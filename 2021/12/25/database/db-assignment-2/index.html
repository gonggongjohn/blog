

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="GONGGONGJOHN">
  <meta name="keywords" content="">
  
    <meta name="description" content="实验要求 功能 实现一个提供网上购书功能的网站后端。网站支持书商在上面开商店，购买者可能通过网站购买。买家和卖家都可以注册自己的账号。一个卖家可以开一个或多个网上商店，买家可以为自已的账户充值，在任意商店购买图书。支持下单 \(\to\) 付款 \(\to\) 发货 \(\to\) 收货的流程。  实现对应接口的功能，见 doc 下面的 .md 文件描述（60% 分数）  用户权限接口，如注册、登">
<meta property="og:type" content="article">
<meta property="og:title" content="当代数据管理系统项目二：书店（Bookstore）">
<meta property="og:url" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/index.html">
<meta property="og:site_name" content="GONGGONGJOHN&#39;s Blog">
<meta property="og:description" content="实验要求 功能 实现一个提供网上购书功能的网站后端。网站支持书商在上面开商店，购买者可能通过网站购买。买家和卖家都可以注册自己的账号。一个卖家可以开一个或多个网上商店，买家可以为自已的账户充值，在任意商店购买图书。支持下单 \(\to\) 付款 \(\to\) 发货 \(\to\) 收货的流程。  实现对应接口的功能，见 doc 下面的 .md 文件描述（60% 分数）  用户权限接口，如注册、登">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/system_arch.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/er_latest.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/pg_user.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/pg_book.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/pg_store.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/pg_order.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/pg_order_book.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/pg_shopping_cart_book.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/mongo_book_info.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/mongo_comment.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/db_ranking.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/mysql_postgresql_compare.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/backend_layer.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/buyer_controller_uml.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/db_concur_test2.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/redis_concur_test2.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/commit.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/branch.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/line_count_java.png">
<meta property="og:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/line_count_all.png">
<meta property="article:published_time" content="2021-12-25T02:00:00.000Z">
<meta property="article:modified_time" content="2022-12-07T11:49:41.956Z">
<meta property="article:author" content="GONGGONGJOHN">
<meta property="article:tag" content="Computer-Science">
<meta property="article:tag" content="Database">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://gonggongjohn.me/2021/12/25/database/db-assignment-2/system_arch.png">
  
  
  <title>当代数据管理系统项目二：书店（Bookstore） - GONGGONGJOHN&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"gonggongjohn.me","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="GONGGONGJOHN's Blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>GONGGONGJOHN&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="当代数据管理系统项目二：书店（Bookstore）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-25 10:00" pubdate>
        2021年12月25日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      21k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      172 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">当代数据管理系统项目二：书店（Bookstore）</h1>
            
            <div class="markdown-body">
              <h2 id="实验要求">实验要求</h2>
<h3 id="功能">功能</h3>
<p>实现一个提供网上购书功能的网站后端。网站支持书商在上面开商店，购买者可能通过网站购买。买家和卖家都可以注册自己的账号。一个卖家可以开一个或多个网上商店，买家可以为自已的账户充值，在任意商店购买图书。支持下单 <span class="math inline">\(\to\)</span> 付款 <span class="math inline">\(\to\)</span> 发货 <span class="math inline">\(\to\)</span> 收货的流程。</p>
<ol type="1">
<li><p><strong>实现对应接口的功能，见 doc 下面的 .md 文件描述（60% 分数）</strong></p>
<ol type="a">
<li><p>用户权限接口，如注册、登录、登出、注销</p></li>
<li><p>买家用户接口，如充值、下单、付款</p></li>
<li><p>卖家用户接口，如创建店铺、填加书籍信息及描述、增加库存 通过对应的功能测试，所有test case都pass。测试下单及付款两个接口的性能（最好分离负载生成和后端），测出支持的每分钟交易数，延迟等</p></li>
</ol></li>
<li><p><strong>为项目添加其它功能：（40% 分数）</strong></p>
<ol type="a">
<li><p>实现后续的流程发货 <span class="math inline">\(\to\)</span> 收货</p></li>
<li><p>搜索图书用户可以通过关键字搜索，参数化的搜索方式；如搜索范围包括，题目，标签，目录，内容；全站搜索或是当前店铺搜索。如果显示结果较大，需要分页（使用全文索引优化查找）</p></li>
<li><p>订单状态，订单查询和取消定单。 用户可以查自已的历史订单，用户也可以取消订单。</p></li>
</ol>
<p>取消定单（可选项，加分 +5 ∼ 10），买家主动地取消定单，如果买家下单经过一段时间超时后，如果买家未付款，定单也会自动取消。</p></li>
</ol>
<h3 id="要求">要求</h3>
<ol type="1">
<li>允许向接口中增加或修改参数，允许修改 HTTP 方法，允许增加新的测试接口，请尽量不 要修改现有接口的 url 或删除现有接口，请根据设计合理的拓展接口（加分项 +2 ∼ 5 分）。 测试程序如果有问题可以提 bug（加分项，每提 1 个 BUG +2, 提 1 个 Pull Request +5）。</li>
<li>核心数据使用关系型数据库(PostgreSQL 或 MySQL 数据库)。blob 数据(如图片和大段 的文字描述)可以分离出来存其它 NoSQL 数据库或文件系统。</li>
<li>对所有的接口都要写 test case，通过测试并计算代码覆盖率（有较高的覆盖率是加分项 +2 ∼ 5）。</li>
<li>尽量使用正确的软件工程方法及工具，如:版本控制，测试驱动开发（利用版本控制是加分项 +2 ∼ 5）。</li>
<li>后端使用技术，实现语言不限；不要复制这个项目上的后端代码（不是正确的实践，减分项 − 2 ∼ 5 ）。</li>
<li>不需要实现页面。</li>
<li>最后评估分数时考虑以下要素：</li>
</ol>
<ol type="a">
<li>实现完整度，全部测试通过，效率合理</li>
<li>正确地使用数据库和设计分析工具，ER 图，从 ER 图导出关系模式，规范化，事务处理，索引等 (c) 其它 · · ·</li>
</ol>
<ol start="8" type="1">
<li>3个人一组，做好分工，量化每个人的贡献度</li>
</ol>
<h2 id="项目实现">项目实现</h2>
<h3 id="系统构架">系统构架</h3>
<p>作为一个经典的电商平台项目，我们采用了<strong>前后端分离</strong>和<strong>微服务</strong>的构架对整个系统进行了设计。整个系统的构架如下图所示（Figure 1）。其中，Nginx 支撑起一个前端维生容器，并向用户提供一个的由 Vue.js 搭建的前端服务<strong>（正向代理）</strong>。根据网页中的 UI 元素，用户可以根据通过配置好的请求方式向后端的对应接口发送 Http 请求（Axios）。请求会首先经过网关，并发送 到一个同样由 Nginx 维护的负载均衡服务器上<strong>（反向代理）</strong>。该服务器维护了当前系统内所有可 用的服务节点，并根据系统负载将所有的请求均摊到对应的服务上。在服务运行的过程中一共 涉及到 4 个数据库：<strong>PostgreSQL 主数据库</strong>、<strong>MongoDB 扩展数据库</strong>、<strong>Redis 缓存数据库</strong>和 <strong>ElasticSearch 搜索服务数据库</strong>，这些数据库通过分离部署的方式被所有服务容器所共享。此 外，一个由 Zookeeper 维护着的分布式 Kafka 消息队列连接着所有的组件，为所有微服务和数 据库间提供消息同步的机制。</p>
<img src="/2021/12/25/database/db-assignment-2/system_arch.png" srcset="/img/loading.gif" lazyload class="" title="system_arch">
<h3 id="数据库设计">数据库设计</h3>
<h4 id="entity-relation图">Entity-Relation图</h4>
<p>本项目的 Entity-Relation 图如下（Figure 2）。书店主要包含用户、商店、商品、订单和购物车五个实体。其中用户和商店构成经营的关系，用户和购物车构成操作的关系，用户与订单依据买家和卖家的角色构成下单和处理的关系；商品和商店构成出售的关系，商品和购物车构成包含的关系，商品和订单构成组成的关系。</p>
<img src="/2021/12/25/database/db-assignment-2/er_latest.png" srcset="/img/loading.gif" lazyload class="" title="er_latest">
<h4 id="关系数据库">关系数据库</h4>
<p>本项目的大部分数据存储在关系数据库中，一共包含 6 张表。</p>
<h5 id="用户表user">用户表（user）</h5>
<p>user 表存储用户的基本信息，包括<strong>用户名（name）</strong>、<strong>地址（address）</strong>、<strong>余额（money）</strong>、<strong>昵称（nickname）</strong>、<strong>密码（password）</strong>和<strong>手机号（phone）</strong>。</p>
<p>以用户名为主键，不额外设置自增主键，简化表结构，易于维护。</p>
<img src="/2021/12/25/database/db-assignment-2/pg_user.png" srcset="/img/loading.gif" lazyload class="" title="pg_user">
<h5 id="商品表book">商品表（book）</h5>
<p>book 表存储商品信息，包括商品 id(id)、详细信息的 id(info_id)、价格 (price)、销量 (sale)、库存 (stock_level)、商店名 (store_name) 和上架时间戳 (time)。</p>
<p>以自增 id 为主键，唯一确定一件商品，同时 store_name 与 info_id 的组合也可以唯一确定 一件商品，在 store_name 与 info_id 上建立联合索引，该索引和主键索引可以分别用于不同的 场景以提高查询效率。在 sale、price 和 time 上分别建立普通索引，用于提高带有对销量、价格或者时间字段排序的查询的效率。</p>
<img src="/2021/12/25/database/db-assignment-2/pg_book.png" srcset="/img/loading.gif" lazyload class="" title="pg_book">
<h5 id="商店表store">商店表（store）</h5>
<p>store 表存储商店信息，包括商店名 (name)、销量 (sale) 和卖家名 (seller_name)。</p>
<p>以商店名为主键，同时在 sale 和 seller_name 上分别建立普通索引，以提高相关查询的效率。</p>
<img src="/2021/12/25/database/db-assignment-2/pg_store.png" srcset="/img/loading.gif" lazyload class="" title="pg_store">
<h5 id="订单表order">订单表（order）</h5>
<p>order 表存储订单信息，包括订单号 (uuid，使用雪花算法生成)、买家用户名 (buyer_name)、发 货地址 (from_address)、物流单号 (logistic_id)、价格 (price)、状态 (status)、商店名 (store_name)、 下单时间戳 (time) 和收货地址 (to_address)。</p>
<p>以 uuid 为主键，同时在 buyer_name 和 store_name 分别建立普通索引，以提高相关查询的 效率。在 time 上建立普通索引，提高需要对时间排序的查询的效率。</p>
<img src="/2021/12/25/database/db-assignment-2/pg_order.png" srcset="/img/loading.gif" lazyload class="" title="pg_order">
<h5 id="订单商品表order_book">订单商品表（order_book）</h5>
<p>order_book 表存储订单里的商品信息，order 与 order_book 是一对多的关系。order_book 表包括订单 id(order_id)、图书详情 id(book_info_id)、数量 (count) 和单价 (single_price)。</p>
<p>以 order_id 和 book_info_id 作为联合主键，唯一确定某一订单里的某件商品。</p>
<img src="/2021/12/25/database/db-assignment-2/pg_order_book.png" srcset="/img/loading.gif" lazyload class="" title="pg_order_book">
<h5 id="购物车商品表shopping_cart_book">购物车商品表（shopping_cart_book）</h5>
<p>shopping_cart_book 表存储用户购物车里的商品信息，这里不单独设置购物车表，因为 用户和购物车存在一对一的关系，购物车与购物车中的商品存在一对多的关系，因此可以 把用户名作为购物车商品表的一个属性，这样即可确定某一商品是在哪个用户购物车里的。 shopping_cart_book 表包括用户名 (buyer_name)、商品 id(book_id)、数量 (count)、单价 (single_price)、商店名 (store_name)。</p>
<p>以 buyer_name 和 book_id 作为联合主键，唯一确定某一用户购物车里的某件商品。</p>
<img src="/2021/12/25/database/db-assignment-2/pg_shopping_cart_book.png" srcset="/img/loading.gif" lazyload class="" title="pg_shopping_cart_book">
<h4 id="文档数据库">文档数据库</h4>
<p>本项目中，文档数据库主要用于存储大段的文字信息和图片信息。</p>
<h5 id="图书详细信息集合-book_info">图书详细信息集合 (book_info)</h5>
<p>book_info 集合存储图书的详细信息，所有对该集合的访问都通过 id 来进行，因此除了 id 之外不再单独构建索引。</p>
<img src="/2021/12/25/database/db-assignment-2/mongo_book_info.png" srcset="/img/loading.gif" lazyload class="" title="mongo_book_info">
<h5 id="图书详细信息索引集合book_info_index">图书详细信息索引集合（book_info_index）</h5>
<p>这一部分存储在 Elastic Search 数据库中，关于 Elastic Search，详见本文的2.5.8节。</p>
<h5 id="评论集合comment">评论集合（comment）</h5>
<p>comment 集合存储商品的评价信息，所有对该集合的访问都通过 id 来进行，因此除了 id 之 外不再单独构建索引。</p>
<img src="/2021/12/25/database/db-assignment-2/mongo_comment.png" srcset="/img/loading.gif" lazyload class="" title="mongo_comment">
<h4 id="键值对数据库">键值对数据库</h4>
<p>本项目采用 redis 这一键值对缓存数据库，将一部分查询频率较高的数据存储到 redis 中，以提升查询效率。关于 redis，详见本文的2.6.1节。</p>
<h4 id="冗余">冗余</h4>
<p>在本项目中，redis 可以看作是关系数据库中某些数据的冗余，当一个查询到来时，如果在 redis 的缓存中命中，便可不用访问关系数据库，直接返回 redis 缓存中的结果，以此来提高查询效率。</p>
<p>Elastic Search 中存储的图书详细信息索引集合可以看作是 mongDB 中图书详细信息集合的 冗余，这里采用冗余是因为 Elastic Search 能够更好地进行搜索操作，提高搜索效率。</p>
<p>从 2.2.2 节可以看出，在关系数据库内部的表之间也存在一些冗余信息，这些冗余都是为了 提高查询效率。</p>
<h4 id="事务处理">事务处理</h4>
<p>本项目对某些操作采用了“事务处理”，如下单操作和付款操作等，以保证数据的一致性和 完整性。</p>
<p>在 SpringBoot 中，我们可以在方法上添加 <span class="citation" data-cites="Transactional">@Transactional</span> 注解来表明该方法为需要进行 “事务处理”的方法。当外部调用带有 <span class="citation" data-cites="Transactional">@Transactional</span> 注解的方法时，其访问数据库的过程会 当作一个事务来完成。当在方法执行过程中抛出 RunTimeException 异常时，会触发事务回滚(Rollback), 以保证数据的一致性，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* BuyerServiceImpl.java */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span> <span class="hljs-comment">// 事务注解</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;OrderMessage&gt; <span class="hljs-title">newOrder</span><span class="hljs-params">(NewOrderBody newOrderBody)</span> </span>&#123;<br>    String buyerName = newOrderBody.getBuyerName();<br>    String storeName = newOrderBody.getStoreName();<br>    <span class="hljs-comment">//Irrelevant codes</span><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span> <span class="hljs-comment">// 事务注解</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;Message&gt; <span class="hljs-title">payment</span><span class="hljs-params">(PayBody payBody)</span> </span>&#123;<br>    String md5Password = DigestUtils.md5DigestAsHex(payBody.getPassword().getBytes());<br>    String userRedisKey = <span class="hljs-string">&quot;user_&quot;</span> + payBody.getBuyerName();<br>    <span class="hljs-comment">//Irrelevant codes</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="数据库选型">数据库选型</h4>
<p>本实验要求我们使用关系型数据库作为系统的核心数据库。现阶段，市面上两大主流的传 统关系型数据库即为 MySQL 和 PostgreSQL(SQL Server 主要服务于 Windows 及其衍生系 统，而本项目设计的目标系统为 Linux 相关系统，故不作考虑)。下面我们来对这两大关系型数 据库进行分析，以确定在该项目中所要选用的核心数据库。</p>
<p>作为 Oracle 旗下的老牌关系型数据库，MySQL 已经在无数的应用上发挥出了其威力。然而， 作为一个以商用为主的软件，MySQL 分为免费的 Community(社区版)和收费的 Enterprise (商业版)，这就导致了其社区版本在许多功能上都受到了限制。此外，尽管 MySQL 的社区版本 开放了源代码，但其使用的 GPL 协议使得二次开发受到了许多的限制。相比之下，PostgreSQL 是一款完全由社区(PostgreSQL Global Development Group)维护的开源关系型数据库，这就 意味着其开发和改进相比 MySQL 更为方便和敏捷。其使用的类 BSD/MIT 协议也使得二次开发变得容易。</p>
<p>PostgreSQL 的宣传标语就是“世界上最先进的开源关系型数据库”，这也意味着其拥有着更新的特性。从功能上来说，PostgreSQL 相比 MySQL 增加了大量的数据类型，如 Array 和 JSON，且在部分原始数据类型上相比 MySQL 也有更小的限制(如 TEXT 类型)。这一特性使 得 PostgreSQL 甚至可以作为 NoSQL 来使用。此外，从运维上来说，PostgreSQL 拥有许多实用 的特性，如:DDL 操作能够放入事务中、能够并发地创建或删除索引、多样化的复制和提交方 式等。这些特性能够帮助我们快速完成对数据库中结构的修改，这对于类似本实验这样的小型项 目是十分重要的。</p>
<p>从 DB Engines 网站上我们可以看到近几年几大关系型数据库的流行程度(Figure 11)。可以 发现，尽管 MySQL 仍然占据着主导的数据库比例，但其市场占比已经开始有下降的趋势;而 PostgreSQL 作为一款新兴的关系型数据库，其市场占有率自 2014 年起就始终以一个极高的速 度增长着，这也充分表明了 PostgreSQL 在实际使用场景下的优势。</p>
<img src="/2021/12/25/database/db-assignment-2/db_ranking.png" srcset="/img/loading.gif" lazyload class="" title="db_ranking">
<p>MySQL 使用了 InnoDB 作为其主要存储引擎(新版本下的 MySQL 支持如 MyISAM 等其 他存储，但由于其不支持完整的事务处理功能，故不常被使用)，尽管自起发明以来已经取得了 长足的进步，但仍然有不少案例报告系统在运行过程中出现了服务器级别的数据库丢失现象。相 比较之下，在实际使用过程中，PostgreSQL 的稳定性更强。从性能上来说，MySQL 使用多线 程技术来提升系统性能的利用率，而 PostgreSQL 使用了多进程技术。在现代处理器上，后者相 比前者有着更好的优化空间。在实际的使用过程中，PostgreSQL 在面对高并发访问请求时相比 MySQL 也的确拥有着更好的表现。除此之外，当数据库负载逼近极限下，PostgreSQL 的性能指 标仍可以维持双曲线甚至对数曲线，到顶峰之后不再下降，而 MySQL 会明显出现一个波峰后下滑。</p>
<p>为了实际测试 MySQL 和 PostgreSQL 的性能表现，我们使用 Sysbench 基准测试工具分别 对同一台部署了 MySQL 和 PostgreSQL 的服务器进行了性能测试，如下图所示(Figure 12)。 测试结果表明，同等配置下，PostgreSQL 的综合性能表现达到了 MySQL 的近两倍。</p>
<img src="/2021/12/25/database/db-assignment-2/mysql_postgresql_compare.png" srcset="/img/loading.gif" lazyload class="" title="mysql_postgresql_compare">
<p>综合上面的结果，在本项目中，我们使用了 PostgreSQL 作为系统的核心数据库。</p>
<p>除此之外，在书店系统中，一本书本商品通常还会带有大量的 BLOB 数据，如图书简介、作 者简介、图书照片等。若直接这些数据放在关系型数据库中，会导致一个字段过长，且不方便存 储和扩展。对于这些数据，文档型数据库(Document Database)是一种极好的存储方式。在 本应用中，我们使用 MongoDB 来作为系统的扩展数据存储数据库。</p>
<h4 id="数据库调优">数据库调优</h4>
<p>除了前文中所讨论的如索引、冗余、事务处理等数据访问优化，对于数据库本身而言，其当前配 置也是一个需要考虑的问题。通常来说，一个数据库的默认配置是较为保守的，在很多场景下无 法完全利用系统中的资源。为了提升设备利用效率，我们需要对数据库的相关配置进行调优。由 于 MongoDB 等 NoSQL 本身已经具有了极强的性能分配机制，因此我们主要针对传统关系型数 据库进行调优。</p>
<p>对于 PostgreSQL 数据库，我们使用如下配置对参数进行了优化(Table 1)：</p>
<table>
<thead>
<tr class="header">
<th>参数名</th>
<th>默认值</th>
<th>参数说明</th>
<th>优化值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>max_connections</td>
<td>100</td>
<td>允许客户端连接的最大数目</td>
<td>10000</td>
</tr>
<tr class="even">
<td>fsync</td>
<td>on</td>
<td>强制把数据同步更新到磁盘</td>
<td>off</td>
</tr>
<tr class="odd">
<td>shared_buffers</td>
<td>24MB</td>
<td>PostgreSQL 能够用于缓存数据的内存大小</td>
<td>1024MB</td>
</tr>
<tr class="even">
<td>work_mem</td>
<td>1MB</td>
<td>内部排序和一些复杂的查询在这个 Buffer 中完成</td>
<td>10MB</td>
</tr>
<tr class="odd">
<td>wal_buffer</td>
<td>768KB</td>
<td>日志缓存区的大小</td>
<td>4096KB</td>
</tr>
<tr class="even">
<td>checkpoint_segments</td>
<td>3</td>
<td>设置 Wal Log 的最大数量(一个 Log 的大小为 16M)</td>
<td>10</td>
</tr>
<tr class="odd">
<td>commit_delay</td>
<td>0</td>
<td>事务提交后，日志写到 Wal Log 上到 wal_buffer写入到磁盘的时间间隔</td>
<td>2</td>
</tr>
<tr class="even">
<td>commit_siblings</td>
<td>5</td>
<td>设置触发 commit_delay 的并发事务数</td>
<td>20</td>
</tr>
</tbody>
</table>
<h3 id="接口设计">接口设计</h3>
<p>本实验共设计并实现了 33 个接口，其中包括 11 个基础接口以及 22 个额外接口。额外接口 一部分用于给前端提供必要的展示数据，对数量较大的数据进行了分页处理，另一部分则用于用 户信息修改、购物车、订单的后续处理 (发货、收货、评价及取消)、商品搜索和商品评论等功能。</p>
<h4 id="基础接口">基础接口</h4>
<h5 id="用户注册">用户注册</h5>
<p><strong>URL:</strong> http://[address]/auth/register</p>
<p><strong>Method:</strong> POST</p>
<p><strong>Request Body</strong></p>
<table>
<thead>
<tr class="header">
<th>变量名</th>
<th>类型</th>
<th>描述</th>
<th>是否可空</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>user_id</td>
<td>string</td>
<td>用户名</td>
<td>N</td>
</tr>
<tr class="even">
<td>password</td>
<td>string</td>
<td>密码</td>
<td>N</td>
</tr>
</tbody>
</table>
<p><strong>Response Status Code</strong></p>
<table>
<thead>
<tr class="header">
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>200</td>
<td>ok</td>
</tr>
<tr class="even">
<td>512</td>
<td>注册失败，用户名已存在</td>
</tr>
</tbody>
</table>
<p><strong>Response Body</strong></p>
<table>
<thead>
<tr class="header">
<th>变量名</th>
<th>类型</th>
<th>描述</th>
<th>是否可空</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>message</td>
<td>string</td>
<td>错误消息，成功时为“ok”</td>
<td>N</td>
</tr>
</tbody>
</table>
<h5 id="用户注销">用户注销</h5>
<h5 id="用户登录">用户登录</h5>
<h5 id="用户修改密码">用户修改密码</h5>
<h5 id="用户登出">用户登出</h5>
<h5 id="卖家创建商铺">卖家创建商铺</h5>
<h5 id="卖家添加书籍信息">卖家添加书籍信息</h5>
<h5 id="卖家添加书籍库存">卖家添加书籍库存</h5>
<h5 id="买家下单">买家下单</h5>
<h5 id="买家付款">买家付款</h5>
<h5 id="买家充值">买家充值</h5>
<h4 id="额外接口">额外接口</h4>
<h5 id="用户获取个人信息">用户获取个人信息</h5>
<h5 id="用户提现">用户提现</h5>
<h5 id="用户修改昵称手机号地址">用户修改昵称、手机号、地址</h5>
<h5 id="卖家删除商店">卖家删除商店</h5>
<h5 id="卖家获得自己的商店列表">卖家获得自己的商店列表</h5>
<h5 id="卖家下架商品">卖家下架商品</h5>
<h5 id="获得商品详细信息">获得商品详细信息</h5>
<h5 id="买家伙的购物车列表">买家伙的购物车列表</h5>
<h5 id="买家把商品加入到购物车">买家把商品加入到购物车</h5>
<h5 id="买家秀改购物车中商品的数量">买家秀改购物车中商品的数量</h5>
<h5 id="买家从购物车下单">买家从购物车下单</h5>
<h5 id="分页获取订单列表">分页获取订单列表</h5>
<h5 id="卖家发货">卖家发货</h5>
<h5 id="买家收获">买家收获</h5>
<h5 id="买家评价">买家评价</h5>
<h5 id="分页获取商品评论">分页获取商品评论</h5>
<h5 id="获取商品星级">获取商品星级</h5>
<h5 id="取消订单">取消订单</h5>
<h5 id="查看商店详情">查看商店详情</h5>
<h5 id="获取商店列表">获取商店列表</h5>
<h5 id="搜索商品分页返回">搜索商品，分页返回</h5>
<h3 id="前端实现">前端实现</h3>
<h4 id="前端技术介绍">前端技术介绍</h4>
<h5 id="vue.js-3">Vue.js 3</h5>
<p>渐进式 JavaScript 框架</p>
<ul>
<li>Vue.js是一套构建用户界面的渐进式框架。</li>
<li>Vue只关注视图层，被设计为可以自底向上逐层应用。</li>
<li>Vue的目标是通过尽可能简单的API实现响应数据的绑定以及视图组件的组合使用。</li>
<li>另外，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页 应用提供驱动。</li>
</ul>
<h5 id="quasar-v2">Quasar v2</h5>
<p>高性能高质量的 Vue.js 3 用户界面框架</p>
<ul>
<li>Quasar是一个高性能的Vue.js前端用户界面设计框架。</li>
<li>Quasar CLI 模式，对每种构建模式(SPA、SSR、PWA、移动应用程序、桌面应用程序和 浏览器扩展)提供了一流的支持，并提供了最佳的开发人员体验，可以高效、灵活地进行 高级开发者设计。</li>
<li>Quasar v2 基于 Vue3，提供高性能的响应式前端组件，可以对页面的风格特性、布局网络、 静态和动态组件进行高效的设计。</li>
<li>Quasar是最注重性能的框架之一。</li>
</ul>
<h5 id="axios">Axios</h5>
<p>易用、简洁且高效的 http 库</p>
<ul>
<li><p>Axios是一个基于promise的HTTP库，可以用在浏览器和node.js中.</p></li>
<li><p>Axios从浏览器中创建XMLHttpRequests，从node.js创建http请求，并且支持Promise API</p></li>
<li><p>Axios可以高效地处理或拦截请求和响应，转换请求数据和响应数据。</p></li>
<li><p>我们将 Axios 进行封装成为 api，简化调用过程、突出功能代码、便捷接口使用</p></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Axios请求使用例</span><br><span class="hljs-keyword">let</span> url = location.protocol + <span class="hljs-string">&quot;//&quot;</span> + ( testurl || location.hostname ) + <span class="hljs-string">&quot;:&quot;</span> +<br>backend_port + <span class="hljs-string">&quot;/buyer/order_cancel&quot;</span>;<br><span class="hljs-keyword">let</span> body = &#123;<br><span class="hljs-string">&quot;buyer_id&quot;</span>: objData.user_id,<br><span class="hljs-string">&quot;uuid&quot;</span>: order_id, &#125;;<br>api.post(url, body).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123; <span class="hljs-keyword">if</span>(response.status == <span class="hljs-number">200</span>)&#123;<br>alert(<span class="hljs-string">&quot;取 消 成 功!&quot;</span>)<br>&#125; &#125;)<br>.catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123; alert(error.response.data.message);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="前端结构设计">前端结构设计</h4>
<h4 id="前端接口设计">前端接口设计</h4>
<h4 id="开发流程">开发流程</h4>
<h4 id="页面展示">页面展示</h4>
<h4 id="特点">特点</h4>
<ul>
<li>数据响应式绑定，一方面简化开发人员对页面内容的操作方式，另一方面使用户实时直观地看到自己正在修改的内容对页面其他数据的影响。</li>
<li>采用高性能框架，减少前端页面内容对用户设备的页面渲染开销，并降低带宽压力。</li>
<li>网页模块化设计，有利于前端框架的维护工作，简化对前端进行进一步开发的流程。</li>
</ul>
<h4 id="后续开发方向">后续开发方向</h4>
<ul>
<li>优化功能:调整页面布局和浏览器本地存储策略，优化用户的信息获取方式，减少用户重复填入信息的操作。</li>
<li>响应式支持:进一优化响应式布局设计，构建 PC、平板电脑、手机端都能获得优秀使用体 验的前端设计。</li>
</ul>
<h3 id="后端实现">后端实现</h3>
<h4 id="springboot服务构架">Springboot服务构架</h4>
<p>为了实现一个完整的电商服务平台并能够应对各种可能的情况，我们必须使用一个足够方便 且功能全面的后端开发框架。作为当前世界上最流行的后端服务框架，Spring 拥有着后端开发 中最全的生态系统。为了方便开发，在本项目中，我们使用了 Springboot 作为后端开发框架。</p>
<p>书店系统的后端构架如下图所示(Figure 30)。整个系统共分为 5 层，拦截层(Interceptor) 负责验证请求的 Token 信息是否合法，控制层(Controller)负责接口的声明和参数传递，服 务层(Service)负责各种服务的实现，持久化层(DAO，Data Access Operator)负责与数 据库的 CRUD 及其他各种操作，模型层(Model)用于声明各种应用中存在的数据实体。</p>
<img src="/2021/12/25/database/db-assignment-2/backend_layer.png" srcset="/img/loading.gif" lazyload class="" title="backend_layer">
<p>为了方便开发和统一接口，我们使用了 ORM(Object Relational Mapping)和 ODM (Object Document Mapping)的方式将 Java 对象和数据库中的实体建立联系。这一功能是 由 Spring 生态中强大的驱动器(Driver)组件所保证的。具体来说，本项目用到的全部模块依赖如下表所示(Table 2)。</p>
<table>
<thead>
<tr class="header">
<th>模块名</th>
<th>版本</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Spring Boot Starter Web</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Mybatis Plus Boot Starter</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Spring Boot Start Data Redis</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Redisson</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Spring Kafka</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Caffeine</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>PostgreSQL</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Hystrix Core</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Lombok</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Spring Boot Starter Test</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>JAVA JWT</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Spring Boot Starter Data MongoDB</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Spring Data ElasticSearch</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>在实际处理请求的过程中，各功能层会被逐层调用，以做到业务的隔离。以买家服务控制器 (BuyerController)为例，其加载流程如下图所示(Figure 31)。可以看到，控制器层首先调用 各服务接口层(Service Interface)，并由服务实现层(Service Implementation)完成所有的请求处理逻辑。对于其中的数据库操作，服务层再接着调用持久化层和模型层完成相应的操作。</p>
<img src="/2021/12/25/database/db-assignment-2/buyer_controller_uml.png" srcset="/img/loading.gif" lazyload class="" title="buyer_controller_uml">
<h4 id="jwt与登录验证">JWT与登录验证</h4>
<h5 id="jwt介绍">JWT介绍</h5>
<p>JSON Web Token (JWT) 是一个开放标准 (RFC7519)，它定义了一种紧凑的、自包含的方 式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数 字签名的。</p>
<h5 id="jwt组成">JWT组成</h5>
<p>JWT 由三部分组成。第一部分为头部 (header)，第二部分为载荷 (payload)，第三部分是签 名 (signature)。头部包含 token 的类型 (“JWT”) 和加密算法名称 (如 SHA256)，载荷包含用 户的有效信息 (不能是敏感信息)，签名用于验证消息在传递过程中是否被更改，要得到签名，需 要仅存在于服务端的密钥 (secret)。</p>
<h5 id="jwt工作流程">JWT工作流程</h5>
<h5 id="jwt优点">JWT优点</h5>
<ul>
<li><p>由于 JSON 的通用性，JWT 是跨语言支持的。</p></li>
<li><p>便于传输，JWT 的构成简单，字节占用小。</p></li>
<li><p>不需要在服务端保存会话信息, 易于应用的扩展。</p></li>
</ul>
<h5 id="jwt应用">JWT应用</h5>
<p>配置 JWT 拦截器 (JWT Interceptor)，编写 JWT 生成和验证方法，除了特定接口直接放 行之外 (如登录、注册不需要 token 验证)，其余接口的请求都需要通过 JWT 验证才能继续进 行。具体代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* JWTInterceptor.java */</span><br><span class="hljs-comment">// JWT拦 截 器</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse</span></span><br><span class="hljs-function"><span class="hljs-params">response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; String token=request.getHeader(<span class="hljs-string">&quot;token&quot;</span>); Message message=<span class="hljs-keyword">new</span> Message();<br><span class="hljs-keyword">try</span>&#123;<br>JWTUtils.verify(token); message.setMessage(<span class="hljs-string">&quot;ok&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>message.setMessage(<span class="hljs-string">&quot;token错 误&quot;</span>); response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>); response.getWriter().write(<span class="hljs-keyword">new</span> ObjectMapper().writeValueAsString(<br>&#125; &#125;<br>&#125;<br>message)); <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><span class="hljs-comment">/* JWTInterceptorConfig.class */</span><br><span class="hljs-comment">// JWT拦 截 器 配 置</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTInterceptorConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>registry.addInterceptor(<span class="hljs-keyword">new</span> JWTInterceptor()) .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>.excludePathPatterns( <span class="hljs-comment">// 不 需 要JWT验 证 直 接 放 行 的 接 口 &quot;/auth/register&quot;,</span><br><span class="hljs-string">&quot;/auth/unregister&quot;</span>, <span class="hljs-string">&quot;/auth/login&quot;</span>, <span class="hljs-string">&quot;/auth/password&quot;</span>, <span class="hljs-string">&quot;/buyer/payment&quot;</span>, <span class="hljs-string">&quot;/buyer/add_funds&quot;</span><br>  );<br>&#125;<br>&#125;<br>  <br><span class="hljs-comment">/* JWTUtils.class */</span><br><span class="hljs-comment">// JWT工 具 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JWTUtils</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SECRET=<span class="hljs-string">&quot;gld-bookstore-*%#@*!&amp;&quot;</span>; <span class="hljs-comment">// 密 钥</span><br><span class="hljs-comment">// JWT生 成</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">generateToken</span><span class="hljs-params">(LoginBody loginBody)</span></span>&#123;<br>JWTCreator.Builder builder= JWT.create(); builder.withClaim(<span class="hljs-string">&quot;name&quot;</span>,loginBody.getName()); builder.withClaim(<span class="hljs-string">&quot;terminal&quot;</span>,loginBody.getTerminal()); Calendar instance=Calendar.getInstance(); instance.add(Calendar.HOUR,<span class="hljs-number">24</span>); builder.withExpiresAt(instance.getTime());<br><span class="hljs-keyword">return</span> builder.sign(Algorithm.HMAC256(SECRET)); &#125;<br><span class="hljs-comment">// JWT验 证</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verify</span><span class="hljs-params">(String token)</span> </span>&#123;<br>JWT.require(Algorithm.HMAC256(SECRET)).build().verify(token); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="orm框架的使用">ORM框架的使用</h4>
<p>在 SpringBoot 中，常用的 ORM 框架有两个，一个是 JPA，另一个是 MyBatis。JPA 可以 实现自动创建数据库表结构，而 Mybatis 却不行。但 Mybatis Plus 封装的 CURD 接口要比 JPA 的接口使用起来更加方便，因此本项目即使用了 JPA 用于自动建表，又使用了 Mybatis Plus 的 CURD 接口。</p>
<h5 id="jpa自动建表">JPA自动建表</h5>
<p>JPA 的自动建表功能十分方便，只需在实体类及其属性上加上相应的注解即可，具体代码如下。</p>
<h5 id="基于-mybatis-plus-的-curd">基于 Mybatis Plus 的 CURD</h5>
<p>使用 Mybatis Plus 封装的 CURD 接口可以方便地操作数据库，几乎不用写 SQL 语句。本项目中用到的 mapper 层接口如下。</p>
<h4 id="用户服务">用户服务</h4>
<h4 id="买家服务">买家服务</h4>
<h4 id="卖家服务">卖家服务</h4>
<h4 id="搜索服务">搜索服务</h4>
<h4 id="elasticsearch与全文搜索">ElasticSearch与全文搜索</h4>
<p>Elasticsearch 是一款基于 Apache Lucene 的分布式文档型数据库。Elasticsearch 的开发目的就 是实现一个能够实时高效的对非结构化数据进行各种检索操作的搜索引擎，因此其被大量的用 于各种 OLAP(Online Analytical Processing)场景。</p>
<p>ElasticSearch 中使用了倒排索引(Inverted Index)技术为加入的每一个文档建立了倒排索 引，这也是其能够实现高效全文搜索的重要基础之一。倒排索引的基本原理如下图所示(Figure 34)。对于每一个加入的文档，系统会使用分词器对其进行分词。随后，系统会建立一个词项 → 文档编号的映射表。如此，当用户发起一个对应词项的文档查询请求时，系统就能快速查询出包 含该词项的文档。</p>
<p>Elasticsearch 默认的分词器对中文的支持并不理想，对于一个中文语句，其往往会将其逐 字拆开作为词项，这显然是不合适的。为此，社区开发者 medcl 基于 Lucene IK analyzer 为 ElasticSearch 提供了一个名为 Analyze IK 的第三方分词。两种分词器对同一个中文语句的分 词结果如下图所示(Figure 35)。可以看到，使用 Analyze IK 对中文语句的分词效果远好于默 认分词器。</p>
<p>在本项目中，Elasticsearch 索引文档的结构如下表所示(Table 3)。其中，Elasticsearch 会对文 本(Text)类型进行分词，并将词项以倒排索引的形式存储在数据库中;而对关键字(Keyword) 类型，ES 直接将其视作一个整体存入数据库。这一区分也符合我们日常过程中对关键字的查询 结果预期。</p>
<p>与访问其他数据库类似，我们同样使用了 ODM 模式将 JAVA 对象与 ElasticSearch 文档相 关联，并使用映射器(Mapper)的方式对其进行访问。除了基本的 CRUD 操作外，Elasticsearch 为我们提供了强大的全文索引功能。我们只需要在 Mapper 中加入相关字段的接口，就可以实现 对对应字段的模糊查询操作:</p>
<p>将测试给定的书本数据插入 Elasticsearch 后的存储情况如下图所示(Figure 36)。可以看到， ES 以分片的方式在不同的空间中管理插入的数据，并为每组数据标记了其索引的位置和各种信 息。</p>
<p>对于一个关键字查询请求，我们首先通过上面的接口方法在各个字段中查询出满足条件的书 籍信息实体。随后，我们通过其对应的 BookinfoID 在书籍实体中查询出出售该种书籍的全部 商店，并根据用户给定的请求参数对结果进行编排后返回给用户。相关实现代码如下:</p>
<h3 id="高可用">高可用</h3>
<p>高可用性(High Availability)是指系统无中断地执行其功能的能力超过其同级别的系统， 代表系统的可用性程度，是进行系统设计时的准则之一 [Wik21a]。</p>
<p>造成服务不可用的原因有很多，其中一个十分重要的原因便是过多的并发请求(Concurrent Request)。在 WEB 服务中，并发请求是指一个或多个用户在同一时刻或相隔极短的时刻内发 送至目标服务器，并使得服务器需要同时处理并响应的请求。随着互联网规模的高速发展，这一 现象在一些热门服务供应商中体现的越来越明显。近年来，因为短时间内收到大量请求使得服务 器崩溃导致无法提供正常服务的事故屡次发生(Figure 37, 38)，这些事故严重影响了用户的体 验和服务的质量，也使得学术界和工业界加强了对高可用系统设计的重视。</p>
<p>一个高可用系统的设计通常具有以下三条原则：</p>
<ul>
<li>消除单点故障(Elimination of single points of failure)</li>
<li>可靠的交叉点服务(Reliable crossover)</li>
<li>提前检测故障并快速恢复(Detection of failures as they occur)</li>
</ul>
<p>在本实验中，我们需要测出书店系统中下单和付款接口的吞吐量，这正是一个极好的高并发 场景的实例。根据上述的三条原则，我们实现了一系列策略来提升这两个接口的吞吐量，并使得 整个书店系统在各种情况下都能够保持较高的可用性。</p>
<h4 id="redis与缓存数据库">Redis与缓存数据库</h4>
<p>由于需要管理的数据量通常十分庞大(GB 甚至 TB 级)，且需要支持完整的事务处理能力，常 规的关系性数据库通常使用磁盘来对数据进行维护，并使用页(Page)为单位对数据进行存取。 因此，对数据库中的内容进行一次访问通常具有很高的 I/O 代价。通过实际的测试我们也发现， 在整个服务的响应逻辑中，对数据库的访问代价占据了整个请求处理过程中绝大部分的耗时。在 高并发场景下，这一时间开销使得数据库系统很快就会遇到性能瓶颈，并使得后续的请求难以得 到正确的响应。</p>
<p>Redis(Remote Dictionary Server，远程字典服务) 是一款开源的、基于内存存储的分布 式 Key-Value 型数据库 [Wik21b]。作为 NoSQL 的一种，Redis 设计的宗旨就是为了在面对大量 随机读写请求时能够以尽可能高的效率存取数据，因此其天然地拥有极高的并发处理能力。经验 值表明，在一台常规的小型笔记本上，Redis 能够支持约 110000 次/秒的写操作和 81000 次/秒 的读操作 [Jai19]，这一数值几乎是传统关系型数据库吞吐量的近 100 倍。因此，使用 Redis 作 为主数据库的缓存数据库来提升整个服务的响应能力是一个十分合适的选择。</p>
<p>我们使用 JMeter 接口压测工具，分别向直接访问 Postgresql 数据库和使用了 Redis 缓存的 两个测试接口发送了 10000 次并发请求，其响应结果如下图所示(Figure 39, 40)。可以看到，使 用了 Redis 缓存的接口吞吐量几乎是直接访问 Postgresql 数据库接口的两倍，前者的平均响应 时间更是比后者快了整整 5 倍。</p>
<img src="/2021/12/25/database/db-assignment-2/db_concur_test2.png" srcset="/img/loading.gif" lazyload class="" title="db_concur_test2">
<img src="/2021/12/25/database/db-assignment-2/redis_concur_test2.png" srcset="/img/loading.gif" lazyload class="" title="redis_concur_test2">
<p>要使用 Redis 作为缓存，我们就需要分析在当前业务中哪些数据是经常被访问的数据，即所 谓的热点数据。在当前应用中，热点数据的访问主要发生在下单和付款两个接口请求的处理上。 对于下单操作，系统需要读取商品的库存、价格;对于付款操作，系统需要读取用户的密码、账 户余额及订单的总价。</p>
<p>书店系统的 Redis 缓存结构如下表所示(Table 4)。其中，user 键和 store 键分别维护当前系 统中所有的用户 ID 和商店 ID，用于快速判断下单和付款请求是否合法;stock_{图书 ID}<em>{商店 ID} 和 price</em>{图书 ID}<em>{商店 ID} 键分别用于维护热点商品的库存和价格信息(分开存储 是为了支持 Redis 的原子级自增(Increment)和自减(Decrement)操作);user</em>{用户名} 键用于存放已登录用户当前的密码及账户余额，用于在付款请求中快速确认用户身份并判断用 户账户是否有足够的足额支付当前订单;order_{订单号} 键用于临时存放下单成功的订单总价(若订单创建后的 T 时刻内仍没有被付款接口更新，则该 Redis 键自动过期，也即订单自动取 消)。</p>
<p>使用 Redis 作为缓存后，高并发接口的数据查询流程如下图所示(Figure 41)。对于一个下 单/付款请求，服务会先查看 Redis 中是否存在相应的缓存，若缓存存在，则直接进行判断和处 理操作;若缓存不存在，则服务从主数据库中查询数据，并将查询到的数据放入 Redis 缓存中。 如此，当收到大量对热点数据的操作请求时，服务就可以快速响应用户的请求，极大的提高了接 口的吞吐能力。</p>
<h4 id="布隆过滤器与缓存防穿透">布隆过滤器与缓存防穿透</h4>
<p>从上面的实现过程我们可以发现，当用户对高并发接口发起一个请求时，服务会先查询 Redis 缓 存，若缓存不命中，再访问数据库进行查询。然而，若用户查询的值并不存在于系统中(也即数 据库中不存在)，则服务必然会对数据库发起查询请求。当这一查询数量增加时，就会有大量的 查询请求直接打在数据库上，导致数据库服务崩溃。此时，缓存起不到任何流量分摊的作用，就 如同不存在一样，也即产生所谓的缓存穿透(Cache Penetration)问题。</p>
<p>在实际应用场景中，要解决缓存穿透问题，通常具有如下三种方法 [kkl21]:</p>
<ul>
<li>增加校验层，让用户请求频率降低</li>
<li>当数据库查询不到目标值时将对应的缓存键设置为空值</li>
<li>维护一张系统中所有书本的 ID 值的集合，在收到请求时过滤无效查询</li>
</ul>
<p>在这里我们使用第三种方法。</p>
<p>要维护系统中所有的书本 ID 集合，我们首先能够想到的就是在 Redis 缓存中增加一个类型 为集合的 bookID 键来存放所有的书本 ID。然而，当书本数量增长时，这一空间开销将逐渐变 得难以接受。注意到，对于每一个书本 ID，我们只需要记录其是否存在于系统中，因此我们可 以使用位图(Bitmap)技术来存放所有的 ID。事实上，我们无需精准的过滤每一个无效请求， 只需要将请求数量降低到一个数据库能够承受的范围即可。此时，我们完全可以使用一种概率型 数据结构来对请求的 ID 进行判断，以减少维护全部书本集合所需要的空间开销。</p>
<p>布隆过滤器(Bloom Filter)是一种概率型数据存储结构，其工作原理如下图所示(Figure 43)。系统首先设置一个固定长度的位数组，随后对于每一个给定的元素，系统会通过确定的 k 个哈希函数将其映射到对应的位上。于是，对于一个待查询元素，系统只需要判断其以同样 的方式映射后的位置上是否已被置为 1 即可。具体来说，布隆过滤器可以在上界确定的空间 O(m), m ∈ N + 内对请求的元素给出如下的应答:</p>
<ul>
<li><p>可能存在于集合中</p></li>
<li><p>一定不存在于集合中</p></li>
</ul>
<p>布隆过滤器可以保证给出第二种应答时一定正确;而对于第一种应答，对于一个由 k 个哈希 函数组成的长度为 m 的布隆过滤器，其面对 n 个总数据时的误判率约为 (1 − exp{− kn })k，这一结果在我们的场景下是完全可以接受的。</p>
<p>通过将布隆过滤器继承到 Redis 缓存中，用户在请求下单/付款接口时服务的数据查询流程 如下图所示(Figure 44)。在系统启动时，服务会从主数据库中获取当前系统中所有存在的书本 ID，并设置布隆过滤器中的响应位。这样，当接收到一个请求时，系统会首先通过布隆过滤器判 断书本 ID 是否可能存在于系统中，若判断结果为一定不存在则直接返回。如此，最终到达缓存 和主数据库的请求量就会被大大降低，减少了系统被恶意攻击时可能的宕机事故发生。</p>
<p>在 Springboot 中，我们可以使用 Google 的 Guava 模块或 Redis 原生的 Redisson 模块来实现布隆过滤器的继承，这里我们使用了后者。</p>
<h4 id="caffeine与多级缓存">Caffeine与多级缓存</h4>
<p>通过 Redis 缓存，我们已经可以使得系统在面对相对较高的并发请求时保证响应的效率。那 么我们是否又可能进一步的优化，让请求能够更快的得到应答呢?答案是肯定的。</p>
<p>注意到，在秒杀活动时，用户对一件商品的请求量与该商品本身的库存数往往是严重不匹配 的(例如一件商品的库存只有 100 件，而在秒杀活动瞬间服务器收到了 10000 次下单请求)，我 们希望能够在请求达到服务器时就能提前过滤掉这些多余的无效请求，让尽可能合理的请求数 到达之后的服务。</p>
<p>在绝大多数使用虚拟内存技术的现代操作系统上，进程内数据通讯只需要引用同一段虚拟 内存地址即可，而进程间数据通讯通常要涉及内存拷贝 [TB15]。尽管相比传统关系型数据库， Redis 已经能够提供较高的吞吐效率，但在面对如此大量的请求时，服务进程每次都要与其交互 仍然具有不小的代价(若 Redis 服务器与主服务器部署在不同的服务器主机上，交互过程还涉及 到 RPC 调用)。因此，我们希望能够在服务内的缓存中就完成对某些请求的判断操作，这也就 引出了多级缓存(Multi-Level Cache)的概念。</p>
<p>要过滤掉库存数量以外的请求，一个朴素的想法就是在缓存中对于每一个热点商品维护一个 “商品是否已售完”的标识符，当检测到库存降低到 0 时，就将缓存中的标识符设为 1。然而，由 于此时的请求是并发的，普通的 HashMap 并不能保证在面对如此大量的设置操作时的进程安全 性。幸运的是，社区开发者 ben-manes 提供了一个名为 Caffeine 的高性能缓存库，其可以支持以下的一些特性:</p>
<ul>
<li><p>异步的自动缓存项加载</p></li>
<li><p>当缓存大小达到上限时可根据访问频率和最近访问时间替换缓存</p></li>
<li><p>可根据最近访问时间对缓存项设置过期时间</p></li>
<li><p>检测到过期请求时自动刷新缓存项</p></li>
<li><p>弱引用时缓存键自动打包</p></li>
<li><p>弱引用或软引用时值自动打包</p></li>
<li><p>替换缓存事件通知</p></li>
<li><p>支持双写操作(一份写入缓存，一份写入外部空间)</p></li>
<li><p>可对缓存访问的特征进行聚合统计</p></li>
</ul>
<p>这些特性使得其可以很好的应对短时间内的高并发请求并保证数据的进程安全性。因此，我 们使用 Caffeine 来建立多级缓存机制。</p>
<p>集成了多级缓存后，一个下单请求的处理流程如下图所示(Figure 45)。当接口收到请求后， 系统会首先检查请求的 BookID 是否在 Caffeine 缓存中已经被标记为售空，若标记存在，则服 务直接返回;若不存在，再使用前文中提到的流程继续处理下单请求。</p>
<h4 id="kafka与消息队列">Kafka与消息队列</h4>
<p>在微服务构架中，我们通常会将服务分拆到多个服务器上，以方便运维和负载分离。此时， 不同服务器间的通讯和协同工作就成为了一个重要的问题。由于不同服务的处理速率差异，对于 一个特定的请求，不同服务能够接受并开始处理的时刻也各不相同。若直接让上一个服务访问下 一个服务，则会造成大量的等待时间。更进一步的，若请求响应链中的其中一个服务宕机，则 会造成整个响应过程卡死，造成请求响应失败。这时候，我们便可以使用消息队列(Message Queue)机制来解决这一问题。消息队列提供了一个公共的状态空间，使得与其关联的每个服务 都能够向其中发送/从其中获取消息。当响应链中的每个服务完成处理后，便向消息队列发送一 条消息，并标识需要接受这条消息的服务。当下游服务完成了其他请求后，便可以从消息队列中 拉取相应的消息并继续完成请求处理。这样，整个响应就可以以异步的方式完成，减少服务处理 的等待时间。</p>
<p>Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，其基于 Zookeeper 实现的分片 式中介服务可以很好的作为一个消息队列来使用。Kafka 的工作原理如下图所示(Figure 46)。 在一个带有 Kafka 消息队列的系统中，服务被分为生产者和消费者。生产者通过 Push 操作向 Kafka 的特定话题(Topic)发送消息，消费者通过 Pull 操作从对应的话题中拉取消息。其中， 每个 Kafka 协调器都被维护在一个 Kafka 容器中，并被统一注册到一个 Zookeeper 集群中。这 样分布式的管理方式使得 Kafka 拥有很强的伸缩性和极高的消息吞吐能力。</p>
<p>集成了消息队列后，一个下单请求的完整处理流程如下图所示(Figure 47)，这也是本项目最 终所采用的下单请求处理逻辑(付款请求使用了同样的逻辑)。请求到达后，系统会通过多级缓 存对请求进行一系列判断，并将无效请求快速过滤。随后，对于缓存命中的合法请求，系统会利 用 Redis 缓存中的信息快速创建订单，并将订单的信息放置到 Kafka 消息队列中。至此，下单 请求的处理已全部完成，服务会直接将订单号快速返回给用户。与此同时，一个异步的后台进程 会从消息队列中抽取下单成功的消息，并继续接管这一处理流程，将订单信息写入主数据库中。 这一分离式的服务处理流程构成了本系统能够应对高并发请求的重要基础。</p>
<h4 id="nginx与负载均衡">Nginx与负载均衡</h4>
<p>通过上面的各种缓存和优化技术，我们已经基本解决了高并发请求处理中数据库访问的性 能瓶颈。然而，由于服务本身也依托于服务器主机的性能之上，当请求规模扩大到一定数量时， 服务本身的处理性能就会成为瓶颈。对于服务的性能瓶颈问题，我们通常有两种处理方法:向上 扩展(Scale Up)和向外扩展(Scale Out)。其中，前者意味着通过升级硬件等方式提升单台 主机的性能，而后者则采用增加处理节点的方式来提升整个系统的处理能力。在当前技术工艺的 限制下，我们很难通过 Scale Up 来从根本上提升系统的性能潜能，因此我们往往会采用 Scale Out 的方式来对服务进行扩展。</p>
<p>当我们在多个节点上部署同一个服务后，我们就可以将接受到的请求君叹道这些节点上进行并行处理。为此，我们就需要引出所谓的负载均衡(Load Balancing)技术。</p>
<p>当前，学术界和工业界都提出了一系列负载均衡的实现方式，其中最常用的便是同样被我们 用作前端维生容器的 Nginx。Nginx 可以通过一种名为反向代理(Reverse Proxy)的方式来实现负载均衡，其基本原理如下图所示(Figure 49)。</p>
<h2 id="项目部署">项目部署</h2>
<p>本项目采用了前后端分离架构进行开发。要在生产环境部署本项目，目标系统上至少需要安装的依赖环境及其版本如下表所示(Table 5)。</p>
<p>若要从源码部署前端项目，你至少需要一个包含 quasar/cli@1.2.1 模块的 NodeJS 开发 环境。首先进入仓库的 frontend 目录，使用 quasar build 对项目进行打包。随后，前端项目的 静态资源会生成在项目的 frontend/dist/spa 目录下。之后，你需要一个能够支持前端资源的 服务容器，在这里我们使用了 Nginx 作为前端维生容器。一个部署完成的 Nginx 前端环境运行 状态如下图所示(Figure 50)。Nginx 的默认服务端口为 8080(可能与后端冲突，可自由更改)， 我们只需使用浏览器访问该地址即可。</p>
<p>后端的部署方式分为 JAR 包部署和 WAR 包部署两种方式。Springboot 本身包含了一个 Tomcat 服务容器，若使用前一种方式部署，框架就会自动将一个 Tomcat 容器集成至最终的 JAR 包中。此时，我们只需要在生产环境安装相应的 JAVA 运行环境即可。若想要在生产环境 下使用自定义的 Tomcat 或其他服务容器，则可以选择使用 WAR 包的方式进行部署。</p>
<p>就参数而言，后端服务的默认端口为 8080;PostgreSQL 连接地址为 127.0.01:5432，用 户名和密码均为 postgres，系统中应存在名称为 bookstore 的数据库;MongoDB 连接地址 为 127.0.0.1:27017;Redis 连接地址为 127.0.0.1:6379;Kafka 连接地址为 127.0.0.1:9092; ElasticSearch 连接地址为 127.0.0.1:9200。如对其中任意参数进行修改，则需要重编译后端项目。</p>
<h2 id="项目测试">项目测试</h2>
<h3 id="接口测试">接口测试</h3>
<h4 id="单元测试规范">单元测试规范</h4>
<h4 id="junit5">JUnit5</h4>
<h4 id="基础接口测试代码移植">基础接口测试代码移植</h4>
<h4 id="基础接口测试">基础接口测试</h4>
<h4 id="额外接口测试">额外接口测试</h4>
<h3 id="代码覆盖率">代码覆盖率</h3>
<p>我们使用了 Intellij IDEA 开发工具中自带的 Run with Coverage 功能记录了运行全部测 试时项目代码的覆盖率，结果如下图所示(Figure 53)。可以看到，我们编写的全部测试可以使 得类覆盖率达到 98.7%，方法覆盖率达到 91.7%，行覆盖率达到 90.3%。经过分析我们还可以 发现，绝大多数未覆盖的代码均为构造函数和形如 try...catch... 这样的异常处理函数，这些函 数保证了我们的系统能够应对各种突发状况和边界情况，因此其存在于代码中是必要的。若只考 虑实际功能段的代码，覆盖率将可得到进一步的提升。</p>
<h3 id="吞吐量测试">吞吐量测试</h3>
<p>我们使用实验要求中给出的测试工具对所实现的系统进行吞吐量测试(fe/test/test_bench.py)。 在 2020 版 13 英寸 Macbook Pro 上(2GHz 4 核 Intel Core i5 + 16GB LPDDR4X)上，下单和 付款接口吞吐量的测试结果如下图所示(Figure 54)。可以看到，系统的吞吐量可以达到 83000 左右，延迟可以维持在 0.008 左右。</p>
<p>然而，在测试过程中我们发现，实验要求中给出的这一测试程序实际上并不能正确给出两个 接口的真实吞吐量。通过修改配置文件中 Request_Per_Session(fe/conf.py)的值，我们甚至可 以测出超过 130 万的吞吐量(Figure 55)。作为对比，2020 年天猫双 11 购物节达到的最大流量 洪峰也仅达到了 583000 笔交易/秒，这一吞吐量已经给全面云原生化的阿里云造成了极大的压 力，因此测试程序给出的这一测试结果显然是不合理的。</p>
<p>为了得到更为可信的结果，我们还是使用 JMeter 接口压测工具对系统进行多线程压测。测 试的相关设置如下图所示(Figure 56, 57)。我们使用 1000 个线程来模拟 1000 个用户同时下单 时的场景，其中每个用户对同一本书进行 10 次下单操作，共 10000 次并发请求操作。</p>
<p>我们分别将请求的书本库存设置为 10000 和 100，用于分别模拟平日里普通下单场景下(商 品库存足够时)和活动促销时秒杀场景下(商品库存远小于请求量)的下单操作。经过测试，在 普通场景下，系统的下单接口吞吐量可以达到 1142 笔交易/秒(68562 笔交易/分钟)(Figure 58);在秒杀场景下，系统的吞吐量可以达到 1972 笔交易/秒(118320 笔交易/分钟)(Figure 59)。这一结果远高于直接对数据库进行访问的朴素服务响应流程(约 300 ∼ 500 笔交易/秒)， 极有力的表明了我们设计的一系列负载平衡措施起到了预期的效果。</p>
<h2 id="开发说明">开发说明</h2>
<h3 id="版本控制">版本控制</h3>
<p>本项目的全部工作均在水杉码源提供的 GitLab 平台上完成，并使用了 Git 工具进行版本控 制。开发过程中，项目成员共进行了 43 次提交，部分提交图如下图所示(Figure 60)。</p>
<img src="/2021/12/25/database/db-assignment-2/commit.png" srcset="/img/loading.gif" lazyload class="" title="commit">
<p>除此之外，我们还根据分工在项目仓库中建立了三个分支:master、frontend、backend (Figure 61)，方便成员集中开发自己模块上的功能。通过 Merge Request 功能，我们就能将分支中的更新合并到主分支上(Figure 62)。</p>
<img src="/2021/12/25/database/db-assignment-2/branch.png" srcset="/img/loading.gif" lazyload class="" title="branch">
<h3 id="项目分工">项目分工</h3>
<p>本项目共有 3 位成员，其中gxx为项目组长，dxx和lxx为项目成员。三位成员均摊了本项目的全部工作量，对本项目的贡 献相当。具体的，三位项目成员在本项目中的主要贡献及负责的任务如下表所示(Table 6)。</p>
<table>
<tbody>
<tr class="odd">
<td>gxx</td>
<td>1/3</td>
<td>系统构架设计、数据库选型与调优、全文搜索、高可用设计与实现</td>
</tr>
<tr class="even">
<td>dxx</td>
<td>1/3</td>
<td>ER 图与关系模式设计，接口设计，前端设计与开发</td>
</tr>
<tr class="odd">
<td>lxx</td>
<td>1/3</td>
<td>系统功能设计、后端设计与开发、接口测试</td>
</tr>
</tbody>
</table>
<h2 id="后记">后记</h2>
<p>至此，本项目的全部功能和实现过程已叙述完毕。本项目从设计、构思到完成全部开发周期 超过两个月时间，仅后端源代码就超过 5000 行(Figure 63)，合计源代码更是达到了超过 70 万行(Figure 64)。项目的部分构架参考了淘宝、当当网、Bilibili 等知名电商及多媒体服务平 台的现役及历史构架，也使得我们得以对当今工业界一个完整电商平台的全开发流程有了一个 全景式的了解。</p>
<img src="/2021/12/25/database/db-assignment-2/line_count_java.png" srcset="/img/loading.gif" lazyload class="" title="line_count_java">
<img src="/2021/12/25/database/db-assignment-2/line_count_all.png" srcset="/img/loading.gif" lazyload class="" title="line_count_all">

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Computer-Science/">Computer-Science</a>
                    
                      <a class="hover-with-bg" href="/tags/Database/">Database</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/16/contemporary-ai/contemporary-ai-exp-1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">当代人工智能 课程项目一 文本分类</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/24/machine-learning/dase-alg-exp-summary/">
                        <span class="hidden-mobile">数据科学与工程算法基础 文本摘要实验</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
