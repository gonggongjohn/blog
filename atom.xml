<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GONGGONGJOHN&#39;s Blog</title>
  
  
  <link href="http://gonggongjohn.github.io/blog/atom.xml" rel="self"/>
  
  <link href="http://gonggongjohn.github.io/blog/"/>
  <updated>2020-10-11T12:44:47.214Z</updated>
  <id>http://gonggongjohn.github.io/blog/</id>
  
  <author>
    <name>GONGGONGJOHN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>和式的求解方法</title>
    <link href="http://gonggongjohn.github.io/blog/2020/10/11/sum-solve/"/>
    <id>http://gonggongjohn.github.io/blog/2020/10/11/sum-solve/</id>
    <published>2020-10-11T12:40:02.000Z</published>
    <updated>2020-10-11T12:44:47.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扰动法"><a href="#扰动法" class="headerlink" title="扰动法"></a>扰动法</h2><p>扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。</p><a id="more"></a><p>令 <script type="math/tex">S_n = \sum_\limits{0 \leq k \leq n} a_k</script></p><script type="math/tex; mode=display">\begin{aligned}S_n + a_{n+1} &= \sum_\limits{0 \leq k \leq n+1} a_k \\&= a_0 + \sum_\limits{1 \leq k \leq n+1} a_k \\&= a_0 + \sum_\limits{1 \leq k+1 \leq n+1} a_{k+1} \\&= a_0 + \sum_\limits{0 \leq k \leq n} a_{k+1}\end{aligned}</script><p>若能将 <script type="math/tex">\sum_\limits{0 \leq k \leq n} a_{k+1}</script> 写为 <script type="math/tex">S_n</script> 的表达式，即可求出该求和式的通项公式</p><blockquote><p><strong>Example1:</strong></p><p>求等比数列和 <script type="math/tex">S_n = \sum_\limits{0 \leq k \leq n} a q^k \ \ (q \neq 1)</script> 的通项公式</p><p><strong>解：</strong> 由上述公式可知</p><script type="math/tex; mode=display">\begin{aligned}S_n + a_{n+1} &= a + \sum_\limits{0 \leq k \leq n} aq^{k+1} \\&=a + q \sum_\limits{0 \leq k \leq n} aq^k \\&=a + q S_n\end{aligned}</script><p>从而 $(1-q)S_n = a - aq^{n+1}$</p><p>故 $S_n = \frac{a\left(1-q^{n+1} \right)}{1-q} \ \ (q \neq 1)$</p><p><strong>Example2:</strong></p><p>求等比差数列和 <script type="math/tex">S_n = \sum_\limits{0 \leq k \leq n} k \cdot q^k \ \ (q \neq 1)</script> 的通项公式</p><p><strong>解：</strong> 由上述公式可知</p><script type="math/tex; mode=display">\begin{aligned}S_n + a_{n+1} &= 0 + \sum_\limits{0 \leq k \leq n} (k+1) \cdot q^{k+1} \\&=\sum_\limits{0 \leq k \leq n} k \cdot q^{k+1} + \sum_\limits{0 \leq k \leq n} q^{k+1} \\&=q \sum_\limits{0 \leq k \leq n} k \cdot q^k + q \sum_\limits{0 \leq k \leq n} q^k \\&=q S_n + q \cdot \frac{1-q^{n+1}}{1-q}\end{aligned}</script><p>从而 $(1-q)S_n = \frac{q-q^{n+2}}{1-q} - (n+1) \cdot q^{n+1}$</p><p>故 </p><script type="math/tex; mode=display">\begin{aligned}S_n &= \frac{q-q^{n+2}}{(1-q)^2} - \frac{(n+1) \cdot q^{n+1}}{1-q} \\&= \frac{q-(n+1)q^{n+1} + nq^{n+2}}{(1-q)^2} \ \ (q \neq 1)\end{aligned}</script></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;扰动法&quot;&gt;&lt;a href=&quot;#扰动法&quot; class=&quot;headerlink&quot; title=&quot;扰动法&quot;&gt;&lt;/a&gt;扰动法&lt;/h2&gt;&lt;p&gt;扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Sequence" scheme="http://gonggongjohn.github.io/blog/tags/Sequence/"/>
    
  </entry>
  
  <entry>
    <title>递归式的解法</title>
    <link href="http://gonggongjohn.github.io/blog/2020/10/11/recursion-solve/"/>
    <id>http://gonggongjohn.github.io/blog/2020/10/11/recursion-solve/</id>
    <published>2020-10-11T12:39:48.000Z</published>
    <updated>2020-10-11T12:52:00.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求和因子法"><a href="#求和因子法" class="headerlink" title="求和因子法"></a>求和因子法</h2><p>对于形如 <script type="math/tex">a_n T_n = b_n T_{n-1} + c_n</script>，我们可以求出其通项公式，下面我们来推导这一公式。</p><p>我们考虑通过变量替换的方式将 <script type="math/tex">T_n</script> 前的 <script type="math/tex">a_n</script> 和 <script type="math/tex">b_n</script> 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 <script type="math/tex">b_n T_{n-1}</script> 能够通过 <script type="math/tex">a_n T_n</script> 表示出来（该表达式通常被称为求和因子）。设该表达式为 <script type="math/tex">s_n</script>，两边同乘以 <script type="math/tex">s_n</script>，即为 <script type="math/tex">s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n</script></p><a id="more"></a><p>注意到等式左边均为第 $n$ 项，而右边为 <script type="math/tex">T_{n-1}</script>，故考虑将右边第一项变为 <script type="math/tex">s_{n-1}a_{n-1}T_{n-1}</script>。要做到这一点，就是要让 <script type="math/tex">s_n b_n = s_{n-1} a_{n-1}</script>，也即 <script type="math/tex">s_n = s_{n-1} \cdot \frac{a_{n-1}}{b_n}</script>。做递推，得到 <script type="math/tex">s_n = \frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2} \cdot s_1</script>。故仅需取 <script type="math/tex">s_n = \frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2}</script> 或该式的常数倍即可。</p><p>现在，我们仅需令 <script type="math/tex">P_n = s_n a_n T_n</script>，即可将原式化简为 <script type="math/tex">P_n = P_{n-1} + s_n c_n</script></p><p>故 <script type="math/tex">P_n = P_0 + \sum_\limits{k=1}^n s_k c_k</script></p><p>故 <script type="math/tex">s_n a_n T_n = s_0 a_0 T_0 + \sum_\limits{k=1}^n s_kc_k = s_1b_1T_0 + \sum_\limits{k=1}^n s_kc_k</script></p><p>故 <script type="math/tex">T_n = \frac{1}{s_n a_n} \left( s_1b_1T_0 + \sum_\limits{k=1}^n s_kc_k \right)</script></p><blockquote><p>Example:</p><p>已知Hanoi问题满足以下递归表达式，试求出其通项公式</p><script type="math/tex; mode=display">\left\{\begin{aligned}&T_0 = 0 \\&T_n = 2T_{n-1} + 1\end{aligned}\right.</script><p><strong>解：</strong> 由 $a_n = 1, b_n = 2$ 可知求和因子 $s_n = \frac{1}{2^{n-1}}$。由于 $s_n$ 乘以常数倍不影响其效果 ，故为了方便起见令 $s_n = \frac{1}{2^n}$</p><p>两边同乘以 <script type="math/tex">s_n = \frac{1}{2^n}</script>，得到 <script type="math/tex">\frac{T_n}{2^n} = \frac{T_{n-1}}{2^{n-1}} + \frac{1}{2^n}</script></p><p>令$P_n = \frac{T_n}{2^n}$，则 </p><script type="math/tex; mode=display">\left\{\begin{aligned}&P_n = P_{n-1} + \frac{1}{2^n} \\&P_0 = 0\end{aligned}\right.</script><p>故 <script type="math/tex">P_n = \sum_\limits{k=1}^n \frac{1}{2^k} = 1-\left(\frac{1}{2}\right)^n</script>，即 <script type="math/tex">\frac{T_n}{2^n} = 1-\left(\frac{1}{2}\right)^n</script></p><p>故 <script type="math/tex">T_n = 2^n - 1</script></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;求和因子法&quot;&gt;&lt;a href=&quot;#求和因子法&quot; class=&quot;headerlink&quot; title=&quot;求和因子法&quot;&gt;&lt;/a&gt;求和因子法&lt;/h2&gt;&lt;p&gt;对于形如 &lt;script type=&quot;math/tex&quot;&gt;a_n T_n = b_n T_{n-1} + c_n&lt;/script&gt;，我们可以求出其通项公式，下面我们来推导这一公式。&lt;/p&gt;
&lt;p&gt;我们考虑通过变量替换的方式将 &lt;script type=&quot;math/tex&quot;&gt;T_n&lt;/script&gt; 前的 &lt;script type=&quot;math/tex&quot;&gt;a_n&lt;/script&gt; 和 &lt;script type=&quot;math/tex&quot;&gt;b_n&lt;/script&gt; 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 &lt;script type=&quot;math/tex&quot;&gt;b_n T_{n-1}&lt;/script&gt; 能够通过 &lt;script type=&quot;math/tex&quot;&gt;a_n T_n&lt;/script&gt; 表示出来（该表达式通常被称为求和因子）。设该表达式为 &lt;script type=&quot;math/tex&quot;&gt;s_n&lt;/script&gt;，两边同乘以 &lt;script type=&quot;math/tex&quot;&gt;s_n&lt;/script&gt;，即为 &lt;script type=&quot;math/tex&quot;&gt;s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n&lt;/script&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Sequence" scheme="http://gonggongjohn.github.io/blog/tags/Sequence/"/>
    
  </entry>
  
  <entry>
    <title>快速排序时间复杂度分析</title>
    <link href="http://gonggongjohn.github.io/blog/2020/10/10/qsort-analyze/"/>
    <id>http://gonggongjohn.github.io/blog/2020/10/10/qsort-analyze/</id>
    <published>2020-10-10T07:46:07.000Z</published>
    <updated>2020-10-10T07:52:36.300Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序的平均比较次数满足以下递归表达式：</p><script type="math/tex; mode=display">\left\{\begin{aligned}&C_0 = 0 \\&C_n = n + 1 + \frac{2}{n}\sum_\limits{k = 0}^{n-1} C_k \ \ (n > 0)\end{aligned}\right.</script><p>下面我们来尝试推导该递归式的封闭解</p><a id="more"></a><p>首先将原式化简为整式，得到 <script type="math/tex">nC_n = n^2 + n + 2 \sum_\limits{k=0}^{n-1} C_k</script></p><p>注意到等式右边有一个连续的求和式（即从 <script type="math/tex">C_0</script> 到 <script type="math/tex">C_{n-1}</script> 中没有缺项），故考虑做<strong>差项</strong>消去该求和式。</p><script type="math/tex; mode=display">\left\{\begin{aligned}&nC_n = n^2 + n + 2 \sum_\limits{k=0}^{n-1} C_k \\&(n-1)C_{n-1} = (n-1)^2 + (n-1) + 2 \sum_\limits{k=0}^{n-2} C_k\end{aligned}\right.</script><p>两式相减，得到 <script type="math/tex">nC_n - (n-1)C_{n-1} = 2n + 2C_{n-1}</script></p><p>化简得到 <script type="math/tex">nC_n = (n+1)C_{n-1} + 2n</script></p><p>接下来我们考虑将 <script type="math/tex">C_n</script> 和 <script type="math/tex">C_{n-1}</script> 前的系数消去以找出通项公式。</p><p>两边同时乘以 $\frac{2}{n(n+1)}$ ，得到 <script type="math/tex">\frac{2}{n+1}C_n = \frac{2}{n}C_{n-1} + \frac{4}{n+1}</script></p><p>令 $T_n = \frac{2}{n+1} C_n$，于是原递归式化简为</p><script type="math/tex; mode=display">\left\{\begin{aligned}& T_0 = 0 \\& T_n = T_{n-1} + \frac{4}{n+1}\end{aligned}\right.</script><p>我们可以快速写出该递归式的通项公式 <script type="math/tex">T_n = 4\sum_\limits{k=2}^{n+1} \frac{1}{k}</script></p><p>即 <script type="math/tex">\frac{2}{n+1}C_n =  4\sum_\limits{k=2}^{n+1} \frac{1}{k}</script></p><p>化简即得 <script type="math/tex">C_n = 2(n+1)\sum_\limits{k=2}^{n+1} \frac{1}{k}</script></p><p>引入调和级数符号 $H_n = 1 + \frac{1}{2} + \frac{1}{3} + … + \frac{1}{n}$</p><p>注意到 $\sum_\limits{k=2}^{n+1} \frac{1}{k} = H_n - 1 + \frac{1}{n+1}$</p><p>故我们得到了原递归表达式的封闭解 $C_n = 2(n+1)H_n - 2n$</p><p>又由 $H_n = \ln n + \gamma + \mathcal{O}\left(\frac{1}{n} \right)$</p><p>故可得</p><script type="math/tex; mode=display">\begin{aligned}C_n &= 2(n+1)\left(\ln n + \gamma + \mathcal{O} \left(\frac{1}{n} \right)\right) - 2n \\&= 2n \ln n + 2(\gamma - 1)n + 2\ln n + 2\gamma + \mathcal{O}(1) + \mathcal{O}\left(\frac{1}{n}\right) \\&= \Theta \left( n \ln n \right) \\&= \Theta \left( n \lg n\right)\end{aligned}</script><p>由此我们得到了快速排序的平均时间复杂度为 $\Theta (n \lg n)$</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;快速排序的平均比较次数满足以下递归表达式：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left\{
\begin{aligned}
&amp;C_0 = 0 \\
&amp;C_n = n + 1 + \frac{2}{n}\sum_\limits{k = 0}^{n-1} C_k \ \ (n &gt; 0)
\end{aligned}
\right.&lt;/script&gt;&lt;p&gt;下面我们来尝试推导该递归式的封闭解&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.github.io/blog/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.github.io/blog/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》笔记整理（一）</title>
    <link href="http://gonggongjohn.github.io/blog/2020/10/07/csapp-01/"/>
    <id>http://gonggongjohn.github.io/blog/2020/10/07/csapp-01/</id>
    <published>2020-10-07T14:31:17.000Z</published>
    <updated>2020-10-11T12:39:08.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-2：信息的表示和处理"><a href="#Chapter-2：信息的表示和处理" class="headerlink" title="Chapter 2：信息的表示和处理"></a>Chapter 2：信息的表示和处理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h4><p><strong>定义：</strong>设一个 $m$ 进制下$w$ 位的位向量表示为 <script type="math/tex">[a_{w-1}, a_{w-2}, ..., a_0]</script>，则其表示的数为 $\sum_\limits{i=0}^{w-1} a_im^i$</p><h4 id="m-进制-rightarrow-十进制"><a href="#m-进制-rightarrow-十进制" class="headerlink" title="$m$ 进制 $\rightarrow$ 十进制"></a>$m$ 进制 $\rightarrow$ 十进制</h4><blockquote><p>设一个 $w$ 位 $m$ 进制整数的位相量表示为 <script type="math/tex">\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ]</script> ，定义函数 $M2D(\vec{x}) = \sum_\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\vec{x})$</p></blockquote><a id="more"></a><p><strong>证明：</strong>由进位计数制的定义可直接得到结论</p><blockquote><p>Example:</p><p>将 $3$ 进制数 $12011$ 转为十进制数</p><p>解： 令 $\vec{x} = [1,2,0,1,1], m = 3$</p><script type="math/tex; mode=display">\begin{align}\therefore n = M2D(\vec{x}) &= 1 \cdot 3^4 + 2 \cdot 3^3 + 1 \cdot 3^1 +1 \cdot 3^0 \\ &= 81+54+3+1 \\ &= 139 \end{align}</script><p>故 <script type="math/tex">12011_3 = 139_{10}</script></p></blockquote><h4 id="十进制-rightarrow-m-进制"><a href="#十进制-rightarrow-m-进制" class="headerlink" title="十进制 $\rightarrow$ $m$ 进制"></a>十进制 $\rightarrow$ $m$ 进制</h4><blockquote><p>设一个十进制整数为 $n$，定义序列 </p><script type="math/tex; mode=display">\begin{align}&p_0 = \lfloor \frac{n}{m} \rfloor, \ r_0 = n \ \ mod \ \ m \\&p_1 = \lfloor \frac{p_0}{m}\rfloor, \ r_1 = p_0 \ \ mod \ \ m \\&... \\&p_{s-1} = \lfloor \frac{p_{s-2}}{m}\rfloor = 0, \ r_{s-1} = p_{s-2} \ \ mod \ \ m \\\end{align}</script><p>则其对应的 $m$ 进制数的位向量表示为 <script type="math/tex">\vec{x} = [r_{s-1}, r_{s-2}, ..., r_0]</script></p></blockquote><p><strong>证明：</strong>设 $n$ 在 $m$ 进制下的位相量表示为 <script type="math/tex">[r_{s-1}, r_{s-2}, ..., r_0]</script></p><p>则由定义可知，<script type="math/tex">n = r_{s-1} \cdot m^{s-1} + r_{s-2} \cdot m^{s-2} + ...+ r_0</script></p><p>故 <script type="math/tex">n = m \cdot \left( r_{s-1} \cdot m^{s-2} + r_{s-2} \cdot m^{s-3} + ... + r_1 \right) + r_0</script></p><p>故 $r_0 = n \ \ mod \ \ m$</p><p>又由</p><script type="math/tex; mode=display">\begin{align}p_0 = \lfloor \frac{n}{m} \rfloor &= r_{s-1} \cdot m^{s-2} + r_{s-2} \cdot m^{s-3} + ... + r_1 \\&= m \cdot \left( r_{s-1} \cdot m^{s-3} + r_{s-2} \cdot m^{s-4} + ... + r_2 \right) + r_1\end{align}</script><p>故 $r_1 = p_0 \ \ mod \ \ m$</p><p>以此类推，<script type="math/tex">r_{i} = p_{i-1} \ \ mod \ \ m \ (i=s-2, ..., 1)</script></p><p>故结论成立</p><blockquote><p>Example:</p><p>将十进制数 $508$ 转为八进制数</p><p>解：</p><script type="math/tex; mode=display">\begin{align}508 &= 63 * 8 + 4 \\63 &= 7 * 8 + 7 \\7 &= 0 * 8 + 7\end{align}</script><p>故 $508_{10} = 774_8$</p></blockquote><h3 id="信息的存储"><a href="#信息的存储" class="headerlink" title="信息的存储"></a>信息的存储</h3><h4 id="字长（Word-Size）"><a href="#字长（Word-Size）" class="headerlink" title="字长（Word Size）"></a>字长（Word Size）</h4><p>在计算机中，<strong>字（Word）</strong>是用来表示一次性处理数据的固定长度。字的位数称为<strong>字长（Word Size）</strong>。字长是计算机系统中的一个重要指标，字长的大小决定了<strong>虚拟地址空间的最大大小</strong>。</p><p>对于一个字长为 $w$ 的机器来说，其虚拟地址的范围为 $0$ ～ $2^w-1$，即可以存储 $2^w$ 个字节</p><blockquote><p>Example:</p><p>字长为32的机器的虚拟地址范围为 $0$ ～ $2^{32}-1$，可以存储 $2^{32}$ 个字节</p></blockquote><h4 id="小端序（Little-Endian）和大端序（Big-Endian）"><a href="#小端序（Little-Endian）和大端序（Big-Endian）" class="headerlink" title="小端序（Little Endian）和大端序（Big Endian）"></a>小端序（Little Endian）和大端序（Big Endian）</h4><p>超过一个字节的数据在计算机中有两种排列顺序：小端序（Little Endian）和大端序（Big Endian）。</p><p>小端序：将较低的有效字节放在<strong>较小</strong>的内存地址中。</p><p>大端序：将较低的有效字节放在<strong>较大</strong>的内存地址中。</p><blockquote><p>Example:</p><p>原始数据：12 34 56 78 </p><p>小端序存储：12 34 56 78</p><p>大端序存储：78 56 34 12</p></blockquote><p><strong>注：</strong>使用ASCII码存储的字符数据在任何系统上都能得到相同的结果，不受端序的影响。</p><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><h4 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h4><p>计算机中有以下四种基本位级运算：<strong>按位与（&amp;）</strong>，<strong>按位或（|）</strong>，<strong>按位非（~）</strong>，<strong>按位异或（^）</strong>，其规则与布尔代数中的规则一致。</p><blockquote><p>Example:</p><p>101100 &amp; 100110 = 100100</p><p>101100 | 100110 = 101110</p><p>~101100 = 010011</p><p>101100 ^ 100110 = 001010</p></blockquote><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>计算机中提供了以下三种逻辑运算：<strong>且（&amp;&amp;）</strong>，<strong>或（||）</strong>，<strong>非（!）</strong>，其规则与命题逻辑中的规则一致。</p><p><strong>注：</strong>C语言中的逻辑运算有<strong>提早终止（Early Termination）</strong>的机制，即当两个表达式做逻辑运算时，若前一个表达式已经能确定最终结果，则不再计算后一个表达式。</p><blockquote><p>Example:</p><p>(1+1=2) &amp; (3=3) = 1</p><p>(1-1=0) || (1=2) = 1</p><p>!(2*5=10) = 0</p><p>!0x3F = 0</p></blockquote><h4 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h4><p>计算机中提供了三种位移操作：左移（&lt;&lt;），逻辑右移（&gt;&gt;），算术右移（&gt;&gt;）</p><p>$x$ 左移 $k$ 位：将 $x$ 的最高 $k$ 位丢弃并在最低位后补充 $k$ 个零，相当于 $x \cdot 2^k$</p><p>$x$ 逻辑右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个零，相当于 $\lfloor \frac{x}{2^k} \rfloor$</p><p>算术右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个最高位值</p><h3 id="整数的存储与运算"><a href="#整数的存储与运算" class="headerlink" title="整数的存储与运算"></a>整数的存储与运算</h3><h4 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h4><p>二进制数码不表示符号信息的整数称为无符号整数，其代码的数字与常规的进位计数制规则一致。即若定义 <script type="math/tex">B2U_w(\vec{x}) = \sum_\limits{i=0}^{w-1}x_i 2^i</script>，则一个 $w$ 位的二进制位相量 $\vec{x}$ 所对应的十进制数 $n = B2U_w(\vec{x})$</p><p>由定义可知，一个 $w$ 位的二进制位相量 $\vec{x}$ 可表示的整数范围为 $0$ ～ $2^w-1$</p><h4 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h4><p>有符号整数是采用补码进行存储的整数。补码是对二进制的一种新的解读方式，其严格的定义如下：若定义 <script type="math/tex">B2T_w(\vec{x}) = -x_{w-1} 2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i</script>，则一个 $w$ 位的二进制位相量 $\vec{x}$ 所对应的十进制数 $n = B2T_w(\vec{x})$。通俗来说，补码将原本 $0$ ～ $2^w-1$ 中 $2^{w-1}$ ～ $2^{w} - 1$ 的部分重新解读为负数，从而使得其可以表示负数。从取模的角度来看， 对于一个 $0$ ～ $2^{w-1} - 1$ 中的数 $n$ 和一个 $2^{w-1}$ ～ $2^{w} - 1$ 中的数 $m$，$(n + m) \ \ mod \ \ 2^w = n - (2^w - m)$，故这样定义是合适的。且容易看出其与无符号整数间的转换关系为 </p><script type="math/tex; mode=display">U2T(x) = \left\{\begin{aligned}&x &, &0 \leq x \leq 2^{w-1} - 1 \\&x - 2^w &, &2^{w-1} \leq x \leq 2^w - 1\end{aligned}\right.</script><script type="math/tex; mode=display">T2U(x) = \left\{\begin{aligned}&x &, & 0 \leq x \leq 2^{w-1}-1 \\&x + 2^w &, & -2^{w-1} \leq x \leq -1\end{aligned}\right.</script><p><strong>证明：</strong>设二进制位向量 $\vec{x}$</p><p>当 <script type="math/tex">0 \leq B2U_w(\vec{x}) \leq 2^{w-1} - 1</script> 时</p><script type="math/tex; mode=display">x_{w-1} = 0</script><p>此时 <script type="math/tex">B2T_w(\vec{x}) = \sum_\limits{i=0}^{w-2}x_i 2^i = B2U_w(\vec{x})</script></p><p>故 <script type="math/tex">U2T_w(x) = x</script></p><p>当 <script type="math/tex">2^{w-1} \leq x \leq 2^w - 1</script> 时</p><script type="math/tex; mode=display">x_{w-1} = 1</script><p>此时 </p><script type="math/tex; mode=display">\left\{\begin{aligned}B2T_w(\vec{x}) &= -2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i \\B2U_w(\vec{x}) &= 2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i\end{aligned}\right.</script><p>故 <script type="math/tex">B2T_w(\vec{x}) = B2U_w(\vec{x}) - 2^w</script></p><p>故 <script type="math/tex">U2T_w(\vec{x}) = x - 2^w</script></p><p><script type="math/tex">T2U(x)</script>的情况同理可证</p><p><strong>注：</strong>无符号或有符号整数仅为二进制解读为十进制时的不同解读方式，由于计算机在二进制层面进行运算，故计算机在进行底层运算时并不区分这两种解读方式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Chapter-2：信息的表示和处理&quot;&gt;&lt;a href=&quot;#Chapter-2：信息的表示和处理&quot; class=&quot;headerlink&quot; title=&quot;Chapter 2：信息的表示和处理&quot;&gt;&lt;/a&gt;Chapter 2：信息的表示和处理&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;进制转换&quot;&gt;&lt;a href=&quot;#进制转换&quot; class=&quot;headerlink&quot; title=&quot;进制转换&quot;&gt;&lt;/a&gt;进制转换&lt;/h3&gt;&lt;h4 id=&quot;进位计数制&quot;&gt;&lt;a href=&quot;#进位计数制&quot; class=&quot;headerlink&quot; title=&quot;进位计数制&quot;&gt;&lt;/a&gt;进位计数制&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;设一个 $m$ 进制下$w$ 位的位向量表示为 &lt;script type=&quot;math/tex&quot;&gt;[a_{w-1}, a_{w-2}, ..., a_0]&lt;/script&gt;，则其表示的数为 $\sum_\limits{i=0}^{w-1} a_im^i$&lt;/p&gt;
&lt;h4 id=&quot;m-进制-rightarrow-十进制&quot;&gt;&lt;a href=&quot;#m-进制-rightarrow-十进制&quot; class=&quot;headerlink&quot; title=&quot;$m$ 进制 $\rightarrow$ 十进制&quot;&gt;&lt;/a&gt;$m$ 进制 $\rightarrow$ 十进制&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;设一个 $w$ 位 $m$ 进制整数的位相量表示为 &lt;script type=&quot;math/tex&quot;&gt;\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ]&lt;/script&gt; ，定义函数 $M2D(\vec{x}) = \sum_\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\vec{x})$&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.github.io/blog/tags/Computer-Science/"/>
    
    <category term="CSAPP" scheme="http://gonggongjohn.github.io/blog/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>GDB使用指南</title>
    <link href="http://gonggongjohn.github.io/blog/2020/09/19/gdb-guide/"/>
    <id>http://gonggongjohn.github.io/blog/2020/09/19/gdb-guide/</id>
    <published>2020-09-19T04:24:40.000Z</published>
    <updated>2020-09-28T08:06:30.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB使用指南"><a href="#GDB使用指南" class="headerlink" title="GDB使用指南"></a>GDB使用指南</h1><p>GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。</p><p>GDB官网：<a href="http://www.gnu.org/software/gdb/">GDB: The GNU Project Debugger</a></p><a id="more"></a><h2 id="GDB和LLDB"><a href="#GDB和LLDB" class="headerlink" title="GDB和LLDB"></a>GDB和LLDB</h2><p>LLDB是一款开源的具有REPL（Read-Evaluation-Print-Loop）特征的调试工具，相比GDB在部分场景下更加先进和高效。Xcode自4.3版本后默认内置了LLDB，因此<strong>macOS用户可以直接使用LLDB对程序进行调试</strong>。（当然macOS同样也可以安装GDB调试工具）</p><p>GDB与LLDB命令对照表：<a href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map</a></p><h2 id="WINDOWS下安装GCC和GDB"><a href="#WINDOWS下安装GCC和GDB" class="headerlink" title="WINDOWS下安装GCC和GDB"></a>WINDOWS下安装GCC和GDB</h2><p>MinGW（Minimalist GNU For Windows）是Windows下的一个小型GNU工具集。新版MinGW中集成了GCC和GDB的相关工具，因此只需安装MinGW即可使用GCC和GDB。</p><h3 id="下载MinGW及GCC包"><a href="#下载MinGW及GCC包" class="headerlink" title="下载MinGW及GCC包"></a>下载MinGW及GCC包</h3><p>首先前往MinGW官方网站：<a href="http://www.mingw.org">MinGW</a> 并在Download界面下载MinGW管理工具。</p><p><img src="mingw-1.png" alt="mingw-2"></p><p><img src="mingw-2.png" alt="mingw-2"></p><p>安装MinGW管理工具并打开。</p><p><img src="mingw-3.JPG" alt="mingw-3"></p><p>选择所需的工具集，点击左上角的<strong>Installation-&gt;Apply Changes</strong>即可安装。（由于受国内网络环境影响，可能会出现下载失败的情况，可以多尝试几次或使用其他网络连接方式下载）。若使用C/C++进行开发，通常仅需安装<strong>mingw32-base-bin</strong>及<strong>mingw32-gcc-g++-bin</strong>即可。</p><h3 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h3><p>安装完成后，我们需要配置系统环境变量使得其可以在CMD中执行。</p><p><strong>右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</strong>，在系统变量框中找到<strong>Path</strong>变量，选择编辑，在最后新增一行填入<strong>你的MinGW安装路径\bin</strong>，确定退出。</p><p><img src="mingw-4.JPG" alt="mingw-4"></p><p>打开CMD，输入<strong>gcc -v</strong>及<strong>gdb -v</strong>，若显示相关版本信息，表明环境变量配置成功。</p><p><img src="mingw-5.JPG" alt="mingw-5"></p><h2 id="在其他IDE中调用GDB"><a href="#在其他IDE中调用GDB" class="headerlink" title="在其他IDE中调用GDB"></a>在其他IDE中调用GDB</h2><h3 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h3><p>CLion本身已经集成了十分完善的可视化调试工具，但如果想在CLion中使用GDB或LLDB调试程序同样十分方便。</p><p>使用通常的方法在需要的地方打上断点启动调试，在下方的Debug窗口中就可以看到GDB/LLDB窗口，在其中输入命令即可。</p><p><img src="clion-1.png" alt="clion-1"></p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>VSCode本身并不自带GCC和GDB的相关功能，因此<strong>使用VSCode进行调试同样需要额外安装GDB/LLDB调试工具</strong>。不过，VSCode提供了一个可视化的C/C++调试插件，相比命令行调试会直观很多。该插件可直接在插件商店里搜索并安装。</p><p><img src="vscode-1.png" alt="vscode-1"></p><p>和其他大型IDE类似，VSCode将一个目录视为一个项目，因此在创建项目时，你需要指定一个空的文件夹来存放项目文件<strong>（这也是一些人装了辅助插件却被提示要手动配置调试文件的一大重要原因）</strong>。在第一次运行程序时，选择<strong>Run-&gt;Start Debugging</strong>，在弹出的选项框中选择一个要使用的调试环境及编译环境，VSCode就会自动在当前的项目目录下创建相应的配置文件。（当然也可以手动指定配置文件，具体配置方法可参考VSCode官方文档）</p><p><img src="vscode-2.png" alt="vscode-2"></p><p><img src="vscode-3.png" alt="vscode-3"></p><p>随后即可在调试界面中看到相关的调试信息。你也可以在下方的Debug Console中输入相关的GDB/LLDB命令来进行进一步的调试。</p><p><img src="vscode-4.png" alt="vscode-4"></p><h2 id="GDB的基本使用"><a href="#GDB的基本使用" class="headerlink" title="GDB的基本使用"></a>GDB的基本使用</h2><h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><p>若要使用GDB来调试程序，需要在使用GCC编译源文件的时候打开-g选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g [源文件名] -o [目标文件名]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g test.c -o test</span><br></pre></td></tr></table></figure></blockquote><p><strong>若不打开调试选项，则在调试时无法添加断点。</strong></p><p>使用gdb打开生成的可执行文件即可开始调试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [目标文件名]</span><br></pre></td></tr></table></figure><p>GDB还可以关联正在运行的程序进行调试。我们可以通过ps命令查询目标进程的PID，随后进入GDB使用attach命令关联进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep [进程名]</span><br><span class="line">gdb</span><br><span class="line">(gdb) attach [PID]</span><br></pre></td></tr></table></figure><p>Linux用户在这一过程过可能会遇到权限不足的情况。解决方法：切换至root用户，进入<strong>/etc/stsctl.d/10-ptrace.conf</strong>中将<code>kernel.yama.ptrace_scpoe = 1</code>改为<code>kernel.yama.ptrace_scpoe = 0</code>即可。</p><h3 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h3><p>通常在调试过程中，我们需要在程序的某个位置添加断点，并让程序运行到这一位置时自动暂停以分析程序当前的运行状态。在GDB环境下，我们可以通过break命令来快速添加断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [源文件名称]:[行号] #执行到某一行时中断</span><br><span class="line">(gdb) break [函数名] #执行到某个函数时中断</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:5</span><br><span class="line">(gdb) break main</span><br></pre></td></tr></table></figure></blockquote><p>有时我们希望程序在特定条件下中断，这个时候我们可以使用break+if或condition语句来设置条件断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [中断位置] if 触发条件</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:10 if a==5</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [中断位置]</span><br><span class="line">(gdb) condition [断点号] [触发条件]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:10</span><br><span class="line">(gdb) condition 1 a==5</span><br></pre></td></tr></table></figure></blockquote><p>我们可以使用info指令查看已设置断点的断点号及相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure><p>通过clear和delete命令可以删除已创建的断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear [目标文件名]:[行号] #删除某一行处的断点</span><br><span class="line">(gdb) clear [函数名] #删除某个函数处的断点</span><br><span class="line">(gdb) delete #删除所有断点</span><br><span class="line">(gdb) delete [断点号] #删除某一特定断点</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear test:5</span><br><span class="line">(gdb) delete 1</span><br></pre></td></tr></table></figure></blockquote><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>对于不需要向main函数传递参数的程序，可以直接使用run指令开始运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><p>对于需要向main函数传递参数的程序，可以使用set args指令或直接在run后跟参数的方式运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args [参数]</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args para1 para2 para3</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run [参数]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run para1 para2 para3</span><br></pre></td></tr></table></figure></blockquote><p>程序运行后，会一直运行至第一个断点处并暂停。若没有设置断点，则效果等同于直接运行程序。</p><p>当程序中断后，GDB提供了以下几种继续运行的指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next #单步执行（不进入函数内部，等同于Clion中的Step Over）</span><br><span class="line">(gdb) step #单步进入（进入函数内部，等同于Clion的Step Into）</span><br><span class="line">(gdb) continue #继续执行至下一个断点处</span><br><span class="line">(gdb) until [行号] #继续执行直至某一行</span><br><span class="line">(gdb) finish #运行至程序结尾</span><br></pre></td></tr></table></figure><h3 id="查看变量及内存"><a href="#查看变量及内存" class="headerlink" title="查看变量及内存"></a>查看变量及内存</h3><p>在程序中断时，GDB提供了一系列指令来查看当前变量及内存中的各种信息。</p><p>通过print指令可以打印变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print &#x27;[源文件名/函数名]&#x27;::[变量名/表达式]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print &#x27;main&#x27;::a</span><br><span class="line">(gdb) print &#x27;test.c&#x27;::b</span><br><span class="line">(gdb) print &#x27;main&#x27;::*p</span><br></pre></td></tr></table></figure></blockquote><p>通过display命令可以使得每次程序中断时自动打印某个变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display [变量名/表达式]</span><br></pre></td></tr></table></figure><p>此外，我们还可以通过watch指令追踪某一变量，使其值发生改变时中断程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch [变量名]</span><br></pre></td></tr></table></figure><p>通过backtrace指令可以查看函数调用栈的存储情况及相关信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace</span><br></pre></td></tr></table></figure><p>更多其他命令的详细用法，可以通过help指令查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help [命令]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GDB使用指南&quot;&gt;&lt;a href=&quot;#GDB使用指南&quot; class=&quot;headerlink&quot; title=&quot;GDB使用指南&quot;&gt;&lt;/a&gt;GDB使用指南&lt;/h1&gt;&lt;p&gt;GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。&lt;/p&gt;
&lt;p&gt;GDB官网：&lt;a href=&quot;http://www.gnu.org/software/gdb/&quot;&gt;GDB: The GNU Project Debugger&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.github.io/blog/tags/Computer-Science/"/>
    
    <category term="Language" scheme="http://gonggongjohn.github.io/blog/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>实数的严格定义</title>
    <link href="http://gonggongjohn.github.io/blog/2020/08/26/analysis-real-number/"/>
    <id>http://gonggongjohn.github.io/blog/2020/08/26/analysis-real-number/</id>
    <published>2020-08-26T11:03:01.000Z</published>
    <updated>2020-08-27T02:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Analysis" scheme="http://gonggongjohn.github.io/blog/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>代数概念整理：映射</title>
    <link href="http://gonggongjohn.github.io/blog/2020/07/31/algebra-projection/"/>
    <id>http://gonggongjohn.github.io/blog/2020/07/31/algebra-projection/</id>
    <published>2020-07-31T07:00:00.000Z</published>
    <updated>2020-09-23T02:33:28.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li><p>设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个<strong>映射</strong>，记为 $f:X \to Y$ ， $X$ 称为 $f$ 的<strong>定义域</strong>， $Y$ 称为 $f$ 的<strong>陪域</strong></p></li><li><p>设 $f:X \to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的<strong>象</strong>，记为 $f(a)$ ； $a$ 称为 $b$ 的<strong>原象</strong>，记为 $f^{-1}(b)$ ；集合 ${f(x) \big| x \in X}$ 称为 $f$ 的<strong>值域</strong>或 $f$ 的<strong>象</strong>，记为$f(X)$ 或 $Imf$</p></li><li><p>设 $f:X \to Y$ 为一映射，若 $\forall x_1 \neq x_2 \in X, f(x_1) \neq f(x_2)$ ，则称 $f$ 为一个<strong>单射</strong></p></li><li><p>设 $f:X \to Y$ 为一映射，若 $\forall y \in Y, \exists x \in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个<strong>满射</strong></p><a id="more"></a></li><li><p>设 $f:X \to Y$ 为一映射，若 $f$ 即是<strong>单射</strong>又是<strong>满射</strong>，则称 $f$ 为一个<strong>双射</strong></p></li><li><p>设 $f: X \to Y$ 为一映射，若 $Y=X$ ，且 $\forall x \in X, f(x) = x$ ，则称 $f$ 为一个<strong>恒等映射</strong>，记为 $Id_X$ 或 $e_X$</p></li><li><p>设 $f: A \to C, g: B \to D$ 为两个映射，若 $A = B,C=D$ ，且 $\forall x \in A, f(x)=g(x)$ ，则称映射 $f$ 与 $g$ <strong>相等</strong></p></li><li><p>设 $f: X \to Y, g: Y \to Z$ 为两个映射，则由法则 $(g \circ f)(x) = g(f(x))$ 定义的映射称为 $f$ 与 $g$ 的<strong>合成</strong>，记为 $g \circ f: X \to Z$ 或 $gf: X \to Z$</p></li><li><p>设 $f:X \to Y,g: Y \to X$ 为两个映射，若 $g \circ f = e_X$ ，则称 $g$ 为 $f$ 的<strong>左逆</strong>， $f$ 为 $g$ 的<strong>右逆</strong>；若  $g \circ f = e_X,f \circ g = e_Y$ ,则称 $g$ 为 $f$ 的<strong>双边逆</strong>或<strong>逆</strong></p></li></ol><h1 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h1><p><strong>1、（映射的合成律）</strong> 设 $f: X \to Y, g: Y \to Z, h: Z \to W$ 为三个映射，则 $h(gf)=(hg)f$</p><p><strong>证明：</strong> 对于 $ h(gf) $ ，$(X \to Y \to Z) \to W=X \to W$ ；对于 $(hg)f$ ，$X \to (Y \to Z \to W)=X \to W$</p><p>$\therefore$ $h(gf)$ 与 $(hg)f$ 的定义域及陪域相同</p><p>$\forall x \in X$ ，由<strong>定义8</strong>可知</p><p>$(h(gf))(x)=h((gf)(x))=h(g(f(x)))=(hg)(f(x))=((hg)f)(x)$</p><p>$\therefore$ 由<strong>定义7</strong>可知，$h(gf)=(hg)f$</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个&lt;strong&gt;映射&lt;/strong&gt;，记为 $f:X \to Y$ ， $X$ 称为 $f$ 的&lt;strong&gt;定义域&lt;/strong&gt;， $Y$ 称为 $f$ 的&lt;strong&gt;陪域&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的&lt;strong&gt;象&lt;/strong&gt;，记为 $f(a)$ ； $a$ 称为 $b$ 的&lt;strong&gt;原象&lt;/strong&gt;，记为 $f^{-1}(b)$ ；集合 ${f(x) \big| x \in X}$ 称为 $f$ 的&lt;strong&gt;值域&lt;/strong&gt;或 $f$ 的&lt;strong&gt;象&lt;/strong&gt;，记为$f(X)$ 或 $Imf$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，若 $\forall x_1 \neq x_2 \in X, f(x_1) \neq f(x_2)$ ，则称 $f$ 为一个&lt;strong&gt;单射&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，若 $\forall y \in Y, \exists x \in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个&lt;strong&gt;满射&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Algebra" scheme="http://gonggongjohn.github.io/blog/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title>代数概念整理：集合</title>
    <link href="http://gonggongjohn.github.io/blog/2020/07/30/algebra-set/"/>
    <id>http://gonggongjohn.github.io/blog/2020/07/30/algebra-set/</id>
    <published>2020-07-30T07:31:34.000Z</published>
    <updated>2020-09-23T02:33:11.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li><p>若 $a$ 为 $S$ 中的一个元素，则称 $a$ <strong>包含于</strong> $S$ ，记为 $a \in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ <strong>不包含于</strong> $S$ ，记为 $a \notin S$</p></li><li><p>设 $S,T$ 为两个集合，若 $\forall a \in S$ ，成立 $a \in T$ ，则称 $S$ 是 $T$ 的一个<strong>子集</strong>，记为 $S \subset T$</p></li><li><p>设 $S,T$ 为两个集合，若 $S \subset T, T \subset S$ ，则称 $S$ 与 $T$ <strong>相等</strong>，记为 $S=T$</p></li><li><p>设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \in T }$ 称为 $S$ 与 $T$ 的<strong>交集</strong>，记为 $S \cap T$ ；将集合 ${ x \big| x \in S \lor x \in T }$ 称为 $S$ 与 $T$ 的<strong>并集</strong>，记为 $S \cup T$</p><a id="more"></a></li><li><p>设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \notin T }$ 称为 $S$ 与 $T$ 的<strong>差集</strong>，记为 $S \setminus T$</p></li><li><p>设 $S,T$ 为两个集合，若 $T \subset S$ ，则将集合 $S \setminus T$ 称为 $T$ 在 $S$ 中的的<strong>补集</strong>，记为 $\complement_S{T}$</p></li><li><p>设 $S,T$ 为两个集合，则将集合 ${(x,y) \big| x \in S, y \in T}$ 称为 $S$ 与 $T$ 的<strong>笛卡尔积</strong> ，记为 $S \times T$ ；将 $\underbrace{X \times X \times … \times X}_{k个}$ 简记为 $X^k$</p></li><li><p>设 $S$ 为一个集合，则将 $S$ 中元素的个数记为 $S$ 的<strong>基数</strong>，记为 $|S|$</p></li></ol><h1 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h1><p><strong>1、（集合分配律）</strong>设 $R,S,T$ 为三个集合，则</p><p><strong>①</strong> $R \cap (S \cup T)=(R \cap S) \cup (R \cap T)$</p><p><strong>②</strong> $R \cup (S \cap T) = (R \cup S) \cap (R \cup T)$</p><p><strong>证明：①</strong> $\forall x \in R \cap (S \cup T)$ </p><p>$\therefore x \in R$ 且 $x \in S \cup T$</p><p>$\therefore$ （ $x \in R$ 且 $x \in S$ ） 或 （ $x \in R 且 x \in T$ ）</p><p>$ \therefore x \in (R \cap S) \cup (R \cap T)$</p><p>$\therefore$ 由<strong>定义2</strong>可知， $R \cap (S \cup T)\subset (R \cap S) \cup (R \cap T)$</p><p>反之， $\forall x \in (R \cap S) \cup (R \cap T)$</p><p>$\therefore$ $x \in R \cap S$ 或 $x \in R \cap T$</p><p>$\therefore x \in R$ 且（ $x \in S$ 或 $x \in T$ ）</p><p>$\therefore$ 由<strong>定义2</strong>可知，$(R \cap S) \cup (R \cap T) \subset R \cap (S \cup T)$</p><p>$\therefore$ 由<strong>定义3</strong>可知， $R \cap (S \cup T)=(R \cap S) \cup (R \cap T)$</p><p><strong>② 同理即可证得结论</strong></p><p><strong>2、</strong> 设 $X,Y$ 为两个集合，且 $|X|=n,|Y|=m$ ，则</p><p><strong>①</strong> $|X \times Y|=n \cdot m$</p><p><strong>②</strong> $|X \cup Y|=n +m-|X \cap Y|$</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;若 $a$ 为 $S$ 中的一个元素，则称 $a$ &lt;strong&gt;包含于&lt;/strong&gt; $S$ ，记为 $a \in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ &lt;strong&gt;不包含于&lt;/strong&gt; $S$ ，记为 $a \notin S$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，若 $\forall a \in S$ ，成立 $a \in T$ ，则称 $S$ 是 $T$ 的一个&lt;strong&gt;子集&lt;/strong&gt;，记为 $S \subset T$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，若 $S \subset T, T \subset S$ ，则称 $S$ 与 $T$ &lt;strong&gt;相等&lt;/strong&gt;，记为 $S=T$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \in T }$ 称为 $S$ 与 $T$ 的&lt;strong&gt;交集&lt;/strong&gt;，记为 $S \cap T$ ；将集合 ${ x \big| x \in S \lor x \in T }$ 称为 $S$ 与 $T$ 的&lt;strong&gt;并集&lt;/strong&gt;，记为 $S \cup T$&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Algebra" scheme="http://gonggongjohn.github.io/blog/tags/Algebra/"/>
    
  </entry>
  
</feed>
