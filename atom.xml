<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GONGGONGJOHN&#39;s Blog</title>
  
  
  <link href="http://gonggongjohn.me/atom.xml" rel="self"/>
  
  <link href="http://gonggongjohn.me/"/>
  <updated>2021-02-27T14:38:48.142Z</updated>
  <id>http://gonggongjohn.me/</id>
  
  <author>
    <name>GONGGONGJOHN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实数集不可数的证明</title>
    <link href="http://gonggongjohn.me/2021/02/27/real-number-uncountability/"/>
    <id>http://gonggongjohn.me/2021/02/27/real-number-uncountability/</id>
    <published>2021-02-27T14:37:37.000Z</published>
    <updated>2021-02-27T14:38:48.142Z</updated>
    
    <content type="html"><![CDATA[<p>实数集是不可数集这一结论的证明是近代集合论研究的一大重要标志。随着近代分析学的发展，这一结论可以从许多不同的角度推导而出。这些方法融合了许多重要的分析思想及数学技巧，在此进行一个简单的整理和总结。</p><a id="more"></a><blockquote><p><strong>Theorem:</strong> 实数集 <script type="math/tex">\mathbb{R}</script> 不可数</p></blockquote><h2 id="对角线法"><a href="#对角线法" class="headerlink" title="对角线法"></a>对角线法</h2><p>若 <script type="math/tex">\mathbb{R}</script> 可数，则区间 <script type="math/tex">[0,1] \subset \mathbb{R}</script> 必然可数</p><p>因此必然可以使用十进制表示法将 <script type="math/tex">[0,1]</script> 中的每一个数一一列出：</p><script type="math/tex; mode=display">r_1 = 0.d_{11} d_{12} d_{13} d_{14} ... \\r_2 = 0.d_{21} d_{22} d_{23} d_{24} ... \\r_3 = 0.d_{31} d_{32} d_{33} d_{34} ... \\r_4 = 0.d_{41} d_{42} d_{43} d_{44} ... \\...</script><p>其中 <script type="math/tex">d_{ij} \in \{0, 1, 2, ..., 9\}</script></p><p>现构造一新的实数 <script type="math/tex">r = 0.d_1 d_2 d_3 d_4 ...</script>，使得</p><script type="math/tex; mode=display">d_i = \left\{\begin{aligned}4, \ if \ d_{ii} \neq 4 \\5, \ if \ d_{ii} = 4\end{aligned}\right.</script><p>显然 <script type="math/tex">r \in [0, 1]</script></p><p>而由于对任意 <script type="math/tex">i \in \mathbb{N}^+</script>，<script type="math/tex">r</script> 与 <script type="math/tex">r_i</script> 的第 <script type="math/tex">i</script> 位数字均不相同，因此 <script type="math/tex">r \neq r_i</script></p><p>由此我们构造出了一个未被列出的实数，这与 <script type="math/tex">[0,1]</script> 中的每一个数均可被列出矛盾</p><p>故 <script type="math/tex">[0,1]</script> 为不可数集，进而可知 <script type="math/tex">\mathbb{R}</script> 为不可数集。</p><h2 id="区间套法"><a href="#区间套法" class="headerlink" title="区间套法"></a>区间套法</h2><blockquote><p><strong>Lemma:</strong> 若 <script type="math/tex">\{[a_n, b_n]\}</script> 形成一闭区间套，则存在唯一的实数 <script type="math/tex">\xi</script> 属于所有的闭区间 <script type="math/tex">[a_n, b_n]</script>，且 <script type="math/tex">\xi = \lim_\limits{n \to \infty} a_n = \lim_\limits{n \to \infty} b_n</script></p></blockquote><p>若 <script type="math/tex">\mathbb{R}</script> 可数，则区间 <script type="math/tex">[0,1] \subset \mathbb{R}</script> 必然可数</p><p>因此我们可将 <script type="math/tex">[0,1]</script> 写为一数列 <script type="math/tex">r_1, r_2, ...,r_n,...</script></p><p>现将 <script type="math/tex">[0,1]</script> 三等分，则必存在某个区间 <script type="math/tex">[a_1, b_1] \subset [0,1]</script>，使得 <script type="math/tex">r_1 \notin [a_1, b_1]</script></p><p>接着继续将 <script type="math/tex">[a_1, b_1]</script> 三等分，则必存在某一子区间 <script type="math/tex">[a_2, b_2] \subset [a_1, b_1]</script>，使得 <script type="math/tex">r_2 \notin [a_2, b_2]</script></p><p>如此进行下去，可得一闭区间套 <script type="math/tex">\{[a_n, b_n]\}</script>，且满足对任意 <script type="math/tex">i \in \mathbb{N^+}</script>，有 <script type="math/tex">r_i \notin [a_i, b_i]</script></p><p>故由<strong>闭区间套定理</strong>可知，存在 <script type="math/tex">\xi \in \mathbb{R}</script>，使得对任意 <script type="math/tex">n \in \mathbb{N^+}</script>，有 <script type="math/tex">\xi \in [a_n, b_n]</script></p><p>于是存在 <script type="math/tex">\xi \in [0,1]</script>，使得对任意 <script type="math/tex">i \in \mathbb{R}^+</script>，有 <script type="math/tex">\xi \neq r_i</script>，与 <script type="math/tex">[0,1]</script> 中每一个数均可被列出矛盾</p><p>故 <script type="math/tex">[0,1]</script> 为不可数集，进而可知 <script type="math/tex">\mathbb{R}</script> 为不可数集。</p><h2 id="外测度法"><a href="#外测度法" class="headerlink" title="外测度法"></a>外测度法</h2><p>对于 <script type="math/tex">\mathbb{R}</script> 上的任意闭区间 <script type="math/tex">I=[a,b]</script>，其体积 <script type="math/tex">V(I)=b-a</script></p><p>故由外测度定义</p><script type="math/tex; mode=display">m(S) = \inf \{ \sum_{i=1}^\infty V(I_i) \big| S \subset \bigcup_{i \in \mathbb{N}} I_i \}</script><p>可知 <script type="math/tex">m(I) = b-a</script></p><p>而对任意可数集 <script type="math/tex">S</script>，<script type="math/tex">m(S) = 0</script></p><p>因此 <script type="math/tex">\mathbb{R}</script> 不可数</p><h2 id="Baire纲定理"><a href="#Baire纲定理" class="headerlink" title="Baire纲定理"></a>Baire纲定理</h2><blockquote><p>Lemma: 设 <script type="math/tex">(X, d)</script> 是一个完备的度量空间，则</p><ol><li>若 <script type="math/tex">(F_n)_{n=0}^\infty</script> 是一列无处稠密的闭集，则它的并的内部是空的</li><li>若 <script type="math/tex">(O_n))_{n=0}^\infty</script> 是一列在 <script type="math/tex">X</script> 中稠密的开集，则它的交在也 <script type="math/tex">X</script> 中稠密</li></ol></blockquote><p>Baire纲定理指出，一个完备的度量空间不能写成可数个无处稠密的集合的并</p><p>由于 <script type="math/tex">\mathbb{R}</script> 是完备的，且在其上有自然度量 <script type="math/tex">d(x,y) = |x-y|</script>，因此其为一个完备的度量空间</p><p>若 <script type="math/tex">\mathbb{R}</script> 可数，则其可以表示为可数个单点集的并，而单点集的闭包即为它本身，也即是无处稠密的</p><p>这与Baire纲定理矛盾，因此 <script type="math/tex">\mathbb{R}</script> 必不可数</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实数集是不可数集这一结论的证明是近代集合论研究的一大重要标志。随着近代分析学的发展，这一结论可以从许多不同的角度推导而出。这些方法融合了许多重要的分析思想及数学技巧，在此进行一个简单的整理和总结。&lt;/p&gt;</summary>
    
    
    
    <category term="分析学" scheme="http://gonggongjohn.me/categories/%E5%88%86%E6%9E%90%E5%AD%A6/"/>
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.me/tags/Mathematics/"/>
    
    <category term="Analysis" scheme="http://gonggongjohn.me/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>Data Lab实验记录</title>
    <link href="http://gonggongjohn.me/2021/01/30/csapp-datalab/"/>
    <id>http://gonggongjohn.me/2021/01/30/csapp-datalab/</id>
    <published>2021-01-30T14:15:21.000Z</published>
    <updated>2021-02-01T06:30:16.415Z</updated>
    
    <content type="html"><![CDATA[<p>Data Lab要求我们在有一系列运算限制的情况下实现某些运算操作，从而尽可能的开发位运算的作用。这个Lab中的绝大部分内容的技巧性都比较强，可以阅读<strong>《算法心得：高效算法的奥秘》</strong>一书作为参考。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Lab中的<strong>bits.c</strong>文件内描述了一系列规则和我们需要实现的函数。具体来说，我们需要实现以下几个函数：</p><ul><li><strong>bitAnd</strong>：按位与</li><li><strong>getByte</strong>：从一个二进制整数中提取某个Byte（8位）</li><li><strong>logicalShift</strong>：逻辑右移</li><li><strong>bitCount</strong>：计算一个二进制整数中1的位数</li><li><strong>bang</strong>：逻辑取反</li><li><strong>tmin</strong>：最小的补码能表示的int型整数</li><li><strong>fitsBits</strong>：判断某个整数能否用n位补码表示</li><li><strong>divpwr2</strong>：计算 <script type="math/tex">\frac{x}{2^n}</script> 并向0取整</li><li><strong>negate</strong>：取相反数</li><li><strong>isPositive</strong>：判断某个数是否为正数</li><li><strong>isLessOrEqual</strong>：判断x是否小于等于y</li><li><strong>ilog2</strong>：计算 <script type="math/tex">\lfloor \log_2 x \rfloor</script></li><li><strong>float_neg</strong>：在float型表示下取相反数</li><li><strong>float_i2f</strong>：将int型表示转为float型表示</li><li><strong>float_twice</strong>：在float型表示下计算 <script type="math/tex">2*x</script></li></ul><p>对于上面这些函数，我们一般只能使用以下几种运算操作：</p><p><strong>逻辑取反（!），按位取反（~），按位与（&amp;），按位异或（^），按位或（|），加法（+），左移（&lt;&lt;），算数右移（&gt;&gt;）</strong></p><p>在此基础之上，其中某些函数还有进一步的限制要求：</p><ul><li>bitAnd：只允许使用<strong>按位取反（~）</strong>和<strong>按位或（|）</strong>操作</li><li>bang：不允许使用<strong>逻辑取反（!）</strong>操作</li><li>float_neg/float_i2f/float_twice：允许使用一切<strong>整数操作</strong>、<strong>逻辑与（&amp;&amp;）</strong>、<strong>逻辑或（||）</strong>、<strong>if语句</strong>及<strong>while语句</strong></li></ul><p>Lab中提供了两种工具来帮助我们检查实现是否正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./dlc -e bits.c <span class="comment"># 检查函数实现中操作是否符合要求</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ./driver.pl <span class="comment"># 检查函数实现是否正确</span></span></span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h3><p>由<strong>De Morgan律</strong>可知 <script type="math/tex">\neg (P \land Q) = (\neg P) \lor (\neg Q)</script></p><p>故 <script type="math/tex">P \land Q = \neg ((\neg P) \lor (\neg Q))</script></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~x | ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行代码搞定。</p><h3 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h3><p>采用掩码的思想，要提取某个Byte的数值并屏蔽其他位的值，可以将目标位移动到最小的8位并将其和0xFF做按位与运算。观察输入的参数，要提取 <script type="math/tex">x</script> 中的第 <script type="math/tex">n</script> 个Byte，就要将 <script type="math/tex">x</script> 向右移动 <script type="math/tex">8*n</script> 位。使用位运算操作的话，也即x&gt;&gt;(n&lt;&lt;3)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x&gt;&gt;(n&lt;&lt;<span class="number">3</span>)) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以一行搞定。</p><h3 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h3><p>算数右移和逻辑右移的区别在于，算数右移会在高位填充最高位的值，而逻辑右移则不会，因此一个基本的思路就是使用算数右移后屏蔽掉高位的值，于是问题便转化为如何构造掩码。</p><p>我们的掩码要保证原数最高位之前均为0，最高位之后均为1。而利用算数右移会填充最高位的特性，我们可以将0x1移动到最高位，随后算数右移到目标位置，再取反即可满足要求，问题也迎刃而解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x&gt;&gt;n)&amp;(~((<span class="number">0x01</span>&lt;&lt;<span class="number">31</span>)&gt;&gt;n&lt;&lt;<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h3><p>利用位运算统计一个字中1的个数是一个技巧性十分强的算法。它的主要思想是<strong>分治法（Divide And Conquer）</strong>，将统计整个字中1的个数的问题转化为多个统计更小区间内1的个数的问题。具体来说，一个32位的整数中，我们可以将其划分为两个16位的区间，进而划分为4个8位的区间，再划分为8个4位的区间，最后划分为16个2位的区间，因此我们仅需要统计每两位中1的个数，再将结果逐步合并即可得到整个数中1的个数。</p><p>对于统计每2位中1的个数，我们同样可以采用掩码的思想，先对两位中第一位和0x1做与运算，再将整个数右移一位与0x1做与运算，将两个结果相加即可统计出这两位中1的个数。</p><p>此外，由于题目中规定不能使用超过0xFF的十六进制数，我们需要通过多步位移的方法来构造出我们想要的的掩码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> maskt1 = (<span class="number">0x55</span>) | (<span class="number">0x55</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> maskt2 = (<span class="number">0x33</span>) | (<span class="number">0x33</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> maskt3 = (<span class="number">0x0F</span>) | (<span class="number">0x0F</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> mask1 = (maskt1) | (maskt1&lt;&lt;<span class="number">16</span>);</span><br><span class="line"><span class="keyword">int</span> mask2 = (maskt2) | (maskt2&lt;&lt;<span class="number">16</span>);</span><br><span class="line"><span class="keyword">int</span> mask3 = (maskt3) | (maskt3&lt;&lt;<span class="number">16</span>);</span><br><span class="line"><span class="keyword">int</span> mask4 = (<span class="number">0xFF</span>) | (<span class="number">0xFF</span>&lt;&lt;<span class="number">16</span>);</span><br><span class="line"><span class="keyword">int</span> mask5 = (<span class="number">0xFF</span>) | (<span class="number">0xFF</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">cnt = (x &amp; mask1) + ((x&gt;&gt;<span class="number">1</span>) &amp; mask1);</span><br><span class="line">cnt = (cnt &amp; mask2) + ((cnt&gt;&gt;<span class="number">2</span>) &amp; mask2);</span><br><span class="line">cnt = (cnt &amp; mask3) + ((cnt&gt;&gt;<span class="number">4</span>) &amp; mask3);</span><br><span class="line">cnt = (cnt &amp; mask4) + ((cnt&gt;&gt;<span class="number">8</span>) &amp; mask4);</span><br><span class="line">cnt = (cnt &amp; mask5) + ((cnt&gt;&gt;<span class="number">16</span>) &amp; mask5);</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>在补码表示中，对一个二进制表示下 <script type="math/tex">n</script> 位的整数 <script type="math/tex">x</script> 取相反数相当于做运算 <script type="math/tex">2^n-x</script>，而 <script type="math/tex">(2^n-1)-x</script> 相当于对x按位取反，因此总的位运算表示即为~x+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h3><p>逻辑取反操作即是要让0变为1，除0以外的任何数变为0，因此我们需要找到一个把0和其他数分开的位运算特性。利用补码表示中负数的最高位始终为1的特性，我们可以发现让一个数和它在补码下的相反数做按位或运算时，如果这个数不为0，那么它的最高位始终为1，而由于0的补码还是0，因此最高位为0。于是利用上一题的结论，我们就能得到最终的运算操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((x|(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>在模的剩余系下，最靠近中间的数即为离边界距离最远的数。利用这一特性可知补码表示下最小的负数最高位为1，其余全为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fitsBits"><a href="#fitsBits" class="headerlink" title="fitsBits"></a>fitsBits</h3><p>如果一个数能用n为补码表示，那么取它的后n位做符号扩展到原来的长度后值应与原来一样。利用逻辑右移的特性，我们只需要将x与x&lt;&lt;(32 - n)&gt;&gt;(32 - n)相比较即可。利用位运算取相反数的结论，以及异或运算的性质 <script type="math/tex">x \oplus x = 0</script>，即可得到最终的运算操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shift = <span class="number">32</span> + ~n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> !(x^((x&lt;&lt;shift)&gt;&gt;shift));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="divpwr2"><a href="#divpwr2" class="headerlink" title="divpwr2"></a>divpwr2</h3><p>要计算 <script type="math/tex">\frac{x}{2^n}</script> 并向0取整，因此我们需要分类讨论。当 <script type="math/tex">x \geq 0</script> 时，这一操作相当于x&gt;&gt;n；而当 <script type="math/tex">x<0</script> 时，若直接对原数右移n位，相当于 <script type="math/tex">\lfloor \frac{x}{2^n} \rfloor</script>，并不满足向0取整的要求。而对于整数，有如下定理成立：</p><blockquote><p>对于整数 <script type="math/tex">x</script> 和 <script type="math/tex">y(y>0)</script>，有 <script type="math/tex">\lceil \frac{x}{y} \rceil = \lfloor \frac{x+y-1}{y} \rfloor</script></p></blockquote><p>由此可知对于负数，我们只需将其加上一个偏置 <script type="math/tex">2^n -1</script>，即可将结果变为向上取整。因此当 <script type="math/tex">x<0</script> 时的操作为 <script type="math/tex">(x+(1<<n)-1)>>n</script>。</p><p>现在我们要通过位运算将这两种情况整合到一起。通过观察可以发现，我们只需要让某个运算在 <script type="math/tex">x \geq 0</script> 时的结果为0，在 <script type="math/tex">x < 0</script> 时的结果为(1&lt;&lt;n)-1即可。同样的，我们可以使用掩码的思想来做到这一点。结合补码的性质及算数右移的性质，我们可以发现只需要将x右移31位即可得到掩码。由此最终的运算操作也迎刃而解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tn = ~((~<span class="number">0</span>)&lt;&lt;n);</span><br><span class="line">    <span class="keyword">int</span> tx = (~((x&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x01</span>)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x + (tx &amp; tn)) &gt;&gt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h3><p>根据题意，我们要让大于0的数运算结果等于1，0和小于0的数运算结果等于0。根据补码的性质，对于除0以外的其他数，我们只需判断最高位是否为1即可；而对于0，我们可以将其单独讨论。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tx = (x&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x01</span>;</span><br><span class="line"><span class="keyword">return</span> !(tx | !x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>当两数异号时，如果直接相减可能会导致结果溢出，但此时我们仅需判断其中一个数的正负即可得知结果，因此无需做减法运算；而当两个数同号时，可以保证相减不会溢出，因此我们只需相减判断符号即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> negx = ~x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> addx = negx + y;</span><br><span class="line">  <span class="keyword">int</span> sign = addx&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> left = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> xleft = x &amp; left;</span><br><span class="line">  <span class="keyword">int</span> yleft = y &amp; left;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">xor</span> = xleft ^ yleft;</span><br><span class="line">  <span class="keyword">xor</span> = (<span class="keyword">xor</span> &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((!<span class="keyword">xor</span>)&amp;(!sign))|(<span class="keyword">xor</span>&amp;(xleft&gt;&gt;<span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h3><p>根据二进制的性质，我们只需要找到最高1的位置即可。仿照前面统计1的个数的思想，我们可以使用二分法来解决这一问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t1, t2, t3;</span><br><span class="line">t3 = x;</span><br><span class="line">t2 = (!!(t3&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">t3 = t3&gt;&gt;t2;</span><br><span class="line">t1 = (!!(t3&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">t3 = t3&gt;&gt;t1;</span><br><span class="line">t2 = t2 | t1;</span><br><span class="line">t1 = (!!(t3&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">t3 = t3&gt;&gt;t1;</span><br><span class="line">t2 = t2 | t1;</span><br><span class="line">t1 = (!!(t3&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">t3 = t3&gt;&gt;t1;</span><br><span class="line">t2 = t2 | t1;</span><br><span class="line"><span class="keyword">return</span> (t2 | (t3&gt;&gt;<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h3><p>在IEEE标准下，float型的格式为1位符号位，8位指数位和23位尾数位。因此我们首先要判断输入的数能否表示为一个float型小数。具体的，我们只需要将其符号位去除（左移），随后将其与0xFF000000比较即可。若大于这个数，则表明其不能表示为float型小数；若小于等于这个数，只需要改变其符号位即可得到结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> x = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> c = <span class="number">0xFF000000</span>;</span><br><span class="line"><span class="keyword">unsigned</span> tuf = uf&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>((c &amp; tuf) == c)&#123;</span><br><span class="line"><span class="keyword">if</span>(tuf != c) <span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> uf ^ x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h3><p>根据IEEE标准中float型的规则，我们需要先计算出符号尾及指数位的数值。随后，我们仅需利用位移操作将符号位、指数位、尾数位移动到相应的位置，再根据舍入的规则做一次微调即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> ax, sign, flag, tmp, shift, cur;</span><br><span class="line">ax = x;</span><br><span class="line">sign = x &amp; (<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line"><span class="keyword">if</span>(sign) ax = -x;</span><br><span class="line">shift = ax;</span><br><span class="line"><span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">tmp = shift;</span><br><span class="line">shift = shift&lt;&lt;<span class="number">1</span>;</span><br><span class="line">cur++;</span><br><span class="line"><span class="keyword">if</span>(tmp &amp; <span class="number">0x80000000</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((shift &amp; <span class="number">0x01FF</span>) &gt; <span class="number">0x0100</span>) flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((shift &amp; <span class="number">0x03FF</span>) == <span class="number">0x0300</span>) flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sign + ((<span class="number">159</span> - cur)&lt;&lt;<span class="number">23</span>) + (shift&gt;&gt;<span class="number">9</span>) + flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h3><p>在二进制科学技术法下，对某个数x乘以2就相对于将其阶数加一。因此若原数阶码不为0且不为255，则直接将阶码加一即可。若阶码等于0，表明其为非规范化数，因此直接将尾数位左移一位即可。由于非规范化数与规范化数之间有一个平滑过渡关系，因此即使左移一位后尾数位的最高位移动至了阶码位，该操作仍然是合法的。当原数阶码为255时，表明其为 <script type="math/tex">\infty</script> 或 <script type="math/tex">NaN</script>，不能进行算术运算，直接返回即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>((uf &amp; <span class="number">0x7F800000</span>) == <span class="number">0</span>)</span><br><span class="line">uf = ((uf &amp; <span class="number">0x007FFFFF</span>) &lt;&lt; <span class="number">1</span>) | (uf &amp; <span class="number">0x80000000</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((uf &amp; <span class="number">0x7F800000</span>) != <span class="number">0x7F800000</span>)</span><br><span class="line">uf = uf + <span class="number">0x800000</span>;</span><br><span class="line"><span class="keyword">return</span> uf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Data Lab要求我们在有一系列运算限制的情况下实现某些运算操作，从而尽可能的开发位运算的作用。这个Lab中的绝大部分内容的技巧性都比较强，可以阅读&lt;strong&gt;《算法心得：高效算法的奥秘》&lt;/strong&gt;一书作为参考。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机系统" scheme="http://gonggongjohn.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Computer-System" scheme="http://gonggongjohn.me/tags/Computer-System/"/>
    
  </entry>
  
  <entry>
    <title>Malloc Lab实验记录</title>
    <link href="http://gonggongjohn.me/2021/01/30/csapp-malloclab/"/>
    <id>http://gonggongjohn.me/2021/01/30/csapp-malloclab/</id>
    <published>2021-01-30T14:15:13.000Z</published>
    <updated>2021-01-31T10:13:55.469Z</updated>
    
    <content type="html"><![CDATA[<p>Malloc Lab要求我们利用CSAPP中9.9节所介绍的技术设计一个简单的动态内存分配器，并且尽可能的使得分配效率最高且空间利用率最大。一个基本的思路便是先构建一个内存分配器的框架，并在此基础上不断优化使得效率和空间使用率均相对达到最优。</p><a id="more"></a><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>首先我们来看一下Lab的基本情况。在Lab的<strong>mm.c</strong>文件中提供了一个最简单的动态内存分配器，我们需要实现以下四个函数以实现更加高效紧凑的内存分配：</p><ul><li><strong>mm_init</strong>：初始化堆</li><li><strong>mm_malloc</strong>：在堆中申请一段空间</li><li><strong>mm_free</strong>：在堆中释放一段之前申请的空间</li><li><strong>mm_realloc</strong>：重新调整之前申请的空间大小</li></ul><p>为了方便起见，Lab在<strong>memlib.c</strong>中为我们提供了一些封装好的基础函数可供我们调用：</p><ul><li><strong>mem_sbrk</strong>：改变堆大小（仅能扩张堆）</li><li><strong>mem_heap_lo</strong>：返回指向堆首的指针</li><li><strong>mem_heap_hi</strong>：返回指向堆尾的指针</li><li><strong>mem_heapsize</strong>：返回当前的堆大小</li><li><strong>mem_pagesize</strong>：返回系统页大小</li></ul><p>我们可以使用Lab为我们提供的<strong>mdriver</strong>工具装载预先设计好的<strong>Trace</strong>文件测试我们的内存分配器效率和空间使用率：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./mdriver -V -f shortX-bal.rep <span class="comment"># X代表Trace文件编号</span></span></span><br></pre></td></tr></table></figure><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>首先我们仿照CSAPP中9.9.12的例子定义一组宏以方便后续的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4   <span class="comment">//字大小（Bytes）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8   <span class="comment">//双字大小（Bytes）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12) <span class="comment">//扩展堆的最小大小（Bytes）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y)? (x):(y)) <span class="comment">//求二者最大值</span></span></span><br><span class="line"><span class="comment">//将块大小和使用标识符组合进一个字中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size,alloc) ((size) | (alloc))</span></span><br><span class="line"><span class="comment">//将任意指针转为一个字指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="comment">//在指针位置放入长度为一个字的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p,val) (*(unsigned int *)(p)=(val))</span></span><br><span class="line"><span class="comment">//将任意指针转为通用指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ADDRESS(p) (*(void **)(p))</span></span><br><span class="line"><span class="comment">//从头部获取块大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="comment">//从头部获取使用标识符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"><span class="comment">//计算块头部位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp)-WSIZE)</span></span><br><span class="line"><span class="comment">//计算块尾部位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp)+ GET_SIZE(HDRP(bp))-DSIZE)</span></span><br><span class="line"><span class="comment">//计算有效载荷大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_PAYLOAD(bp) (GET_SIZE(HDRP(bp))-DSIZE) </span></span><br><span class="line"><span class="comment">//计算后一个块的位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp)+GET_SIZE(((char *)(bp)-WSIZE)))</span></span><br><span class="line"><span class="comment">//计算前一个块的位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(((char *)(bp)-DSIZE)))</span></span><br></pre></td></tr></table></figure><h3 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h3><p>堆初始化的一个基本作用就是向内存系统申请一块初始空间并标识为空闲状态。不过我们会发现，这一行为和后续当需要额外向系统申请新的空间时的行为完全相同，因此我们可以将这一逻辑封装为一个单独的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp; <span class="comment">//新空间的起始指针</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">  <span class="comment">//向上对齐为双字的倍数</span></span><br><span class="line">    size=(words %<span class="number">2</span>)? (words+<span class="number">1</span>)*WSIZE: words*WSIZE;</span><br><span class="line">  <span class="comment">//向系统申请空间</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//设置块头部</span></span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">  <span class="comment">//设置块尾部</span></span><br><span class="line">    PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是初始化函数可以被写成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE)==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="申请空间"><a href="#申请空间" class="headerlink" title="申请空间"></a>申请空间</h3><p>现在我们来考虑如何响应用户的空间申请。由于堆需要保持双字对其，我们必须将用户的申请要求向上对齐为双字大小。而由于一个块还需要额外的双字空间用于存放块头部和块尾部，因此一次申请的空间必须为四字以上。随后我们需要找到合适的位置分配给用户的这一申请，由于后续我们需要不断优化分配的算法，因此我们将这一过程单独封装。此外，如果当前堆中找不到合适的位置分配给用户，我们还需要申请额外的空间以满足用户的需求。于是空间申请函数的基本构架就可以写成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize; <span class="comment">//实际分配的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; <span class="comment">//扩展堆大小</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">  <span class="comment">//申请空间大小为0的情况</span></span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//向上对齐</span></span><br><span class="line">    <span class="keyword">if</span>(size&lt;=DSIZE)</span><br><span class="line">        asize=<span class="number">2</span>*DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize=DSIZE*((size+(DSIZE)+(DSIZE<span class="number">-1</span>))/DSIZE);</span><br><span class="line"><span class="comment">//寻找合适的位置并分配空间</span></span><br><span class="line">    <span class="keyword">if</span>((bp=find_fit(asize))!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        place(bp,asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//当空间不够使扩展堆大小</span></span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span>((bp=extend_heap(extendsize/WSIZE))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//分配空间</span></span><br><span class="line">    place(bp,asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放空间"><a href="#释放空间" class="headerlink" title="释放空间"></a>释放空间</h3><p>释放空间本质上就是把块头部的使用标识符从已使用改为空闲状态，因此我们可以快速实现出这一函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> size=GET_SIZE(HDRP(ptr)); <span class="comment">//块大小</span></span><br><span class="line">  <span class="comment">//将头部设置为空闲状态</span></span><br><span class="line">    PUT(HDRP(ptr),PACK(size,<span class="number">0</span>));</span><br><span class="line">  <span class="comment">//将尾部设置为空闲状态</span></span><br><span class="line">    PUT(FTRP(ptr),PACK(size,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过进一步思考我们会发现，当有多个连续的空闲块时，我们需要在释放时将其合并。由于空闲块可能在新释放的块之前或之后，因此我们需要讨论所有情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp))); <span class="comment">//前一个块是否空闲</span></span><br><span class="line">    <span class="keyword">size_t</span> next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp))); <span class="comment">//后一个块是否空闲</span></span><br><span class="line">    <span class="keyword">size_t</span> size=GET_SIZE(HDRP(bp)); <span class="comment">//块大小</span></span><br><span class="line">  <span class="comment">//前后都不空闲</span></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//前一个块空闲</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//后一个块空闲</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//前后都空闲</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size+=(GET_SIZE(HDRP(NEXT_BLKP(bp)))+GET_SIZE(FTRP(PREV_BLKP(bp))));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在合并的过程中，我们还需要考虑遇到堆的前后边界时的情况。我们可以利用CSAPP中介绍的通过在堆首和堆尾引入首位块的方法规避这一问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//申请空间存放首位块</span></span><br><span class="line">    <span class="keyword">if</span>((head_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">//填充</span></span><br><span class="line">    PUT(head_listp,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">//序言块首</span></span><br><span class="line">    PUT(head_listp+(<span class="number">1</span>*WSIZE),PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">  <span class="comment">//序言块尾</span></span><br><span class="line">    PUT(head_listp+(<span class="number">2</span>*WSIZE),PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">  <span class="comment">//结尾块首</span></span><br><span class="line">    PUT(head_listp+(<span class="number">3</span>*WSIZE),PACK(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">  <span class="comment">//堆首指针指向序言块</span></span><br><span class="line">    head_listp += (<span class="number">2</span>*WSIZE);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，在扩展堆大小的时候，我们也需要考虑到合并的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调整空间大小"><a href="#调整空间大小" class="headerlink" title="调整空间大小"></a>调整空间大小</h3><p>当用户需要调整空间的大小时，我们需要考虑所有可能的情况。如果这一行为相当于申请更大的空间，我们可以先使用合并空闲块的思想将前后的空闲块合并进来，当合并后的空间大小还不够时，我们就需要重新在堆中申请一块更大的空间，并将原本空间中的数据复制过去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//如果没有原始位置，相当于申请一块新的空间</span></span><br><span class="line">    <span class="keyword">if</span>(ptr==<span class="literal">NULL</span>) <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">  <span class="comment">//如果新空间大小为0，相当于释放原本的空间</span></span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> asize=<span class="number">0</span>; <span class="comment">//实际分配大小</span></span><br><span class="line">  <span class="comment">//对齐处理</span></span><br><span class="line">    <span class="keyword">if</span>(size&lt;=DSIZE)</span><br><span class="line">        asize=<span class="number">2</span>*DSIZE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize=DSIZE*((size+(DSIZE)+(DSIZE<span class="number">-1</span>))/DSIZE);</span><br><span class="line">    <span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> oldsize=GET_PAYLOAD(ptr); <span class="comment">//获取原本的有效载荷大小</span></span><br><span class="line">      <span class="comment">//原本大小小于新申请空间的大小</span></span><br><span class="line">        <span class="keyword">if</span>(oldsize&lt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">void</span>* newptr=recoalesce(ptr,asize); <span class="comment">//尝试合并前后块</span></span><br><span class="line">          <span class="comment">//合并空间无法满足需求，申请额外的空间</span></span><br><span class="line">            <span class="keyword">if</span>(newptr==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newptr=mm_malloc(asize); <span class="comment">//申请新空间</span></span><br><span class="line">                <span class="built_in">memcpy</span>(newptr,ptr,oldsize); <span class="comment">//复制数据</span></span><br><span class="line">                mm_free(ptr); <span class="comment">//释放原空间</span></span><br><span class="line">                <span class="keyword">return</span> newptr;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//合并后空间能够满足需求</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> newptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//原本大小和新空间大小一致</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(oldsize==size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//原本大小大于新空间大小</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并前后空闲块</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">recoalesce</span><span class="params">(<span class="keyword">void</span> *bp,<span class="keyword">size_t</span> needsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp))); <span class="comment">//前一个块是否空闲</span></span><br><span class="line">    <span class="keyword">size_t</span> next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp))); <span class="comment">//后一个块是否空闲</span></span><br><span class="line">    <span class="keyword">size_t</span> size=GET_SIZE(HDRP(bp)); <span class="comment">//当前块大小</span></span><br><span class="line">  <span class="comment">//前后都不空闲</span></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//后一个块空闲</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp))); <span class="comment">//合并后一个块后的大小</span></span><br><span class="line">        <span class="keyword">if</span>(size&lt;needsize)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            PUT(HDRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">            PUT(FTRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//前一个块空闲</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        <span class="keyword">if</span>(size&lt;needsize)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> thissize=GET_PAYLOAD(bp); <span class="comment">//当前有效载荷大小</span></span><br><span class="line">            <span class="keyword">void</span>* prev_point=PREV_BLKP(bp); <span class="comment">//前一个块的位置</span></span><br><span class="line">            PUT(FTRP(bp),PACK(size,<span class="number">1</span>));</span><br><span class="line">            PUT(HDRP(prev_point),PACK(size,<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">memcpy</span>(prev_point,bp,thissize); <span class="comment">//向前复制数据</span></span><br><span class="line">            <span class="keyword">return</span> prev_point;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//前后都空闲</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size += (GET_SIZE(HDRP(NEXT_BLKP(bp)))+GET_SIZE(FTRP(PREV_BLKP(bp))));</span><br><span class="line">        <span class="keyword">if</span>(size&lt;needsize)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> thissize=GET_PAYLOAD(bp);</span><br><span class="line">            <span class="keyword">void</span>* prev_point=PREV_BLKP(bp);</span><br><span class="line">            PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">1</span>));</span><br><span class="line">            PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">memcpy</span>(prev_point,bp,thissize);</span><br><span class="line">            <span class="keyword">return</span> prev_point;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>前面我们使用隐式链表的方式实现了内存分配器的基本逻辑。但以这种方式实现的内存分配器效率极低且会产生大量的外部碎片，因此我们需要对其逐步优化。</p><h3 id="显式分离存储"><a href="#显式分离存储" class="headerlink" title="显式分离存储"></a>显式分离存储</h3><p>在使用隐式链表存储块信息的情况下，搜索一个空闲块的平均时间复杂度为 <script type="math/tex">\mathcal{O}(n)</script>，当块的数量很大或空闲块分布较为稀疏时，搜索效率就会变得极低。如果我们显式地将空闲块连在一起，搜索效率会得到一定的提高，然而，每当我们需要释放一段空间时，就需要在空闲链表中搜索合适的位置放置新的空闲块，这一操作有可能使得总时间复杂度再次退化到 <script type="math/tex">\mathcal{O}(n)</script>，因此我们还需要使用CSAPP中介绍的分离链表的方式存储不同规模的空闲块。我们可以按照2的幂来划分每个空闲链表的大小范围，这里一共划分成了10类：<script type="math/tex">(0,8],(9,16],(17,32],(33,64],(65,128],(129,256],(257,512],(513,2048],(2049,4096],(4097, +\infty)</script></p><p>我们可以通过一个指针数据来保存每张链表的头位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MAX_SIZE=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>* linkhead[<span class="number">10</span>]=&#123;<span class="literal">NULL</span>&#125;;  </span><br></pre></td></tr></table></figure><p>随后我们实现一个根据块大小计算属于哪一张链表的辅助函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findlink</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size&lt;=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">64</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">128</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">256</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">512</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">2048</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size&lt;=<span class="number">4096</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以实现空闲块的插入和删除逻辑了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向对应的空闲链表中插入空闲块</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">placefree</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=findlink(GET_SIZE(HDRP(bp))); <span class="comment">//空闲链表头下标</span></span><br><span class="line">    <span class="keyword">void</span>* head=linkhead[index]; <span class="comment">//空闲链表入口</span></span><br><span class="line">  <span class="comment">//相应链表未初始化时</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//把当前块作为标首</span></span><br><span class="line">        linkhead[index]=bp;</span><br><span class="line">        GET_ADDRESS(PRED(bp))=<span class="literal">NULL</span>;</span><br><span class="line">        GET_ADDRESS(SUCC(bp))=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> bpsize=GET_SIZE(HDRP(bp)); <span class="comment">//当前块大小</span></span><br><span class="line">        <span class="keyword">void</span>* temp=<span class="literal">NULL</span>;</span><br><span class="line">      <span class="comment">//移动到链表中和当前块大小最接近的元素前</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=head;</span><br><span class="line">            <span class="keyword">if</span>(GET_SIZE(HDRP(head))&gt;=bpsize) <span class="keyword">break</span>;</span><br><span class="line">            head=GET_ADDRESS(SUCC(head));</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//插入当前块</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GET_ADDRESS(SUCC(temp))=bp;</span><br><span class="line">            GET_ADDRESS(PRED(bp))=temp;</span><br><span class="line">            GET_ADDRESS(SUCC(bp))=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head==linkhead[index])</span><br><span class="line">            &#123;</span><br><span class="line">                GET_ADDRESS(PRED(head))=bp;</span><br><span class="line">                GET_ADDRESS(SUCC(bp))=head;</span><br><span class="line">                GET_ADDRESS(PRED(bp))=<span class="literal">NULL</span>;</span><br><span class="line">                linkhead[index]=bp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                GET_ADDRESS(SUCC(GET_ADDRESS(PRED(head))))=bp;</span><br><span class="line">                GET_ADDRESS(PRED(bp))=GET_ADDRESS(PRED(head));</span><br><span class="line">                GET_ADDRESS(SUCC(bp))=head;</span><br><span class="line">                GET_ADDRESS(PRED(head))=bp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从对应的空闲链表中删除块</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deletefree</span><span class="params">(<span class="keyword">void</span>* bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=findlink(GET_SIZE(HDRP(bp)));</span><br><span class="line">  <span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(linkhead[index]==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Freelist is empty!&quot;</span>);</span><br><span class="line">  <span class="comment">//链表中仅有一个元素时</span></span><br><span class="line">    <span class="keyword">if</span>(GET_ADDRESS(PRED(bp))==<span class="literal">NULL</span> &amp;&amp; GET_ADDRESS(SUCC(bp))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        linkhead[index]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//当前元素为表首元素时</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(GET_ADDRESS(PRED(bp))==<span class="literal">NULL</span> &amp;&amp; GET_ADDRESS(SUCC(bp))!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GET_ADDRESS(PRED(GET_ADDRESS(SUCC(bp))))=<span class="literal">NULL</span>;</span><br><span class="line">        linkhead[index]=GET_ADDRESS(SUCC(bp));</span><br><span class="line">        GET_ADDRESS(SUCC(bp))=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//当前元素为表尾元素时</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(GET_ADDRESS(PRED(bp))!=<span class="literal">NULL</span> &amp;&amp; GET_ADDRESS(SUCC(bp))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GET_ADDRESS(SUCC(GET_ADDRESS(PRED(bp))))=<span class="literal">NULL</span>;</span><br><span class="line">        GET_ADDRESS(PRED(bp))=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//当前元素在表的中间位置时</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        GET_ADDRESS(SUCC(GET_ADDRESS(PRED(bp))))=GET_ADDRESS(SUCC(bp));</span><br><span class="line">        GET_ADDRESS(PRED(GET_ADDRESS(SUCC(bp))))=GET_ADDRESS(PRED(bp));</span><br><span class="line">        GET_ADDRESS(PRED(bp))=GET_ADDRESS(SUCC(bp))=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们需要在合并空闲块时引入这一管理机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        placefree(bp); <span class="comment">//向空闲链表插入当前块</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        deletefree(NEXT_BLKP(bp)); <span class="comment">//从空闲链表中删除后一个块</span></span><br><span class="line">        ...</span><br><span class="line">        placefree(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        deletefree(PREV_BLKP(bp)); <span class="comment">//从空闲链表中删除前一个块</span></span><br><span class="line">        ...</span><br><span class="line">        placefree(PREV_BLKP(bp)); <span class="comment">//向空闲链表插入更新过的前一个块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        deletefree(PREV_BLKP(bp)); <span class="comment">//从空闲链表中删除前一个块</span></span><br><span class="line">        deletefree(NEXT_BLKP(bp)); <span class="comment">//从空闲链表中删除后一个块</span></span><br><span class="line">        ...</span><br><span class="line">        placefree(PREV_BLKP(bp)); <span class="comment">//向空闲链表插入更新过的前一个块</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">recoalesce</span><span class="params">(<span class="keyword">void</span> *bp,<span class="keyword">size_t</span> needsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            deletefree(NEXT_BLKP(bp));</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            deletefree(prev_point);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">            deletefree(prev_point);</span><br><span class="line">            deletefree(NEXT_BLKP(bp));</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分离适配"><a href="#分离适配" class="headerlink" title="分离适配"></a>分离适配</h3><p>有了分离存储的结构后，我们就可以使用分离适配的方法来寻找合适的块分配给用户的每一次空间请求了。其具体思路就是当用户申请某个大小的空间时，我们在其对应空间大小范围的链表中搜索，一旦搜索到一块不小于用户申请大小的块，就将其分配给用户。不过需要注意的是，如果分配给用户的块剩下的大小还可以单独形成一个新的空闲块，则需要将其分割成两个块。用代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找合适的块</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//遍历对应的链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index=findlink(size);index&lt;MAX_SIZE;++index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span>* bp=linkhead[index];</span><br><span class="line">        <span class="keyword">while</span>(bp!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//在找到第一个不小于用户申请大小的块时返回</span></span><br><span class="line">            <span class="keyword">if</span>(GET_SIZE(HDRP(bp))&gt;=size) <span class="keyword">return</span> bp;</span><br><span class="line">            bp=GET_ADDRESS(SUCC(bp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果找不到合适的空间则返回空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在块中分配空间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span>* bp,<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//剩余块大小</span></span><br><span class="line">    <span class="keyword">size_t</span> left=GET_SIZE(HDRP(bp))-asize;</span><br><span class="line">    <span class="keyword">int</span> alloc=GET_ALLOC(HDRP(bp));</span><br><span class="line">  <span class="comment">//如果块为空闲状态，则把它从空闲链表中移除</span></span><br><span class="line">    <span class="keyword">if</span>(alloc==<span class="number">0</span>)</span><br><span class="line">        deletefree(bp);</span><br><span class="line">  <span class="comment">//剩余空间可以构成一个新块</span></span><br><span class="line">    <span class="keyword">if</span>(left&gt;=(DSIZE*<span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(HDRP(NEXT_BLKP(bp)),PACK(left,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(left,<span class="number">0</span>));</span><br><span class="line">        coalesce(NEXT_BLKP(bp));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//剩余空间不能构成一个新块</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> allsize=GET_SIZE(HDRP(bp));</span><br><span class="line">        PUT(HDRP(bp),PACK(allsize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(allsize,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以证明，这种方法的空间利用率近似于对整个堆做最佳适配搜索，且其搜索效率明显优于对整个堆做最佳适配搜索。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Malloc Lab要求我们利用CSAPP中9.9节所介绍的技术设计一个简单的动态内存分配器，并且尽可能的使得分配效率最高且空间利用率最大。一个基本的思路便是先构建一个内存分配器的框架，并在此基础上不断优化使得效率和空间使用率均相对达到最优。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机系统" scheme="http://gonggongjohn.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Computer-System" scheme="http://gonggongjohn.me/tags/Computer-System/"/>
    
  </entry>
  
  <entry>
    <title>Shell Lab实验记录</title>
    <link href="http://gonggongjohn.me/2021/01/29/csapp-shlab/"/>
    <id>http://gonggongjohn.me/2021/01/29/csapp-shlab/</id>
    <published>2021-01-29T15:48:59.000Z</published>
    <updated>2021-01-29T17:30:27.575Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说就是用C语言以及各种系统调用实现一个简单的Unix Shell，说的更直白点就是把CSAPP书上第八章提到的关于Shell的内容全部实现一遍，因此最快的办法应该就是先搭一个基本的框架出来，然后跟着trace的要求把功能一个个补齐。</p><a id="more"></a><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>首先我们来看一下Lab的具体要求和操作流程。</p><p>在Lab下的<strong>tsh.c</strong>文件里给出了一个Shell的基本框架，我们的任务就是要完成如下几个函数的具体实现：</p><ul><li><strong>eval</strong>：解析并执行用户输入的命令</li><li><p><strong>builtin_cmd</strong>：识别并解析Shell的内置函数</p></li><li><p><strong>do_bgfg</strong>：内置函数bg和fg的功能实现</p></li><li><strong>waitfg</strong>：等待前台任务完成</li><li><strong>sigchld_handler</strong>：SIGCHLD信号处理</li><li><strong>sigint_handler</strong>：SIGINT信号处理</li><li><strong>sigstp_handler</strong>：SIGSTP信号处理</li></ul><p>其中，内置函数包括如下几个：</p><ul><li><strong>quit</strong>：结束当前的Shell进程</li><li><strong>jobs</strong>：列出所有当前的后台任务</li><li><strong>bg &lt;jobs&gt;</strong>：向被挂起的前台任务发送SIGCONT信号，并将其转到后台运行</li><li><strong>fg &lt;jobs&gt;</strong>：向被挂起的后台任务发送SIGCONT信号，并将其转到前台运行</li></ul><p>任务要求我们必须回收所有的僵尸孩子进程，并对相应的信号给出正确的反馈。</p><p>为了方便起见，tsh.c文件中提供了一些已封装完成的函数可供我们使用：（仅列出了需要使用到的函数）</p><ul><li><strong>parseline</strong>：解析命令行字符串</li><li><strong>addjob</strong>：向任务列表添加任务</li><li><strong>deletejob</strong>：从任务列表移除任务</li><li><strong>listjobs</strong>：输出任务列表中所有任务的信息</li><li><strong>fgpid</strong>：获取当前前台任务的PID</li><li><strong>getjobpid/getjobjid</strong>：使用PID/Job ID获取任务实例</li><li><strong>pid2jid</strong>：PID号转Job ID号</li><li><strong>unix_error</strong>：发送错误信息并退出</li></ul><p>Lab设计了16个Trace任务用于测试给出的Shell，我们可以使用Lab中提供的<strong>sdriver.pl</strong>工具测试我们的Shell代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./sdriver.pl -t traceXX.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span>  <span class="comment"># XX代表要使用的trace编号</span></span></span><br></pre></td></tr></table></figure><p>作为参考，我们可以将每个Trace的输出结果与tshref.out中的相应内容进行比对以验证功能是否正确。</p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="eval及builtin-cmd"><a href="#eval及builtin-cmd" class="headerlink" title="eval及builtin_cmd"></a>eval及builtin_cmd</h3><p>我们先从eval和builtin_cmd函数入手。对于eval函数，其基本的逻辑如下：</p><ul><li>使用parseline函数解析命令行</li><li>边界判断（判断输入命令是否为空或仅有一个&amp;符号）</li><li>判断是否为内置函数，若是，则直接执行并返回</li><li>创建子进程并执行命令</li><li>将任务加入任务列表</li><li>若为前台任务，则等待其执行完成；否则输出信息并返回</li></ul><p>于是我们可以快速写出其对应的代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[MAXARGS]; <span class="comment">//参数列表</span></span><br><span class="line">    <span class="keyword">int</span> bg; <span class="comment">//前后台标识符</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid; <span class="comment">//最近创建子任务的PID号</span></span><br><span class="line">  <span class="comment">//解析命令行</span></span><br><span class="line">    bg = parseline(cmdline, argv);</span><br><span class="line">  <span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//内置函数判断</span></span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))&#123;</span><br><span class="line">      <span class="comment">//创建子进程</span></span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//执行任务</span></span><br><span class="line">            <span class="keyword">if</span>(execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//将任务加入任务列表</span></span><br><span class="line">        <span class="keyword">if</span>(bg)</span><br><span class="line">    addjob(jobs, pid, BG, cmdline);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          addjob(jobs, pid, FG, cmdline);</span><br><span class="line">      <span class="comment">//前后台任务处理</span></span><br><span class="line">        <span class="keyword">if</span>(bg)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>builtin_cmd函数的功能仅为判断命令是否为内置函数并调用对应的函数，因此其实现更为简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//处理quit指令</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//处理jobs指令</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>))&#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//处理bg指令</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>))&#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//处理fg指令</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))&#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-bgfg"><a href="#do-bgfg" class="headerlink" title="do_bgfg"></a>do_bgfg</h3><p>随后我们来处理内置函数bg和fg的实现。当用户输入bg或fg时，需要切换指定任务的运行状态。首先我们来看一下job实例的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> &#123;</span>              </span><br><span class="line">    <span class="keyword">pid_t</span> pid;              <span class="comment">// 任务PID</span></span><br><span class="line">    <span class="keyword">int</span> jid;                <span class="comment">// 任务Job ID</span></span><br><span class="line">    <span class="keyword">int</span> state;              <span class="comment">// 任务状态：UNDEF（未定义）, BG（后台）, FG（前台）, or ST（停止）</span></span><br><span class="line">    <span class="keyword">char</span> cmdline[MAXLINE];  <span class="comment">// 命令行字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此可知我们只需要切换job实例中的state变量即可。这一逻辑可以通过下面这段代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))&#123;</span><br><span class="line">job-&gt;state = FG; <span class="comment">//转为前台任务</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">job-&gt;state = BG; <span class="comment">//转为后台任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们需要根据用户的输入获取到对应的job实例。用户可以通过PID或Job ID来指定要操作的任务，不过根据题目要求，我们需要讨论所有的输入情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> jid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="comment">//无参数的情况</span></span><br><span class="line"><span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入Job ID的情况</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%%%d&quot;</span>, &amp;jid) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">job = getjobjid(jobs, jid);</span><br><span class="line"><span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: No such job\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入PID的情况</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>, &amp;pid) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">job = getjobpid(jobs, pid);</span><br><span class="line"><span class="keyword">if</span>(job == <span class="literal">NULL</span> || job-&gt;state == UNDEF)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%s): No such process\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入其他字符的情况</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们需要向任务发送SIGCONT信号。需要注意的是，我们需要向任务及其子任务同时发送信号，因此我们需要在创建任务时将其自身和后续的子任务打包到一个独立的进程组中，这可以通过<strong>setpgid</strong>函数来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))&#123;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//将自身及子进程放入一个以自身PID为组号的进程组中</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以使用<strong>kill</strong>函数向整个进程组发送信号了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill(-pid, SIGCONT); <span class="comment">//向pid进程组发送SIGCONT信号</span></span><br></pre></td></tr></table></figure><p>随后的行为和eval中类似，只需分情况处理前台或后台任务即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))&#123;</span><br><span class="line">waitfg(pid);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, pid, job-&gt;cmdline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>waitfg的作用基本就是<strong>在前台任务终止前锁住Shell进程的指令执行</strong>。我们可以使用<strong>while+pause</strong>语句来快速实现这一功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pid == fgpid(jobs))&#123;</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h3 id="SIGINT及SIGTSTP"><a href="#SIGINT及SIGTSTP" class="headerlink" title="SIGINT及SIGTSTP"></a>SIGINT及SIGTSTP</h3><p>首先我们来处理SIGINT和SIGTSTP信号。这两种信号的处理方式完全一致，均为向前台任务的整个进程组发送相应的信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid = fgpid(jobs);</span><br><span class="line"><span class="keyword">if</span>(pid != <span class="number">0</span>)&#123;</span><br><span class="line">    kill(-pid, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这一过程中可能会由于出现另外的异常而改变errno的值，因此我们需要在刚进入函数时保存errno的值，再在函数返回前将其恢复：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> old_errno = errno;</span><br><span class="line">...</span><br><span class="line">errno = old_errno; </span><br></pre></td></tr></table></figure><h3 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h3><p>按照实验要求，共有三种可能的情况会触发SIGCHLD信号：</p><ul><li>子任务正常结束</li><li>前台任务被信号终止</li><li>前台任务被信号暂停</li></ul><p>因此我们需要分情况处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old_errno = errno;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> state; <span class="comment">//子进程结束状态码</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line"><span class="comment">//对所有已终止或暂停的子进程进行操作</span></span><br><span class="line"><span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//正常退出的情况</span></span><br><span class="line"><span class="keyword">if</span>(WIFEXITED(state))&#123;</span><br><span class="line">deletejob(jobs, pid);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//被信号终止的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(state))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(state));</span><br><span class="line">deletejob(jobs, pid);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//被信号暂停的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(state))&#123;</span><br><span class="line">job = getjobpid(jobs, pid);</span><br><span class="line">job-&gt;state = ST; <span class="comment">//将子进程设置为暂停状态</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, pid, WSTOPSIG(state));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  errno = old_errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们需要备份errno以防止破坏其他的操作。</p><h2 id="调度排查"><a href="#调度排查" class="headerlink" title="调度排查"></a>调度排查</h2><p>现在我们的程序已经能够通过绝大部分的Trace任务，但由于<strong>进程调度机制</strong>的存在，某些操作的执行顺序可能并不会如我们所愿，这样在某些情况下可能会导致<strong>竞争</strong>或<strong>死锁</strong>的问题，因此我们需要排查这些情况并解决。</p><p>首先在任务的添加和删除时，由于要修改全局变量jobs，我们不希望有其他信号处理函数打断这一过程导致jobs被修改，因此在执行这些函数时我们要屏蔽所有的信号接收：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_all, mask_prev;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))&#123;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(bg)</span><br><span class="line">addjob(jobs, pid, BG, cmdline);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        addjob(jobs, pid, FG, cmdline);</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;mask_prev, <span class="literal">NULL</span>);</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">sigset_t</span> mask_all, mask_prev;</span><br><span class="line">...</span><br><span class="line">sigfillset(&amp;mask_all);</span><br><span class="line"><span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);</span><br><span class="line">...</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;mask_prev, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，在修改任务状态时我们也需要屏蔽所有信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="keyword">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">sigset_t</span> mask_all, mask_prev;</span><br><span class="line">  ...</span><br><span class="line">sigfillset(&amp;mask_all);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);</span><br><span class="line">...</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;mask_prev, <span class="literal">NULL</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们继续检查eval函数，发现如果子进程在addjob函数被执行前便已终止，则sigchld_handler中的deletejob便无法正确删除相应的任务，因此我们需要在addjob被执行前屏蔽SIGCHLD信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">sigset_t</span> mask_one, mask_prev;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))&#123;</span><br><span class="line">        sigemptyset(&amp;mask_one);</span><br><span class="line">sigaddset(&amp;mask_one, SIGCHLD);</span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;mask_prev);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，这一操作可能会使得子进程也无法接收到SIGCHLD信号，因此我们需要在创建子进程后恢复信号的接收：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eval</span><span class="params">(<span class="keyword">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))&#123;</span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;mask_prev, <span class="literal">NULL</span>);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们考察waitfg函数，发现经过上面的修改后Shell进程已无法正确接受SIGCHLD指令。此时尽管我们可以暂时放开SIGCHLD信号的接收，但如果程序刚放开信号进程调度程序便调度至子进程并运行至子进程退出，则pause指令永远无法正确接收到SIGCHLD信号，此时便会出现死锁的情况。因此我们需要使用<strong>sigsuspend</strong>函数来代替以保证其不会被打断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">sigset_t</span> empty_mask;</span><br><span class="line">    sigemptyset(&amp;empty_mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pid == fgpid(jobs))&#123;</span><br><span class="line">        sigsuspend(&amp;empty_mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单来说就是用C语言以及各种系统调用实现一个简单的Unix Shell，说的更直白点就是把CSAPP书上第八章提到的关于Shell的内容全部实现一遍，因此最快的办法应该就是先搭一个基本的框架出来，然后跟着trace的要求把功能一个个补齐。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机系统" scheme="http://gonggongjohn.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Computer-System" scheme="http://gonggongjohn.me/tags/Computer-System/"/>
    
  </entry>
  
  <entry>
    <title>K-Means聚类与层次聚类</title>
    <link href="http://gonggongjohn.me/2020/12/30/clustering/"/>
    <id>http://gonggongjohn.me/2020/12/30/clustering/</id>
    <published>2020-12-30T13:22:44.000Z</published>
    <updated>2021-02-01T07:42:39.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cluster-Analysis"><a href="#Cluster-Analysis" class="headerlink" title="Cluster Analysis"></a>Cluster Analysis</h2><p><strong>Cluster analysis</strong> or <strong>clustering</strong> is a task of grouping a set of objects in such a way that objects in the same group are more similar to each other than to those in other groups. It is <strong>a main task of exploratory data mining</strong>, and <strong>a common technique for statistical data analysis</strong> which is used in many fields including <strong>pattern recognition</strong>, <strong>image analysis</strong>, <strong>information retrieval</strong>, <strong>bioinformatics</strong>, <strong>data compression</strong>, <strong>computer graphics</strong> and <strong>machine learning</strong>. </p><a id="more"></a><p>There are various clustering algorithms that differ significantly in their understanding of what constitutes a cluster and how to effectively find them, which proved to be useful in different scenarios.</p><h2 id="K-means-Clustering"><a href="#K-means-Clustering" class="headerlink" title="K-means Clustering"></a>K-means Clustering</h2><h3 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h3><p>K-means clustering is a partition-based method that can be used to partition a dataset into a fixed number of clusters. We can use the famous <strong>priest-villager model</strong> to illustrate the main idea of K-means algorithm.</p><p>There are four priests preaching in the countryside. At first, they chose four preaching points arbitrarily, and told villagers to take the preaching course that is nearest to their own house. After the first class, some villagers complained that the preaching points were still too far from their home, so each of the priests collected the home addresses of all the villagers that came to his class and move the preaching point to the center of all the addresses. Since the update of preaching points, some villagers found that another preaching points became closer to their house than the previous one, so they chose to take the course at the new preaching point. In this way, the priests updated their preaching points every week, and villagers decided which course to take according to the distance of each preaching points. After several weeks, the preaching points became stable and both the villagers and the priests got satisfied.</p><p>In formal words, K-means algorithm can be described as follows:</p><ol><li>Choose a set of <script type="math/tex">K</script> initial points <script type="math/tex">\{c_1, c_2, ..., c_K\}</script> that denotes the centroid of each cluster</li><li>Iteratively execute the following steps until all the centroid points stop to change (or hit some global restriction):<ul><li>For each sample points in the dataset, compute the distances from it to every centroids and assign it to the centroid with the smallest distance</li><li>Recompute the position of each centroid according to the positions of all the samples assigned to it</li></ul></li></ol><h3 id="Mathematical-Details"><a href="#Mathematical-Details" class="headerlink" title="Mathematical Details"></a>Mathematical Details</h3><p>Intuitively, we want to find a set of centroids and an assignment of every instances in the dataset to these centroids so that every centroid covers the most reasonable amount of instances and anchors at exactly the average point of all the instances that assigned to it. We can use a mathematical trick to convert this intuition into an optimization problem.</p><p>If we define an indicator variable <script type="math/tex">r_{nk}</script> to describe which cluster an instance is in, which is</p><script type="math/tex; mode=display">r_{nk} = \left\{\begin{aligned}&1, &if \ n \ is \ assigned \ to \ k \\&0, &otherwise\end{aligned}\right.</script><p>, then the sum of the distance of all the instances in the dataset to their centroids can be written as</p><script type="math/tex; mode=display">J = \sum_{n=1}^N \sum_{k=1}^K r_{nk} \cdot dist(x_n, c_k)</script><p>where <script type="math/tex">N</script> is the size of the dataset, <script type="math/tex">K</script> is the number of clusters, <script type="math/tex">x_n</script> is the <script type="math/tex">n^{th}</script> instance in the dataset, <script type="math/tex">c_k</script> is the <script type="math/tex">k^{th}</script> centroid, <script type="math/tex">dist(a, b)</script> is the distance between <script type="math/tex">a</script> and <script type="math/tex">b</script>.</p><p>Specifically, if the dataset is in the Euclidean space, then we can use the <strong>square of Euclidean distance</strong> as the distance function (square is for the convenience of derivation operations), which is</p><script type="math/tex; mode=display">dist(x_n, c_k) = ||x_n - c_k||^2 = (x_{n1}-c_{k1})^2 + (x_{n2}-c_{k2})^2 + ... + (x_{nm}-c_{km})^2</script><p>where <script type="math/tex">x_{ni}</script> and <script type="math/tex">c_{ki}</script> is the <script type="math/tex">i^{th}</script> component of <script type="math/tex">x</script> and <script type="math/tex">c</script> respectively.</p><p>If the dataset denotes some broader set (usually text data), we can also use the <strong>Jaccard distance</strong> as the distance function, which is defined as</p><script type="math/tex; mode=display">dist(A, B) = \frac{A \Delta B}{|A \cup B|} = \frac{|A \cup B - A \cap B|}{|A \cup B|}</script><p>where <script type="math/tex">A, B</script> are two sets and <script type="math/tex">|S|</script> is the size of set <script type="math/tex">S</script>.</p><p>Therefore, our goal becomes to minimize the function <script type="math/tex">J</script>. A famous solution to this kind of problems is the <strong>EM(Expectation-Maximization) Algorithm</strong> where optimizing <script type="math/tex">r_{nk}</script> is the expectation step and minimizing <script type="math/tex">dist(x_n, c_k)</script> is the maximization step.</p><p>First we optimize <script type="math/tex">r_{nk}</script>. Since <script type="math/tex">J</script> is the linear function of <script type="math/tex">r_{nk}</script>, we can simply assigned every instance to the centroid <script type="math/tex">k</script> if the distance  between them is the smallest among all centroids to get the minimum <script type="math/tex">J</script> when the centroids are fixed.</p><p>Then we try to minimize the distance function. Here we only consider the situation when we use the Euclidean distance as the distance metrics. More specifically, our goal is to minimize</p><script type="math/tex; mode=display">J = \sum_{n=1}^N \sum_{k=1}^K r_{nk} ||x_n - c_k||^2</script><p>when <script type="math/tex">r_{nk}</script> is fixed (This function are also called the <strong>sum of squared error</strong> function). Since each cluster is independent, we can optimize each cluster respectively to get the global minimum, which is to minimize the following expression</p><script type="math/tex; mode=display">J_k = \sum_{n=1}^N r_{nk} \cdot ||x_n-c_k||^2</script><p>for every <script type="math/tex">k</script> from <script type="math/tex">1</script> to <script type="math/tex">K</script>. </p><p>We can notice that this is a quadratic function of <script type="math/tex">c_k</script>, so we can simply set its derivative function to <script type="math/tex">0</script> and solve for <script type="math/tex">c_k</script> to get the minimum point. From this we can get the final formula to find the position of <script type="math/tex">c_k</script></p><script type="math/tex; mode=display">c_k = \frac{\sum_\limits{n=1}^N r_{nk}x_n}{\sum_\limits{n=1}^N r_{nk}}</script><p>Since both of the two steps aims at reducing <script type="math/tex">J</script> while <script type="math/tex">J</script> is always greater than <script type="math/tex">0</script>, we can prove that the function will finally converges.</p><h3 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h3><p>We can implement K-means algorithm in pseudo-code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">K-MEANS(K, t, s): &#x2F;&#x2F;The paramaters denote the number of clusters, the iteration times and the dataset respectively</span><br><span class="line">Initialize c[K] &#x2F;&#x2F;Denote the centroid set</span><br><span class="line">While t</span><br><span class="line">For i in s</span><br><span class="line">min_dist &#x3D; INF</span><br><span class="line">For j &#x3D; 1 to K</span><br><span class="line">d &#x3D; Distance between i and c[j]</span><br><span class="line">If d &lt; min_dist</span><br><span class="line">min_dist &#x3D; d</span><br><span class="line">min_index &#x3D; j</span><br><span class="line">Append i into the cluster set of c[min_index]</span><br><span class="line">For i &#x3D; 1 to K</span><br><span class="line">c[i].pos &#x3D; Mean position of all the points in the cluster set of c[i]</span><br><span class="line">return c</span><br></pre></td></tr></table></figure><p>If we use the standard Euclidean distance (<script type="math/tex">L_2</script> norm) as the distance metrics, then the time complexity of K-means algorithm is <script type="math/tex">\mathcal{O}(tknm)</script> where <script type="math/tex">t</script> is the iteration times, <script type="math/tex">k</script> is the number of clusters, <script type="math/tex">n</script> is the size of the dataset and <script type="math/tex">m</script> is the dimension of each sample in the dataset.</p><p>Similarly, if the samples of the dataset and the centroids are all in <script type="math/tex">m</script>-dimensional Euclidean space, than the space complexity of K-means algorithm is <script type="math/tex">\mathcal{O}((n+k) \cdot m)</script> where <script type="math/tex">n</script> is the size of the dataset, <script type="math/tex">k</script> is the number of clusters.</p><h3 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h3><p>Due to its simplicity, K-means clustering algorithm has been successfully used in many domains such as market segmentation, computer vision and astronomy. It is also used as a preprocessing step before many other alogirithms to find a starting configuration.</p><p>For example, in computer graphics, there is a task called <strong>color quantization</strong> which is to reduce the color palette of a picture into a fixed number. K-means algorithm can easily been used for this task and often produces a competitive result.</p><p>As an unsupervised learning algorithm, K-means algorithm is also widely used to explore the implicit features of a dataset before applying subsequent learning algorithms in data mining area, which can be very useful in some NLP(Natural Language Processing) and computer vision tasks.</p><h3 id="Pros-And-Cons"><a href="#Pros-And-Cons" class="headerlink" title="Pros And Cons"></a>Pros And Cons</h3><p>The advantage of K-means algorithm is that it <strong>has a relatively low time and space complexity</strong>, and <strong>has a good flexibility even when applying to a large dataset</strong>. However, there are also some drawbacks of it:</p><ol><li>The algorithm may converges to a local minimum, which is counterintuitive in some situation.</li><li>Unable to get a correct partition when the clusters is not spherical or non-convex.</li><li>The algorithm is sensitive to the cluster number K and the initial point of the centroids.</li></ol><h2 id="Hierarchical-Clustering"><a href="#Hierarchical-Clustering" class="headerlink" title="Hierarchical Clustering"></a>Hierarchical Clustering</h2><h3 id="Concept-1"><a href="#Concept-1" class="headerlink" title="Concept"></a>Concept</h3><p>As its name suggests, hierarchical clustering is a hierarchical-based method to group similar objects into clusters. Its main idea is to build a <strong>hierarchical tree</strong> (or <strong>dendrogram</strong>) to represent the nested group relations. In general, there are two different strategies to achieve this goal: <strong>Agglomerative Hierarchical Clustering</strong> and <strong>Divisive Hierarchical Clustering</strong>. Agglomative method is a <strong>bottom-up</strong> method, which is to regard each of the instances as a single cluster at first and then keep merging the most similar clusters until there is only one cluster left. In comparison, divisive method is a <strong>top-down</strong> method, which consider the whole dataset as a big cluster and keep splitting down until each of the clusters have only one instance in it. </p><h3 id="Complexity-Analysis-1"><a href="#Complexity-Analysis-1" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h3><p>Agglomerative hierarchical clustering algorithm can be implemented as follow:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AHC(s): &#x2F;&#x2F;s denotes the dataset</span><br><span class="line">Initialize c &#x2F;&#x2F;Denote the clusters at the current level</span><br><span class="line">Append every instance from s to c</span><br><span class="line">While c.length !&#x3D; 1</span><br><span class="line">min_dist &#x3D; INF</span><br><span class="line">For i in c</span><br><span class="line">For j in c</span><br><span class="line">If i !&#x3D; j</span><br><span class="line">d &#x3D; Distance between i and j</span><br><span class="line">If d &lt; min_dist</span><br><span class="line">min_dist &#x3D; d</span><br><span class="line">min_cp &#x3D; i, j</span><br><span class="line">cm &#x3D; merge(min_cp)</span><br><span class="line">Remove min_cp from c</span><br><span class="line">Append cm to c</span><br></pre></td></tr></table></figure><p>The basic structure of Divisive hierarchical clustering algorithm is the same as the agglomerative one, except the divisive one needs to split the farthest sub-clusters from the larger cluster in every loop.</p><p>If we use the Euclidean distance as the distance metrics, then the <strong>time complexity</strong> of hierarchical clustering is <script type="math/tex">\mathcal{O}(mn^3)</script> where <script type="math/tex">m</script> is the dimension of each sample in the dataset and <script type="math/tex">n</script> is the size of the dataset.</p><p>Since every cluster needs to record its member and its sub-clusters, the <strong>space complexity</strong> of hierarchical clustering is <script type="math/tex">\mathcal{O}(n^2)</script></p><h3 id="Applications-1"><a href="#Applications-1" class="headerlink" title="Applications"></a>Applications</h3><p>Hierarchical clustering is an ideal methods to find the hierarchical relations between instances. These instances often differ from each other in some aspects, but not to the extent that we should put them into two mutual exclusive groups.</p><p>For instance, we can use hierarchical clustering to find the members of each party in America senate. To achieve this, we can define how much one senator agrees with another’s words as a metrics, and implement hierarchical clustering algorithm on all senator’s twitter accounts. </p><h3 id="Pros-And-Cons-1"><a href="#Pros-And-Cons-1" class="headerlink" title="Pros And Cons"></a>Pros And Cons</h3><p>A conspicuous benefit for hierarchical clustering is that it can get the whole cluster information once-and-for-all. Once we get the hierarchical relation tree of a dataset, we can probe the cluster information in different granularity and get the fittest cluster results we want to get. </p><p>However, the defects of it is equally distinct. The huge cost of computing distance between every two clusters and storing hierarchical information makes it unsuitable to handle large dataset. Once a cluster partition or congregation is determined, it is not easy to change since every subsequent judgement is based on clusters existed, which gives the algorithm a poor flexibility. Moreover, the strategy for merging or splitting the clusters is a greedy strategy, which may leads to an local-optimum result.</p><h3 id="K-means-V-S-Hierarchical-Clustering"><a href="#K-means-V-S-Hierarchical-Clustering" class="headerlink" title="K-means V.S. Hierarchical Clustering"></a>K-means V.S. Hierarchical Clustering</h3><p>In view of their different features, K-means and hierarchical clustering are often used in different scenarios. K-means can be easily adapted to a large or dense dataset thanks to its simplity and low computational cost. When it is uneasy to determine how many clusters in the dataset or the instance relations are unambiguous, hierarchical clustering proves to be a better choice. In practice, we often perform K-means clustering first to get a rough understanding of a dataset and reduce the data size. Then we perform hierarchical clustering to explore the deeper interrelationships among the dataset. </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Cluster-Analysis&quot;&gt;&lt;a href=&quot;#Cluster-Analysis&quot; class=&quot;headerlink&quot; title=&quot;Cluster Analysis&quot;&gt;&lt;/a&gt;Cluster Analysis&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Cluster analysis&lt;/strong&gt; or &lt;strong&gt;clustering&lt;/strong&gt; is a task of grouping a set of objects in such a way that objects in the same group are more similar to each other than to those in other groups. It is &lt;strong&gt;a main task of exploratory data mining&lt;/strong&gt;, and &lt;strong&gt;a common technique for statistical data analysis&lt;/strong&gt; which is used in many fields including &lt;strong&gt;pattern recognition&lt;/strong&gt;, &lt;strong&gt;image analysis&lt;/strong&gt;, &lt;strong&gt;information retrieval&lt;/strong&gt;, &lt;strong&gt;bioinformatics&lt;/strong&gt;, &lt;strong&gt;data compression&lt;/strong&gt;, &lt;strong&gt;computer graphics&lt;/strong&gt; and &lt;strong&gt;machine learning&lt;/strong&gt;. &lt;/p&gt;</summary>
    
    
    
    <category term="机器学习" scheme="http://gonggongjohn.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Machine-Learning" scheme="http://gonggongjohn.me/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>从主方法到Akra-Bazzi定理</title>
    <link href="http://gonggongjohn.me/2020/11/25/akra-bazzi/"/>
    <id>http://gonggongjohn.me/2020/11/25/akra-bazzi/</id>
    <published>2020-11-25T03:34:14.000Z</published>
    <updated>2021-04-17T09:14:28.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h2><p>在算法分析中，当我们使用分治法求解问题时，通常会遇到以递归式定义的算法运行时间函数。要得到此类算法的时间复杂度，就必须求出该递归式的渐近表达式。通常情况下，我们可以通过如下公式直接得到大部分不太复杂的递归式的渐近解。<strong>《算法导论》</strong>一书中将该方法称为<strong>“主方法”</strong>。</p><a id="more"></a><blockquote><p><strong>Theorem: </strong>设<script type="math/tex">a\geq 1, b >1</script>，<script type="math/tex">f(n)</script>为一定义在非负整数上的函数， <script type="math/tex">T(n)=aT\left(\frac{n}{b}\right) + f(n)</script>（当 <script type="math/tex">\frac{n}{b}</script> 不为整数时代表 <script type="math/tex">\lfloor{\frac{n}{b}\rfloor}</script> 或 <script type="math/tex">\lceil{\frac{n}{b}\rceil}</script>），则</p><ol><li><p>若存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \mathcal{O}\left(n^{\log_b a - \varepsilon}\right)</script>，则 <script type="math/tex">T(n) = \Theta\left(n^{\log_b a}\right)</script></p></li><li><p>若存在 <script type="math/tex">k \geq 0</script>，使得 <script type="math/tex">f(n) = \Theta\left(n^{\log_b a} \lg^k n\right)</script>，则 <script type="math/tex">T(n) = \Theta\left(n^{\log_b a} \lg^{k+1} n\right)</script></p></li><li><p>若存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \Omega\left(n^{\log_b a + \varepsilon}\right)</script>，且存在 <script type="math/tex">0<c<1</script>及正整数 <script type="math/tex">N</script>，使得当 <script type="math/tex">n>N</script> 时，有 <script type="math/tex">af\left(\frac{n}{b}\right) \leq cf(n)</script>，则 <script type="math/tex">T(n) = \Theta(f(n))</script></p></li></ol></blockquote><p>通过该定理，我们可以快速得到一些算法的时间复杂度。</p><blockquote><p><strong>Example1:</strong> Strassen矩阵算法的运行时间函数 <script type="math/tex">T(n)=7T\left(\frac{n}{2}\right) + \Theta(n^2)</script>，求Strassen矩阵算法的时间复杂度</p><p><strong>解：</strong>由 <script type="math/tex">\log_2 7 > \log_2 4 = 2</script> 可知，存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \Theta(n^2) = \mathcal{O}(n^{\log_2 7 - \varepsilon})</script></p><p>故由主定理可知，<script type="math/tex">T(n) = \Theta(n^{\log_2 7})</script></p><p><strong>Example2:</strong> 归并排序算法的运行时间函数 <script type="math/tex">T(n) = 2T\left(\frac{n}{2}\right) + \Theta(n)</script>，求归并排序算法的时间复杂度</p><p><strong>解：</strong>由 <script type="math/tex">\log_2 2 = 1</script> 可知，存在 <script type="math/tex">k=0</script>，使得 <script type="math/tex">f(n) = \Theta(n) = \Theta(n^{\log_2 2} \lg^k n)</script></p><p>故由主定理可知，<script type="math/tex">T(n) = \Theta(n \lg n)</script></p><p><strong>Example3:</strong> 若一个算法的运行时间函数 <script type="math/tex">T(n)=2T\left(\frac{n}{2}\right) + \Theta(n^2)</script>，求该算法的时间复杂度</p><p><strong>解：</strong>由 <script type="math/tex">\log_2 2 = 1</script> 可知，存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \Theta(n^2) = \Omega(n^{\log_2 2 + \varepsilon})</script></p><p>又由于 <script type="math/tex">af\left(\frac{n}{b}\right) = 2 \left(\frac{n}{2}\right)^2 = \frac{n^2}{2}</script></p><p>因此仅需取 <script type="math/tex">\frac{1}{2} \leq c < 1</script>，则有 <script type="math/tex">af\left(\frac{n}{b}\right) \leq cf(n)</script></p><p>故由主定理可知，<script type="math/tex">T(n) = \Theta(n^2)</script></p></blockquote><h2 id="主定理的证明"><a href="#主定理的证明" class="headerlink" title="主定理的证明"></a>主定理的证明</h2><p>下面我们来尝试证明主定理。</p><p>主定理的证明思路如下：首先我们考虑当 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的某个幂次时的情况，此时可以保证 <script type="math/tex">\frac{n}{b}</script> 是一个整数，因此可以直接做递推并求出其阶数。随后，通过放缩，我们可以将其推广到一切正整数的情况上去。</p><p>首先我们考虑当 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的 <script type="math/tex">k</script> 次幂时的情况。此时原递归式可写为</p><script type="math/tex; mode=display">T(n)=\left\{\begin{aligned}&\Theta(1) &, &n = 1 \\&aT\left(\frac{n}{b}\right)+f(n) &, &n=b^i(i=1,2,...,k)\end{aligned}\right.</script><p>作递推，可得</p><script type="math/tex; mode=display">\begin{aligned}T(n)&=aT\left(\frac{n}{b}\right) + f(n) \\&=a^2T\left(\frac{n}{b^2}\right) + af\left(\frac{n}{b}\right) + f(n) \\&=a^3T\left(\frac{n}{b^3}\right) + a^2f\left(\frac{n}{b^2}\right) + af\left(\frac{n}{b}\right) + f(n) \\&=... \\&=a^{\log_b n} T(1) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right) \\&=n^{\log_b a} \Theta(1) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right) \\&=\Theta \left(n^{\log_b a} \right) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)\end{aligned}</script><p>因此我们只需要考察 <script type="math/tex">\sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)</script> 的渐近表达式即可得到 <script type="math/tex">T(n)</script> 的渐近解。</p><p>现在我们来证明如下的的引理成立</p><blockquote><p><strong>Lemma:</strong> 设 <script type="math/tex">g(n) = \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)</script> （其中 <script type="math/tex">a \geq 1, b > 1</script>，<script type="math/tex">n=b^k</script>），则</p><ol><li><p>若存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \mathcal{O} \left(n^{\log_b a - \varepsilon} \right)</script>，则 <script type="math/tex">g(n) = \mathcal{O}\left(n^{\log_b a}\right)</script></p></li><li><p>若存在 <script type="math/tex">k \geq 0</script>，使得 <script type="math/tex">f(n) = \Theta\left(n^{\log_b a} \lg^k n\right)</script>，则 <script type="math/tex">g(n) = \Theta\left(n^{\log_b a} \lg^{k+1} n\right)</script></p></li><li><p>若存在 <script type="math/tex">0<c<1</script>及正整数 <script type="math/tex">N</script>，使得当 <script type="math/tex">n>N</script> 时，有 <script type="math/tex">af\left(\frac{n}{b}\right) \leq cf(n)</script>，则 <script type="math/tex">g(n) = \Theta(f(n))</script></p></li></ol><p><strong>证明：①</strong> 当 <script type="math/tex">f(n) = \mathcal{O} \left(n^{\log_b a - \varepsilon} \right)</script> 时，<script type="math/tex">f\left(\frac{n}{b^i}\right) = \mathcal{O}\left(\left(\frac{n}{b^i}\right)^{\log_b a - \varepsilon}\right)</script></p><p>此时</p><script type="math/tex; mode=display">\begin{aligned}g(n) &= \sum_\limits{i = 0}^{\log_b n - 1} a^i \cdot \mathcal{O}\left(\left(\frac{n}{b^i}\right)^{\log_b a - \varepsilon}\right) \\&=\mathcal{O} \left(\sum_\limits{i = 0}^{\log_b n - 1} a^i \cdot \left(\frac{n}{b^i}\right)^{\log_b a - \varepsilon}\right) \\&=\mathcal{O} \left(n^{\log_b a - \varepsilon} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \left(\frac{a}{b^{\log_b a - \varepsilon}}\right)^i\right) \\&=\mathcal{O} \left(n^{\log_b a - \varepsilon} \cdot \sum_\limits{i = 0}^{\log_b n - 1} b^{i\varepsilon}\right) \\&=\mathcal{O} \left(n^{\log_b a - \varepsilon} \cdot \frac{n^\varepsilon - 1}{b^\varepsilon - 1}\right) \\&=\mathcal{O} \left(\frac{n^{\log_b a}}{b^\varepsilon - 1} - \frac{n^{\log_b a - \varepsilon}}{b^\varepsilon - 1}\right) \\&=\mathcal{O} \left(n^{\log_b a} \right)\end{aligned}</script><p><strong>②</strong> 当 <script type="math/tex">f(n) = \Theta\left(n^{\log_b a} \lg^k n\right)</script> 时，<script type="math/tex">f\left(\frac{n}{b^i}\right) = \Theta \left( \left(\frac{n}{b^i}\right)^{\log_b a} \lg^k \left(\frac{n}{b^i}\right)\right)</script></p><p>此时</p><script type="math/tex; mode=display">\begin{aligned}g(n) &= \sum_\limits{i = 0}^{\log_b n - 1} a^i \cdot \Theta\left(\left(\frac{n}{b^i}\right)^{\log_b a} \lg^k \left(\frac{n}{b^i}\right)\right) \\&= \Theta \left(\sum_\limits{i = 0}^{\log_b n - 1} a^i\left(\frac{n}{b^i}\right)^{\log_b a} \lg^k \left(\frac{n}{b^i}\right)\right) \\&=\Theta \left(n^{\log_b a} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \lg^k \left(\frac{n}{b^i}\right)\right) \\&=\Theta \left(n^{\log_b a} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \left(\lg n - i \lg b \right)^k\right)\end{aligned}</script><p>由二项式定理可知，<script type="math/tex">\left(\lg n - i \lg b \right)^k = \lg^k n + \mathcal{O}\left(\lg^k n\right)</script></p><p>故</p><script type="math/tex; mode=display">\begin{aligned}g(n) &= \Theta \left(n^{\log_b a} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \left(\lg^k n + \mathcal{O} \left(\lg^k n \right)\right)\right) \\&= \Theta \left(n^{\log_b a} \cdot \left(\log_b n \cdot \lg^k n + \log_b n \cdot \mathcal{O} \left(\lg^k n \right)\right)\right) \\&=\Theta \left( n^{\log_b a} \cdot \log_b n \cdot \lg^k n\right) \\&=\Theta \left(n^{\log_b a} \lg^{k+1} n\right)\end{aligned}</script><p><strong>③</strong> 由 <script type="math/tex">g(n) = f(n) + \sum_\limits{i = 1}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)</script> 可知 <script type="math/tex">g(n) = \Omega(f(n))</script></p><p>由条件存在 <script type="math/tex">c<1</script>及正整数 <script type="math/tex">N</script>，使得当 <script type="math/tex">n>N</script> 时，有 <script type="math/tex">af\left(\frac{n}{b}\right) \leq cf(n)</script></p><p>作递推可知，当 <script type="math/tex">\frac{n}{b^{i-1}}>N</script> 时，有 <script type="math/tex">a^i f\left(\frac{n}{b^i}\right) \leq c^if(n)</script></p><p>故</p><script type="math/tex; mode=display">\begin{aligned}g(n) &= \sum_\limits{i = 0}^{\log_b n - \log_b N} a^i f \left( \frac{n}{b^i} \right) + \sum_\limits{i = \log_b n - \log_b N + 1}^{\log_b n - 1} a^i f \left( \frac{n}{b^i} \right) \\&\leq \sum_\limits{i = 0}^{\log_b n - \log_b N}c^if(n) + \Theta(1) \\&=f(n) \sum_\limits{i = 0}^{\log_b n - \log_b N}c^i + \Theta(1) \\&\leq f(n) \sum_\limits{i = 0}^{\infty}c^i + \Theta(1) \\&=\frac{1}{1-c} \cdot f(n) + \Theta(1) \\&=\mathcal{O}(f(n))\end{aligned}</script><p>由此可得 <script type="math/tex">g(n) = \Theta(f(n))</script></p></blockquote><p>由于 <script type="math/tex">T(n)=\Theta \left(n^{\log_b a} \right) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)</script>，故根据引理我们就能快速得到 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的 <script type="math/tex">k</script> 次幂时的主定理。</p><p>下面我们需要将 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的 <script type="math/tex">k</script> 次幂时的主定理推广到 <script type="math/tex">n</script> 为一切整数时的情况以证明完整的主定理成立。</p><p>首先由于</p><script type="math/tex; mode=display">\begin{aligned}T(n)&=aT\left(\lceil{\frac{n}{b}\rceil}\right) + f(n) \\&\geq aT\left(\frac{n}{b}\right) + f(n)\end{aligned}</script><p>故根据 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的幂次时的主定理可知当 <script type="math/tex">T(n)=aT\left(\lceil{\frac{n}{b}\rceil}\right) + f(n)</script> 时，<script type="math/tex">T(n)=\Omega(A)</script> （根据不同情况 <script type="math/tex">A</script> 取 <script type="math/tex">n^{\log_b a}</script>、<script type="math/tex">n^{\log_b a} \lg^{k+1} n</script> 或 <script type="math/tex">f(n)</script>）</p><p>同理可得当 <script type="math/tex">T(n)=aT\left(\lfloor{\frac{n}{b}\rfloor}\right) + f(n)</script> 时，<script type="math/tex">T(n)=\mathcal{O}(A)</script> </p><p>下面我们来证明当 <script type="math/tex">T(n)=aT\left(\lceil{\frac{n}{b}\rceil}\right) + f(n)</script> 时，<script type="math/tex">T(n)=\mathcal{O}(A)</script> </p><p>令 <script type="math/tex">t_0 = n, t_1 = \lceil{\frac{t_0}{b} \rceil}, t_2 = \lceil{\frac{t_1}{b} \rceil}, ..., t_k = \lceil{\frac{t_{k - 1}}{b} \rceil}=\Theta(1)</script></p><p>由于</p><script type="math/tex; mode=display">\begin{aligned}t_1 &\leq \frac{n}{b} + 1 \\t_2 &\leq \frac{t_1}{b} + 1 \leq \frac{n}{b^2} + \frac{1}{b} + 1 \\... \\t_k &\leq \frac{t_{k-1}}{b} + 1 \leq \frac{n}{b^k} + \sum_\limits{i = 0}^{k-1} \frac{1}{b^i}\end{aligned}</script><p>故</p><script type="math/tex; mode=display">\begin{aligned}t_k &\leq \frac{n}{b^k} + \sum_\limits{i = 0}^{\infty} \frac{1}{b^i} \\&=\frac{n}{b^k} + \frac{b}{b-1}\end{aligned}</script><p>由于当 <script type="math/tex">k = \lfloor{\log_b n\rfloor}</script> 时有</p><script type="math/tex; mode=display">\frac{n}{b^k} + \frac{b}{b-1} \leq \frac{n}{b^{\log_b n - 1}} + \frac{b}{b-1} = \frac{b^2}{b-1} = \Theta(1)</script><p>故 <script type="math/tex">k \leq \lfloor{\log_b n\rfloor}</script></p><p>故对原式作递推，可得</p><script type="math/tex; mode=display">\begin{aligned}T(n) &= aT\left(t_1\right) + f(t_0) \\&= a^2T(t_2) + af(t_1) + f(t_0) \\&... \\&\leq \Theta \left(n^{\log_b a} \right) + \sum_\limits{i = 0}^{\lfloor{\log_b n \rfloor} - 1} a^i f\left(t_i\right)\end{aligned}</script><p>因此由上面 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的幂次时主定理得推导过程同理可得，<script type="math/tex">T(n) \leq \Theta(A)</script>，即 <script type="math/tex">T(n) = \mathcal{O}(A)</script></p><p>类似的我们同样可以得到当 <script type="math/tex">T(n)=aT\left(\lfloor{\frac{n}{b}\rfloor}\right) + f(n)</script> 时，<script type="math/tex">T(n)=\Omega(A)</script> </p><p>于是综上所述，<script type="math/tex">T(n) = \Theta(A)</script> 可推广到一切正整数，即主定理成立</p><h2 id="主方法的局限性"><a href="#主方法的局限性" class="headerlink" title="主方法的局限性"></a>主方法的局限性</h2><p>通俗来说，若要使用主方法，<script type="math/tex">f(n)</script> 必须多项式意义上的小于或大于 <script type="math/tex">n^{\log_b a}</script>（即 <script type="math/tex">f(n)</script> 与 <script type="math/tex">n^{\log_b a}</script> 的阶数差能够被某个 <script type="math/tex">n^\varepsilon</script> 控制住），或者 <script type="math/tex">f(n)</script> 仅比 <script type="math/tex">n^{\log_b a}</script> 大 <script type="math/tex">\log</script> 阶。而这三种情况并不能覆盖 <script type="math/tex">f(n)</script> 所有可能的函数特征，若 <script type="math/tex">f(n)</script> 的阶数在这三种情况之间，主方法就失效了。</p><p>例如当 <script type="math/tex">T(n) = 3T \left(\frac{n}{3}\right) + \frac{n}{\lg n}</script> 时，对于 <script type="math/tex">f(n) = \frac{n}{\lg n}</script>，无法找到某个 <script type="math/tex">\varepsilon > 0</script> 使得 <script type="math/tex">f(n) = \mathcal{O}(n)</script>，即 <script type="math/tex">f(n)</script> 不是多项式意义上的小于 <script type="math/tex">\log_b a</script>，此时便无法使用主定理得到该递归式的渐近解。</p><p>此外，主方法要求递归式必须由平均划分的子式定义，而对于如 <script type="math/tex">T(n) = T\left(\frac{n}{2} \right) + T\left(\frac{n}{4} \right) + T\left(\frac{n}{8} \right) + n</script> 这样非平均划分子式定义的递归式，同样无法使用主方法求解。</p><p>遇到此类问题，<strong>《算法导论》</strong>中推荐使用<strong>画递归树+数学归纳证明</strong>的方法解决。然而对于一些子问题情况较为复杂的递归式，这种方法的效率十分低下且容易出错，有时并不能很好的作为一种普适的办法使用。</p><h2 id="Akra-Bazzi定理"><a href="#Akra-Bazzi定理" class="headerlink" title="Akra-Bazzi定理"></a>Akra-Bazzi定理</h2><p>Akra-Bazzi定理是由两位黎巴嫩数学家<strong>Mohamad Akra</strong>和<strong>Louay Bazzi</strong>于1998年提出的一种用于求解线性递归式的渐近解的定理。Akra-Bazzi定理相比主定理对递归式的要求更弱，其适用范围也远广于主定理。</p><p>为了引出Akra-Bazzi定理，我们需要定义一个<strong>多项式增长条件</strong></p><blockquote><p><strong>Definition:</strong> 设 <script type="math/tex">g(x)</script> 为一定义在非负实数上的函数，<script type="math/tex">\{b_k\}</script> 为一个含有 <script type="math/tex">k</script> 项的数列且满足 <script type="math/tex">0 < b_i< 1</script>，若存在正常数 <script type="math/tex">c_1, c_2</script> 使得对任意 <script type="math/tex">x \geq 1, 1 \leq i \leq k, u \in [b_i x , x]</script>，均有 <script type="math/tex">c_1 g(x) \leq g(u) \leq c_2 g(x)</script> ，则称 <script type="math/tex">g(x)</script> 满足多项式增长条件</p></blockquote><p>由定义可知，若存在 <script type="math/tex">c > 0</script> ，使得 <script type="math/tex">|g'(x)| \in \mathcal{O}(x^c)</script>，则 <script type="math/tex">g(x)</script> 满足多项式增长条件。例如，对任意 <script type="math/tex">\alpha, \beta \in \mathbb{R}</script>，<script type="math/tex">g(x) = x^{\alpha} \lg^{\beta} x</script> 均满足多项式增长条件。</p><p>下面我们来叙述Akra-Bazzi定理：</p><blockquote><p><strong>Theorem:</strong> 设 <script type="math/tex">g(x)</script> 为一非负函数， <script type="math/tex">T(x) = \left\{ \begin{aligned} &\Theta(1)&, &1 \leq x \leq X_0 \\ &\sum_\limits{i = 1}^k a_i T(b_i x) +g(x)&, &x > X_0 \end{aligned}\right.</script>（其中 <script type="math/tex">k \geq 1, a_i > 0, 0 < b_i < 1</script>，<script type="math/tex">X_0</script> 满足对任意 <script type="math/tex">1 \leq i \leq k</script> 有 <script type="math/tex">X_0 > \frac{1}{b_i}</script> 且 <script type="math/tex">X_0> \frac{1}{1-b_i}</script>），若 <script type="math/tex">g(x)</script> 满足多项式增长条件，<script type="math/tex">p</script> 为方程 <script type="math/tex">\sum_\limits{i = 1}^k a_i b_i^p = 1</script> 的实数解，则</p><script type="math/tex; mode=display">\begin{aligned}T(x) &= \Theta \left(x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\right)\end{aligned}</script></blockquote><p>通过该定理，我们可以快速求解许多主方法无法处理的递归式。</p><blockquote><p><strong>Example1:</strong> 设 <script type="math/tex">T(n) = 2T \left( \frac{n}{4}\right) + 3T \left(\frac{n}{6} \right) + n \lg n</script>，求 <script type="math/tex">T(n)</script> 的渐近解</p><p><strong>解：</strong>由 <script type="math/tex">\frac{2}{4^p} + \frac{3}{6^p} = 1</script> 可知 <script type="math/tex">p = 1</script></p><p>故由Akra-Bazzi定理可知</p><script type="math/tex; mode=display">\begin{aligned}T(n) &= \Theta \left(n \left(1 + \int_1^n \frac{x \lg x}{x^2} dx\right)\right) \\&=\Theta \left(n \left(1 + \frac{1}{2}\lg^2 n \right)\right) \\&=\Theta \left(n \lg^2 n \right)\end{aligned}</script><p><strong>Example2:</strong> 设 <script type="math/tex">T(n) = 3T \left( \frac{n}{3}\right) + \frac{n}{\lg n}</script>（<script type="math/tex">n \geq 2</script>），求 <script type="math/tex">T(n)</script> 的渐近解</p><p><strong>解：</strong>由 <script type="math/tex">\left(\frac{3}{3}\right)^p = 1</script> 可知 <script type="math/tex">p = 1</script></p><p>故由Akra-Bazzi定理可知</p><script type="math/tex; mode=display">\begin{aligned}T(n) &= \Theta \left(n \left( 1 + \int_2^n \frac{\frac{x}{\lg x}}{x^2} dx\right)\right) \\&=\Theta \left(n \left( 1 + \int_2^n \frac{1}{x \lg x} dx\right)\right) \\&=\Theta \left(n \left( 1 + \lg \lg n \right) \right) \\&=\Theta(n \lg \lg n)\end{aligned}</script><p><strong>Example3:</strong> 设 <script type="math/tex">T(n) = \frac{1}{2} T \left( \frac{n}{2} \right) + \frac{1}{n}</script>，求 <script type="math/tex">T(n)</script> 的渐近解</p><p>解：由 <script type="math/tex">\frac{1}{2} \cdot \left(\frac{1}{2}\right)^p = 1</script> 可知 <script type="math/tex">p = -1</script></p><p>故由Akra-Bazzi定理可知</p><script type="math/tex; mode=display">\begin{aligned}T(n) &= \Theta \left(n^{-1} \left( 1 + \int_1^n \frac{\frac{1}{x}}{x^0} dx \right)\right) \\&= \Theta(\left(n^{-1} \left(1 + \ln n \right) \right) \\&= \Theta \left(\frac{\ln n}{n}\right)\end{aligned}</script></blockquote><h2 id="Akra-Bazzi定理的证明"><a href="#Akra-Bazzi定理的证明" class="headerlink" title="Akra-Bazzi定理的证明"></a>Akra-Bazzi定理的证明</h2><p>Akra-Bazzi的原始论文中使用了一种称为<strong>阶变换（Order Transform）</strong>的技巧来导出Akra-Bazzi定理，但完整过程篇幅较长且较为复杂。在已经知道结论的情况下，我们还可以使用数学归纳法来证明Akra-Bazzi定理，这种方法更加简洁且相对容易理解。</p><p>首先我们证明一个引理</p><blockquote><p><strong>Lemma:</strong> 若 <script type="math/tex">g(x)</script> 为一非负函数且满足多项式增长条件，则存在 <script type="math/tex">c_3, c_4 > 0</script>，使得对任意 <script type="math/tex">x \geq 1, 1 \leq i \leq k</script>，有</p><script type="math/tex; mode=display">c_3 g(x) \leq x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du \leq c_4 g(x)</script><p><strong>证明：</strong> <script type="math/tex">g(x)</script> 满足多项式增长条件，即存在正常数 <script type="math/tex">c_1, c_2</script> 使得对任意 <script type="math/tex">x \geq 1, 1 \leq i \leq k, u \in [b_i x , x]</script>，均有 <script type="math/tex">c_1 g(x) \leq g(u) \leq c_2 g(x)</script> </p><p>故</p><script type="math/tex; mode=display">\begin{aligned}x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du &\leq c_2 x^p g(x) \cdot \int_{b_i x}^x \frac{1}{u^{p + 1}} du \\&\leq c_2 x^p g(x) \cdot (x - b_i x) \cdot \max \{ \frac{1}{(b_i x)^{p+1}}, \frac{1}{x^{p+1}}\} \\&=c_2 \cdot (1-b_i) \cdot \max \{\frac{1}{b_i^{p+1}}, 1 \} \cdot g(x)\end{aligned}</script><p>因此仅需令 <script type="math/tex">c_4 \geq c_2 \cdot (1-b_i) \cdot \max \{\frac{1}{b_i^{p+1}}, 1 \}</script>，就有 <script type="math/tex">x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du \leq c_4 g(x)</script></p><p>同理，令 <script type="math/tex">c_3 \leq c_2 \cdot (1-b_i) \cdot \min \{\frac{1}{b_i^{p+1}}, 1 \}</script>，就有 <script type="math/tex">x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du \geq c_3 g(x)</script></p><p>故原命题成立</p></blockquote><p>下面我们使用数学归纳法证明存在 <script type="math/tex">c_5>0, x_1 > 1</script>，使得对任意 <script type="math/tex">x > x_1</script>，有 <script type="math/tex">T(x) \geq c_5 \cdot x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)</script></p><p>由于 <script type="math/tex">T(x)</script> 的取值范围包含大于1的一切实数，我们不能直接对 <script type="math/tex">x</script> 进行归纳。</p><p>为了使用数学归纳法，我们令 <script type="math/tex">I_0 = [1, X_0], I_1 = (X_0+1, X_0+2], ..., I_j = (X_0 + j -1, X_0 + j]</script>。易见 <script type="math/tex">x</script> 必然落在某一个区间 <script type="math/tex">j_0</script> 内，且 <script type="math/tex">b_i x</script> 必然落在 <script type="math/tex">j_0</script> 前面的某一区间内，因此我们可以对 <script type="math/tex">I_j</script> 进行归纳。</p><p>当 <script type="math/tex">j=0</script> 时，由定义可知 <script type="math/tex">T(x) = \Theta(1)</script>，结论显然成立</p><p>若结论对任意 <script type="math/tex">j < j_0</script> 均成立，则当 <script type="math/tex">j=j_0</script> 时，有</p><script type="math/tex; mode=display">\begin{aligned}T(x) &= \sum_\limits{i = 1}^k a_i T(b_i x) +g(x) \\&\geq \sum_\limits{i = 1}^k a_i \cdot c_5 \cdot (b_i x)^p \left( 1 + \int_1^{b_i x} \frac{g(u)}{u^{p+1}} du\right) +g(x) \\&=c_5 x ^p \sum_\limits{i = 1}^k a_i \cdot b_i^p \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du - \int_{b_i x}^{x} \frac{g(u)}{u^{p+1}} du\right) +g(x) \\&\geq c_5 x ^p \cdot \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du - \frac{c_4}{x_p}g(x)\right) \cdot \sum_\limits{i = 1}^k a_i b_i^p +g(x) \\&=c_5 x ^p \cdot \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du - \frac{c_4}{x_p}g(x)\right) +g(x) \\&=c_5 x ^p \cdot \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du \right) - (c_4c_5 - 1) g(x)\end{aligned}</script><p>因此，只需令 <script type="math/tex">c_5 \leq \frac{1}{c_4}</script>，就有 <script type="math/tex">T(x) \geq c_5 \cdot x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)</script> 成立</p><p>即 <script type="math/tex">T(x) = \Omega \left( x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right) \right)</script></p><p>同理可证得  <script type="math/tex">T(x) = \mathcal{O} \left( x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right) \right)</script></p><p>由此我们便证得了最终的结论 <script type="math/tex">T(x) = \Theta \left(x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\right)</script></p><h2 id="推广的Akra-Bazzi定理"><a href="#推广的Akra-Bazzi定理" class="headerlink" title="推广的Akra-Bazzi定理"></a>推广的Akra-Bazzi定理</h2><p>事实上，<strong>Tom Leighton</strong>还给出过一个更一般形式的Akra-Bazzi推广定理</p><blockquote><p><strong>Definition（推广的多项式增长条件）:</strong> 设 <script type="math/tex">g(x),h(x)</script> 均为定义在非负实数上的函数，<script type="math/tex">\{b_k\}</script> 为一个含有 <script type="math/tex">k</script> 项的数列且满足 <script type="math/tex">0 < b_i< 1</script>，若存在正常数 <script type="math/tex">c_1, c_2</script> 使得对任意 <script type="math/tex">x \geq 1, 1 \leq i \leq k, u \in [b_i x + h_i(x), x]</script>，均有 <script type="math/tex">c_1 g(x) \leq g(u) \leq c_2 g(x)</script> ，则称 <script type="math/tex">g(x)</script> 满足多项式增长条件</p><p><strong>Theorem:</strong> 设 <script type="math/tex">g(x)</script> 为一非负函数， <script type="math/tex">T(x) = \left\{ \begin{aligned} &\Theta(1)&, &1 \leq x \leq X_0 \\ &\sum_\limits{i = 1}^k a_i T(b_i x + h_i(x)) +g(x)&, &x > X_0 \end{aligned}\right.</script>，若满足以下四个条件：</p><p>(1) <script type="math/tex">k \geq 1</script>，对任意 <script type="math/tex">1 \leq i \leq k</script>，有 <script type="math/tex">a_i > 0, 0 < b_i < 1</script></p><p>(2) <script type="math/tex">X_0</script> 为一足够大的常数，使得存在 <script type="math/tex">\varepsilon > 0</script>，对任意 <script type="math/tex">1 \leq i \leq k, x \geq X_0</script>，满足以下四个条件：</p><script type="math/tex; mode=display">\begin{aligned}&(a) \left( 1 - \frac{1}{b_i \lg^{1+\varepsilon} x} \right)^p \left( 1 + \frac{1}{\lg^{\frac{\varepsilon}{2}} \left( b_i x + \frac{x}{\lg^{1+\varepsilon} x}\right)} \right) \geq 1+ \frac{1}{\lg^{\frac{\varepsilon}{2}} x} \\&(b) \left( 1 + \frac{1}{b_i \lg^{1+\varepsilon} x} \right)^p \left( 1 - \frac{1}{\lg^{\frac{\varepsilon}{2}} \left( b_i x + \frac{x}{\lg^{1+\varepsilon} x}\right)} \right) \leq 1- \frac{1}{\lg^{\frac{\varepsilon}{2}} x} \\&(c) \frac{1}{2} \left( 1 + \frac{1}{\lg^{\frac{\varepsilon}{2}} x}\right) \leq 1 \\&(d) 2 \left( 1 - \frac{1}{\lg^{\frac{\varepsilon}{2}} x} \right) \geq 1\end{aligned}</script><p>(3) 存在 <script type="math/tex">\varepsilon > 0</script> 使得对任意 <script type="math/tex">1 \leq i \leq k, x > X_0</script>，均有 <script type="math/tex">|h_i(x)| \leq \frac{x}{\lg^{1+\varepsilon} x}</script></p><p>(4) <script type="math/tex">g(x)</script> 满足多项式增长条件</p><p>若设 <script type="math/tex">p</script> 为方程 <script type="math/tex">\sum_\limits{i = 1}^k a_i b_i^p = 1</script> 的实数解，则</p><script type="math/tex; mode=display">\begin{aligned}T(x) &= \Theta \left(x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\right)\end{aligned}</script></blockquote><p>该定理在Akra-Bazzi的基础上，进一步考虑了递归式参数中带余项的情况，因此适用面更广。与Akra-Bazzi类似，其正确性同样可以使用数学归纳法验证，不过篇幅较长，这里就不详细阐述了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;主方法&quot;&gt;&lt;a href=&quot;#主方法&quot; class=&quot;headerlink&quot; title=&quot;主方法&quot;&gt;&lt;/a&gt;主方法&lt;/h2&gt;&lt;p&gt;在算法分析中，当我们使用分治法求解问题时，通常会遇到以递归式定义的算法运行时间函数。要得到此类算法的时间复杂度，就必须求出该递归式的渐近表达式。通常情况下，我们可以通过如下公式直接得到大部分不太复杂的递归式的渐近解。&lt;strong&gt;《算法导论》&lt;/strong&gt;一书中将该方法称为&lt;strong&gt;“主方法”&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.me/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数的相关算法</title>
    <link href="http://gonggongjohn.me/2020/10/30/fibonacci/"/>
    <id>http://gonggongjohn.me/2020/10/30/fibonacci/</id>
    <published>2020-10-30T15:29:04.000Z</published>
    <updated>2021-01-21T07:10:05.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列由以下递推式定义：</p><script type="math/tex; mode=display">\left\{\begin{aligned}&F(0)=0 \\&F(1)=1 \\&F(n)=F(n-1)+F(n-2),n \geq 2\end{aligned}\right.</script><a id="more"></a><p>下面我们来推导斐波那契数列的通项公式</p><p>设矩阵 <script type="math/tex">M=\begin{pmatrix} m_{11} & m_{12} \\ m_{21} & m_{22} \end{pmatrix}</script>，使得 <script type="math/tex">\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix} =M \begin{pmatrix} F_{n} \\ F_{n-1} \end{pmatrix}</script></p><p>故</p><script type="math/tex; mode=display">\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}=\begin{pmatrix}m_{11} & m_{12} \\m_{21} & m_{22}\end{pmatrix}\begin{pmatrix}F_{n} \\F_{n-1}\end{pmatrix}=\begin{pmatrix}m_{11}F_{n}+m_{12}F_{n-1} \\m_{21}F_{n}+m_{22}F_{n-1}\end{pmatrix}</script><p>对比等式左右可得 <script type="math/tex">m_{11}=m_{12}=m_{21}=1,m_{22}=0</script>，即 <script type="math/tex">M=\begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}</script></p><p>由此可知</p><script type="math/tex; mode=display">\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}=\begin{pmatrix}1 & 1 \\1 & 0\end{pmatrix}\begin{pmatrix}F_{n} \\F_{n-1}\end{pmatrix}</script><p>对该矩阵等式做递推，可得</p><script type="math/tex; mode=display">\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}=\begin{pmatrix}1 & 1 \\1 & 0\end{pmatrix}^n\begin{pmatrix}F_{1} \\F_{0}\end{pmatrix}=\begin{pmatrix}1 & 1 \\1 & 0\end{pmatrix}^n\begin{pmatrix}1 \\0\end{pmatrix}</script><p>易知 <script type="math/tex">\begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}</script> 的特征多项式 <script type="math/tex">f(\lambda) = \begin{vmatrix} \lambda - 1 & -1 \\ -1 & \lambda \end{vmatrix} = \lambda^2 - \lambda - 1</script></p><p>令 <script type="math/tex">f(\lambda) = 0</script>，可得该矩阵的特征值 <script type="math/tex">\lambda_1 = \frac{1 - \sqrt{5}}{2}, \lambda_2 = \frac{1 + \sqrt{5}}{2}</script></p><p>由此可知该矩阵可相似对角化</p><p>对于 <script type="math/tex">\lambda_1 = \frac{1-\sqrt{5}}{2}</script>，其对应的特征向量 <script type="math/tex">\alpha_1 = \left(\frac{1-\sqrt{5}}{2},1\right)</script></p><p>对于 <script type="math/tex">\lambda_2 = \frac{1+\sqrt{5}}{2}</script>，其对应的特征向量 <script type="math/tex">\alpha_2 = \left(\frac{1+\sqrt{5}}{2},1\right)</script></p><p>故若令 <script type="math/tex">P=\begin{pmatrix} \frac{1-\sqrt{5}}{2} & \frac{1+\sqrt{5}}{2} \\ 1 & 1 \end{pmatrix}</script>，则</p><script type="math/tex; mode=display">\begin{pmatrix}1 & 1 \\1 & 0\end{pmatrix}=P\begin{pmatrix}\frac{1-\sqrt{5}}{2} & 0\\ 0 & \frac{1+\sqrt{5}}{2}\end{pmatrix}P^{-1}</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}&=P\begin{pmatrix}\frac{1-\sqrt{5}}{2} & 0\\ 0 & \frac{1+\sqrt{5}}{2}\end{pmatrix}^nP^{-1}\begin{pmatrix}1 \\0\end{pmatrix} \\&=\begin{pmatrix}\frac{1-\sqrt{5}}{2} & \frac{1+\sqrt{5}}{2} \\1 & 1\end{pmatrix}\begin{pmatrix}\left(\frac{1-\sqrt{5}}{2}\right)^n & 0\\ 0 & \left(\frac{1+\sqrt{5}}{2}\right)^n\end{pmatrix}\begin{pmatrix}-\frac{1}{\sqrt{5}} & \frac{5 + \sqrt{5}}{10} \\\frac{1}{\sqrt{5}} & \frac{5 - \sqrt{5}}{10}\end{pmatrix}\begin{pmatrix}1 \\0\end{pmatrix} \\&=\begin{pmatrix}\frac{1-\sqrt{5}}{2} & \frac{1+\sqrt{5}}{2} \\1 & 1\end{pmatrix}\begin{pmatrix}-\frac{1}{\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n \\\frac{1}{\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^n\end{pmatrix} \\&=\begin{pmatrix}\frac{\sqrt{5}-1}{2\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n + \frac{\sqrt{5}+1}{2\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^n \\-\frac{1}{\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n + \frac{1}{\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^n\end{pmatrix}\end{aligned}</script><p>由此我们得到了斐波那契数列的通项公式</p><script type="math/tex; mode=display">F_n = \frac{1}{\sqrt{5}} \left[\left(\frac{1+\sqrt{5}}{2}\right)^n - \left(\frac{1-\sqrt{5}}{2}\right)^n \right]</script><h2 id="朴素递归算法"><a href="#朴素递归算法" class="headerlink" title="朴素递归算法"></a>朴素递归算法</h2><p>朴素递归算法即为递推式定义的程序表达，采用递归的方法实现。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易得该算法时间复杂度的递推表达式为 <script type="math/tex">T(n)=T(n-1)+T(n-2)+\Theta(1)</script></p><p>观察递归树可以发现，所有叶子结点的和就是 <script type="math/tex">\Theta(F_n)</script> ，而所有内部节点的和为 <script type="math/tex">\Theta(F_n-1)</script></p><p>故朴素递归算法的时间复杂度 </p><script type="math/tex; mode=display">\begin{aligned}T(n)&=\Theta(F_n) + \Theta(F_n-1) \\&=\Theta(F_n) \\&=\Theta\left(\left(\frac{1+\sqrt{5}}{2}\right)^n\right) \\&=\mathcal{O}(1.62^n)\end{aligned}</script><h2 id="自下而上算法"><a href="#自下而上算法" class="headerlink" title="自下而上算法"></a>自下而上算法</h2><p>朴素递归算法的时间复杂度为指数级，这显然是难以接受的。观察发现朴素递归算法的主要问题是重复求解了许多子问题，其本质原因在于朴素递归算法是自上而下的求解子问题，而不同子问题中重叠的部分无法相互影响。故我们换一种思路，自下而上的求解，就可以很好的解决这一问题。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[N]; <span class="comment">//N is the biggest possible value</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易知该算法的时间复杂度 <script type="math/tex">T(n)=n-1=\Theta(n)</script></p><h2 id="矩阵快速幂算法"><a href="#矩阵快速幂算法" class="headerlink" title="矩阵快速幂算法"></a>矩阵快速幂算法</h2><p>自下而上算法已经将原本的指数级时间复杂度降低到了多项式级，我们希望能够进一步的将其降低到对数级别。自然的，我们首先想到的是利用其通项公式并通过快速幂的方法来求解。但斐波那契数列的通项公式中包含无理数，由于计算机的精度限制，计算结果可能并不正确，故这种方法显然是不可靠的。</p><p><strong>注：</strong>事实上，若不存在精度限制的问题，斐波那契数列还可以表示为 <script type="math/tex">F_n = \left[ \left(\frac{1+\sqrt{5}}{2}\right)^n \right]</script> （其中 <script type="math/tex">[x]</script> 表示取整到离 <script type="math/tex">x</script> 最近的整数）</p><p>于是问题转化为是否存在一个仅需在整数域内进行运算的斐波那契通项公式。回顾上面求解斐波那契数列通项公式的过程，注意到 <script type="math/tex">\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix} = \begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}^n \begin{pmatrix} 1 \\ 0 \end{pmatrix}</script>，故我们可以通过求解该矩阵来得到 <script type="math/tex">F_n</script> 的值。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    matrix(<span class="keyword">int</span> a11, <span class="keyword">int</span> a12, <span class="keyword">int</span> a21, <span class="keyword">int</span> a22)&#123;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = a11;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">1</span>] = a12;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>] = a21;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>] = a22;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//This function can only handle 2*2 matrix multiplication</span></span><br><span class="line"><span class="function">matrix <span class="title">matrixMult</span><span class="params">(matrix matA, matrix matB)</span></span>&#123;</span><br><span class="line">    <span class="function">matrix <span class="title">matR</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                matR.a[i][j] += matA.a[i][k] * matB.a[k][j];</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">matrixPow</span><span class="params">(matrix mat, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> mat;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        matrix matT = matrixPow(mat, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMult(matT, matT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        matrix matT1 = matrixPow(mat, (n - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        matrix matT2 = matrixMult(matT1, matT1);</span><br><span class="line">        <span class="keyword">return</span> matrixMult(matT2, mat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        matrix matT(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        matrix matR = matrixPow(matT, n);</span><br><span class="line">        <span class="keyword">return</span> matR.a[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析该算法，发现其时间复杂度的递推表达式为 <script type="math/tex">T(n) = T\left(\frac{n}{2}\right) + \Theta(1)</script>。故由主定理可知该矩阵快速幂算法的时间复杂度为 <script type="math/tex">T(n) = \Theta(\lg n)</script></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h2&gt;&lt;p&gt;斐波那契数列由以下递推式定义：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left\{
\begin{aligned}
&amp;F(0)=0 \\
&amp;F(1)=1 \\
&amp;F(n)=F(n-1)+F(n-2),n \geq 2
\end{aligned}
\right.&lt;/script&gt;</summary>
    
    
    
    <category term="算法" scheme="http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.me/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>和式的求解方法</title>
    <link href="http://gonggongjohn.me/2020/10/11/sum-solve/"/>
    <id>http://gonggongjohn.me/2020/10/11/sum-solve/</id>
    <published>2020-10-11T12:40:02.000Z</published>
    <updated>2020-10-11T12:44:47.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扰动法"><a href="#扰动法" class="headerlink" title="扰动法"></a>扰动法</h2><p>扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。</p><a id="more"></a><p>令 <script type="math/tex">S_n = \sum_\limits{0 \leq k \leq n} a_k</script></p><script type="math/tex; mode=display">\begin{aligned}S_n + a_{n+1} &= \sum_\limits{0 \leq k \leq n+1} a_k \\&= a_0 + \sum_\limits{1 \leq k \leq n+1} a_k \\&= a_0 + \sum_\limits{1 \leq k+1 \leq n+1} a_{k+1} \\&= a_0 + \sum_\limits{0 \leq k \leq n} a_{k+1}\end{aligned}</script><p>若能将 <script type="math/tex">\sum_\limits{0 \leq k \leq n} a_{k+1}</script> 写为 <script type="math/tex">S_n</script> 的表达式，即可求出该求和式的通项公式</p><blockquote><p><strong>Example1:</strong></p><p>求等比数列和 <script type="math/tex">S_n = \sum_\limits{0 \leq k \leq n} a q^k \ \ (q \neq 1)</script> 的通项公式</p><p><strong>解：</strong> 由上述公式可知</p><script type="math/tex; mode=display">\begin{aligned}S_n + a_{n+1} &= a + \sum_\limits{0 \leq k \leq n} aq^{k+1} \\&=a + q \sum_\limits{0 \leq k \leq n} aq^k \\&=a + q S_n\end{aligned}</script><p>从而 $(1-q)S_n = a - aq^{n+1}$</p><p>故 $S_n = \frac{a\left(1-q^{n+1} \right)}{1-q} \ \ (q \neq 1)$</p><p><strong>Example2:</strong></p><p>求等比差数列和 <script type="math/tex">S_n = \sum_\limits{0 \leq k \leq n} k \cdot q^k \ \ (q \neq 1)</script> 的通项公式</p><p><strong>解：</strong> 由上述公式可知</p><script type="math/tex; mode=display">\begin{aligned}S_n + a_{n+1} &= 0 + \sum_\limits{0 \leq k \leq n} (k+1) \cdot q^{k+1} \\&=\sum_\limits{0 \leq k \leq n} k \cdot q^{k+1} + \sum_\limits{0 \leq k \leq n} q^{k+1} \\&=q \sum_\limits{0 \leq k \leq n} k \cdot q^k + q \sum_\limits{0 \leq k \leq n} q^k \\&=q S_n + q \cdot \frac{1-q^{n+1}}{1-q}\end{aligned}</script><p>从而 $(1-q)S_n = \frac{q-q^{n+2}}{1-q} - (n+1) \cdot q^{n+1}$</p><p>故 </p><script type="math/tex; mode=display">\begin{aligned}S_n &= \frac{q-q^{n+2}}{(1-q)^2} - \frac{(n+1) \cdot q^{n+1}}{1-q} \\&= \frac{q-(n+1)q^{n+1} + nq^{n+2}}{(1-q)^2} \ \ (q \neq 1)\end{aligned}</script></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;扰动法&quot;&gt;&lt;a href=&quot;#扰动法&quot; class=&quot;headerlink&quot; title=&quot;扰动法&quot;&gt;&lt;/a&gt;扰动法&lt;/h2&gt;&lt;p&gt;扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.me/tags/Mathematics/"/>
    
    <category term="Sequence" scheme="http://gonggongjohn.me/tags/Sequence/"/>
    
  </entry>
  
  <entry>
    <title>递归式的解法</title>
    <link href="http://gonggongjohn.me/2020/10/11/recursion-solve/"/>
    <id>http://gonggongjohn.me/2020/10/11/recursion-solve/</id>
    <published>2020-10-11T12:39:48.000Z</published>
    <updated>2020-10-11T12:52:00.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求和因子法"><a href="#求和因子法" class="headerlink" title="求和因子法"></a>求和因子法</h2><p>对于形如 <script type="math/tex">a_n T_n = b_n T_{n-1} + c_n</script>，我们可以求出其通项公式，下面我们来推导这一公式。</p><p>我们考虑通过变量替换的方式将 <script type="math/tex">T_n</script> 前的 <script type="math/tex">a_n</script> 和 <script type="math/tex">b_n</script> 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 <script type="math/tex">b_n T_{n-1}</script> 能够通过 <script type="math/tex">a_n T_n</script> 表示出来（该表达式通常被称为求和因子）。设该表达式为 <script type="math/tex">s_n</script>，两边同乘以 <script type="math/tex">s_n</script>，即为 <script type="math/tex">s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n</script></p><a id="more"></a><p>注意到等式左边均为第 $n$ 项，而右边为 <script type="math/tex">T_{n-1}</script>，故考虑将右边第一项变为 <script type="math/tex">s_{n-1}a_{n-1}T_{n-1}</script>。要做到这一点，就是要让 <script type="math/tex">s_n b_n = s_{n-1} a_{n-1}</script>，也即 <script type="math/tex">s_n = s_{n-1} \cdot \frac{a_{n-1}}{b_n}</script>。做递推，得到 <script type="math/tex">s_n = \frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2} \cdot s_1</script>。故仅需取 <script type="math/tex">s_n = \frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2}</script> 或该式的常数倍即可。</p><p>现在，我们仅需令 <script type="math/tex">P_n = s_n a_n T_n</script>，即可将原式化简为 <script type="math/tex">P_n = P_{n-1} + s_n c_n</script></p><p>故 <script type="math/tex">P_n = P_0 + \sum_\limits{k=1}^n s_k c_k</script></p><p>故 <script type="math/tex">s_n a_n T_n = s_0 a_0 T_0 + \sum_\limits{k=1}^n s_kc_k = s_1b_1T_0 + \sum_\limits{k=1}^n s_kc_k</script></p><p>故 <script type="math/tex">T_n = \frac{1}{s_n a_n} \left( s_1b_1T_0 + \sum_\limits{k=1}^n s_kc_k \right)</script></p><blockquote><p>Example:</p><p>已知Hanoi问题满足以下递归表达式，试求出其通项公式</p><script type="math/tex; mode=display">\left\{\begin{aligned}&T_0 = 0 \\&T_n = 2T_{n-1} + 1\end{aligned}\right.</script><p><strong>解：</strong> 由 $a_n = 1, b_n = 2$ 可知求和因子 $s_n = \frac{1}{2^{n-1}}$。由于 $s_n$ 乘以常数倍不影响其效果 ，故为了方便起见令 $s_n = \frac{1}{2^n}$</p><p>两边同乘以 <script type="math/tex">s_n = \frac{1}{2^n}</script>，得到 <script type="math/tex">\frac{T_n}{2^n} = \frac{T_{n-1}}{2^{n-1}} + \frac{1}{2^n}</script></p><p>令$P_n = \frac{T_n}{2^n}$，则 </p><script type="math/tex; mode=display">\left\{\begin{aligned}&P_n = P_{n-1} + \frac{1}{2^n} \\&P_0 = 0\end{aligned}\right.</script><p>故 <script type="math/tex">P_n = \sum_\limits{k=1}^n \frac{1}{2^k} = 1-\left(\frac{1}{2}\right)^n</script>，即 <script type="math/tex">\frac{T_n}{2^n} = 1-\left(\frac{1}{2}\right)^n</script></p><p>故 <script type="math/tex">T_n = 2^n - 1</script></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;求和因子法&quot;&gt;&lt;a href=&quot;#求和因子法&quot; class=&quot;headerlink&quot; title=&quot;求和因子法&quot;&gt;&lt;/a&gt;求和因子法&lt;/h2&gt;&lt;p&gt;对于形如 &lt;script type=&quot;math/tex&quot;&gt;a_n T_n = b_n T_{n-1} + c_n&lt;/script&gt;，我们可以求出其通项公式，下面我们来推导这一公式。&lt;/p&gt;
&lt;p&gt;我们考虑通过变量替换的方式将 &lt;script type=&quot;math/tex&quot;&gt;T_n&lt;/script&gt; 前的 &lt;script type=&quot;math/tex&quot;&gt;a_n&lt;/script&gt; 和 &lt;script type=&quot;math/tex&quot;&gt;b_n&lt;/script&gt; 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 &lt;script type=&quot;math/tex&quot;&gt;b_n T_{n-1}&lt;/script&gt; 能够通过 &lt;script type=&quot;math/tex&quot;&gt;a_n T_n&lt;/script&gt; 表示出来（该表达式通常被称为求和因子）。设该表达式为 &lt;script type=&quot;math/tex&quot;&gt;s_n&lt;/script&gt;，两边同乘以 &lt;script type=&quot;math/tex&quot;&gt;s_n&lt;/script&gt;，即为 &lt;script type=&quot;math/tex&quot;&gt;s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n&lt;/script&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.me/tags/Mathematics/"/>
    
    <category term="Sequence" scheme="http://gonggongjohn.me/tags/Sequence/"/>
    
  </entry>
  
  <entry>
    <title>快速排序时间复杂度分析</title>
    <link href="http://gonggongjohn.me/2020/10/10/qsort-analyze/"/>
    <id>http://gonggongjohn.me/2020/10/10/qsort-analyze/</id>
    <published>2020-10-10T07:46:07.000Z</published>
    <updated>2021-01-21T07:09:44.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机化快速排序"><a href="#随机化快速排序" class="headerlink" title="随机化快速排序"></a>随机化快速排序</h2><p>随机化快速排序在快速排序的基础上，通过随机数选择一个数作为pivot，使得没有特定的输入数据可以使得该算法达到最坏情况。</p><p>下面我们来分析其平均时间复杂度。</p><a id="more"></a><p>设 <script type="math/tex">X_k</script> 为一个随机变量，使得对任意 <script type="math/tex">k=0,1,...,n-1</script>，有</p><script type="math/tex; mode=display">X_k = \left\{\begin{aligned}1 &, &if \ Partition \ generates \ (k:n-k-1) \ split \\0 &, &otherwise\end{aligned}\right.</script><p>若随机数生成每个数的概率相同，则</p><script type="math/tex; mode=display">\begin{aligned}E[X_k] &= 0 \cdot \Pr \{X_k = 0\} + 1 \cdot \Pr \{X_k = 1\} \\&=\Pr\{X_k = 1\} \\&=\frac{1}{n}\end{aligned}</script><p>设 <script type="math/tex">T(n)</script> 为一个代表总运行时间的随机变量（假设所有的情况均为独立的）</p><p>即</p><script type="math/tex; mode=display">T(n) = \left\{\begin{aligned}T(0) + T(n-1) + \Theta(n) &, &if \ Partition \ generates \ (0:n-1) \ split \\T(1) + T(n-2) + \Theta(n) &, &if \ Partition \ generates \ (1:n-2) \ split \\...... \\T(n-1) + T(0) + \Theta(n) &, &if \ Partition \ generates \ (n-1:0) \ split\end{aligned}\right.</script><p>通过引入 <script type="math/tex">X_k</script>，我们可以把 <script type="math/tex">T(n)</script> 改写为一个和式</p><script type="math/tex; mode=display">T(n) = \sum_\limits{k=0}^{n-1} X_k \left( T(k) + T(n-k-1) + \Theta(n) \right)</script><p>故</p><script type="math/tex; mode=display">\begin{aligned}E[T(n)] &= E \left[\sum_\limits{k=0}^{n-1} X_k \left( T(k) + T(n-k-1) + \Theta(n) \right) \right] \\&=\sum_\limits{k=0}^{n-1} E \left[ X_k \left( T(k) + T(n-k-1) + \Theta(n) \right) \right] \\&=\sum_\limits{k=0}^{n-1} E \left[ X_k \right] \cdot E\left[ \left( T(k) + T(n-k-1) + \Theta(n)\right) \right] \\&=\frac{1}{n} \sum_\limits{k=0}^{n-1} E[T(k)] + \frac{1}{n} \sum_\limits{k=0}^{n-1} E[T(n-k-1)] + \frac{1}{n} \sum_\limits{k=0}^{n-1} E[\Theta(n)] \\&=\frac{2}{n} \sum_\limits{k=0}^{n-1} E[T(k)] + \Theta(n)\end{aligned}</script><p>由此我们得到了一个关于 <script type="math/tex">E[T(n)]</script> 的递推式。下面我们使用<strong>第二数学归纳法</strong>证明：当 <script type="math/tex">n \geq 3</script> 时，存在 <script type="math/tex">a>0</script>，使得 <script type="math/tex">E[T(n)] \leq an \lg n</script></p><p>为了方便起见，我们首先对原式进行适当变形</p><script type="math/tex; mode=display">\begin{aligned}E[T(n)] &=\frac{2}{n} \sum_\limits{k=0}^{n-1} E[T(k)] + \Theta(n) \\&=\frac{2}{n}E[T(0)] + \frac{2}{n}E[T(1)] + \frac{2}{n} \sum_\limits{k=2}^{n-1} E[T(k)] + \Theta(n) \\&=\frac{2}{n} \sum_\limits{k=2}^{n-1} E[T(k)] + \Theta(n)\end{aligned}</script><p>随后，我们需要一个引理</p><blockquote><p>Lemma:</p><script type="math/tex; mode=display">\sum_\limits{k=2}^{n-1} k \lg k \leq \frac{1}{2}n^2 \lg n - \frac{1}{8} n^2</script><p>证明：令 <script type="math/tex">f(x) = x \lg x</script></p><p>则 <script type="math/tex">f'(x) = \lg k + \frac{1}{\ln 2}</script></p><p>故当 <script type="math/tex">x \geq 2</script> 时 <script type="math/tex">f(x)>0</script> 且 <script type="math/tex">f(x)</script> 单调递增</p><p>因此</p><script type="math/tex; mode=display">\begin{aligned}\sum_\limits{k=2}^{n-1} k \lg k &\leq \int_2^n x \lg x dx \\&=\frac{1}{2} \int_2^n \lg x d(x^2) \\&=\frac{1}{2} \left(\left[x^2 \lg x\right]\Big|_2^n - \int_2^n x^2 \cdot \frac{1}{x \ln 2} dx\right) \\&=\frac{1}{2} \left( n^2 \lg n - 4 - \frac{1}{2 \ln 2} \cdot \left[x^2\right]\Big|_2^n\right) \\&=\frac{1}{2}n^2 \lg n - \frac{1}{4 \ln 2}n^2 -2 + \frac{1}{\ln 2} \\&\leq \frac{1}{2}n^2 \lg n -\frac{1}{4\ln2}n^2 \\&\leq \frac{1}{2}n^2 \lg n - \frac{1}{8}n^2\end{aligned}</script></blockquote><p>现在就可以对 <script type="math/tex">n</script> 进行归纳了</p><p>当 <script type="math/tex">n=3</script> 时，<script type="math/tex">E[T(3)]=\Theta(1)</script>，仅需取一足够大的 <script type="math/tex">a</script>，则结论显然成立</p><p>若对 <script type="math/tex">\forall k < n</script>，存在 <script type="math/tex">a>0</script> 使得 <script type="math/tex">E[T(n)] \leq ak \lg k</script> 成立</p><p>则</p><script type="math/tex; mode=display">\begin{aligned}E[T(n)] &\leq \frac{2}{n} \sum_\limits{k=2}^{n-1} ak \lg k + \Theta(n) \\&\leq \frac{2a}{n} \cdot \left( \frac{1}{2}n^2 \lg n - \frac{1}{8}n^2\right) + \Theta(n) \\&=an \lg n - \frac{an}{4} + \Theta(n)\end{aligned}</script><p>故仅需取一足够大的 <script type="math/tex">a</script> 使得 <script type="math/tex">\frac{an}{4}> \Theta(n)</script>，即可使得 <script type="math/tex">E[T(n)] \leq an \lg n</script></p><p>因此 <script type="math/tex">E[T(n)] \leq an \lg n</script> 对 <script type="math/tex">\forall n \geq 3</script> 均成立</p><p>由此可知 <script type="math/tex">E[T(n)] = \mathcal{O}(n \lg n)</script></p><p>同理可得 <script type="math/tex">E[T(n)] = \Omega(n\lg n)</script></p><p>故 <script type="math/tex">E[T(n)] = \Theta(n \lg n)</script></p><p>事实上，原始的快速排序中Partition的操作次数为 <script type="math/tex">n+1</script> 次，故总运行时间的期望还可以进一步写成以下递推式</p><script type="math/tex; mode=display">\left\{\begin{aligned}&E[T(0)] = 0 \\&E[T(n)] = \frac{2}{n}\sum_\limits{k = 0}^{n-1} E[T(k)] + n+1 \ \ (n \geq 1)\end{aligned}\right.</script><p>下面我们来尝试推导该递推式的封闭解</p><p>首先将原式化简为整式，得到 <script type="math/tex">n \cdot E[T(n)] = 2 \sum_\limits{k=0}^{n-1} E[T(k)] + n^2+n</script></p><p>注意到等式右边有一个连续的求和式（即从 <script type="math/tex">E[T(0)]</script> 到 <script type="math/tex">E[T(n-1)]</script> 中没有缺项），故考虑做<strong>差项</strong>消去该求和式。</p><script type="math/tex; mode=display">\left\{\begin{aligned}&n \cdot E[T(n)] = 2 \sum_\limits{k=0}^{n-1} E[T(k)] + n^2+n \\&(n-1) \cdot E[T(n-1)] = 2 \sum_\limits{k=0}^{n-2} E[T(k)] + (n-1)^2+(n-1)\end{aligned}\right.</script><p>两式相减，得到 $n \cdot E[T(n)] - (n-1) \cdot E[T(n-1)] = 2n + 2 \cdot E[T(n-1)]$</p><p>化简得到 <script type="math/tex">n \cdot E[T(n)] = (n+1) \cdot E[T(n-1)] + 2n</script></p><p>接下来我们考虑将 <script type="math/tex">E[T(n)]</script> 和 <script type="math/tex">E[T(n-1)]</script> 前的系数消去以找出通项公式。</p><p>两边同时乘以 <script type="math/tex">\frac{2}{n(n+1)}</script> ，得到 <script type="math/tex">\frac{2}{n+1} \cdot E[T(n)] = \frac{2}{n} \cdot E[T(n-1)] + \frac{4}{n+1}</script></p><p>令 <script type="math/tex">S_n = \frac{2}{n+1} \cdot E[T(n)]</script>，于是原递归式化简为</p><script type="math/tex; mode=display">\left\{\begin{aligned}& S_0 = 0 \\& S_n = S_{n-1} + \frac{4}{n+1}\end{aligned}\right.</script><p>我们可以快速写出该递归式的通项公式 <script type="math/tex">S_n = 4\sum_\limits{k=2}^{n+1} \frac{1}{k}</script></p><p>即 $\frac{2}{n+1} \cdot E[T(n)] =  4\sum_\limits{k=2}^{n+1} \frac{1}{k}$</p><p>化简即得 $E[T(n)] = 2(n+1)\sum_\limits{k=2}^{n+1} \frac{1}{k}$</p><p>引入调和级数符号 $H_n = 1 + \frac{1}{2} + \frac{1}{3} + … + \frac{1}{n}$</p><p>注意到 $\sum_\limits{k=2}^{n+1} \frac{1}{k} = H_n - 1 + \frac{1}{n+1}$</p><p>故我们得到了原递推式的封闭解 <script type="math/tex">E[T(n)] = 2(n+1)H_n - 2n</script></p><p>又由 $H_n = \ln n + \gamma + \mathcal{O}\left(\frac{1}{n} \right)$</p><p>故可得</p><script type="math/tex; mode=display">\begin{aligned}E[T(n)] &= 2(n+1)\left(\ln n + \gamma + \mathcal{O} \left(\frac{1}{n} \right)\right) - 2n \\&= 2n \ln n + 2(\gamma - 1)n + 2\ln n + 2\gamma + \mathcal{O}(1) + \mathcal{O}\left(\frac{1}{n}\right) \\&= \Theta \left( n \ln n \right) \\&= \Theta \left( n \lg n\right)\end{aligned}</script><p>由此我们得到了快速排序的平均时间复杂度为 $\Theta (n \lg n)$</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;随机化快速排序&quot;&gt;&lt;a href=&quot;#随机化快速排序&quot; class=&quot;headerlink&quot; title=&quot;随机化快速排序&quot;&gt;&lt;/a&gt;随机化快速排序&lt;/h2&gt;&lt;p&gt;随机化快速排序在快速排序的基础上，通过随机数选择一个数作为pivot，使得没有特定的输入数据可以使得该算法达到最坏情况。&lt;/p&gt;
&lt;p&gt;下面我们来分析其平均时间复杂度。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.me/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》笔记整理（一）</title>
    <link href="http://gonggongjohn.me/2020/10/07/csapp-01/"/>
    <id>http://gonggongjohn.me/2020/10/07/csapp-01/</id>
    <published>2020-10-07T14:31:17.000Z</published>
    <updated>2020-10-11T12:39:08.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-2：信息的表示和处理"><a href="#Chapter-2：信息的表示和处理" class="headerlink" title="Chapter 2：信息的表示和处理"></a>Chapter 2：信息的表示和处理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h4><p><strong>定义：</strong>设一个 $m$ 进制下$w$ 位的位向量表示为 <script type="math/tex">[a_{w-1}, a_{w-2}, ..., a_0]</script>，则其表示的数为 $\sum_\limits{i=0}^{w-1} a_im^i$</p><h4 id="m-进制-rightarrow-十进制"><a href="#m-进制-rightarrow-十进制" class="headerlink" title="$m$ 进制 $\rightarrow$ 十进制"></a>$m$ 进制 $\rightarrow$ 十进制</h4><blockquote><p>设一个 $w$ 位 $m$ 进制整数的位相量表示为 <script type="math/tex">\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ]</script> ，定义函数 $M2D(\vec{x}) = \sum_\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\vec{x})$</p></blockquote><a id="more"></a><p><strong>证明：</strong>由进位计数制的定义可直接得到结论</p><blockquote><p>Example:</p><p>将 $3$ 进制数 $12011$ 转为十进制数</p><p>解： 令 $\vec{x} = [1,2,0,1,1], m = 3$</p><script type="math/tex; mode=display">\begin{align}\therefore n = M2D(\vec{x}) &= 1 \cdot 3^4 + 2 \cdot 3^3 + 1 \cdot 3^1 +1 \cdot 3^0 \\ &= 81+54+3+1 \\ &= 139 \end{align}</script><p>故 <script type="math/tex">12011_3 = 139_{10}</script></p></blockquote><h4 id="十进制-rightarrow-m-进制"><a href="#十进制-rightarrow-m-进制" class="headerlink" title="十进制 $\rightarrow$ $m$ 进制"></a>十进制 $\rightarrow$ $m$ 进制</h4><blockquote><p>设一个十进制整数为 $n$，定义序列 </p><script type="math/tex; mode=display">\begin{align}&p_0 = \lfloor \frac{n}{m} \rfloor, \ r_0 = n \ \ mod \ \ m \\&p_1 = \lfloor \frac{p_0}{m}\rfloor, \ r_1 = p_0 \ \ mod \ \ m \\&... \\&p_{s-1} = \lfloor \frac{p_{s-2}}{m}\rfloor = 0, \ r_{s-1} = p_{s-2} \ \ mod \ \ m \\\end{align}</script><p>则其对应的 $m$ 进制数的位向量表示为 <script type="math/tex">\vec{x} = [r_{s-1}, r_{s-2}, ..., r_0]</script></p></blockquote><p><strong>证明：</strong>设 $n$ 在 $m$ 进制下的位相量表示为 <script type="math/tex">[r_{s-1}, r_{s-2}, ..., r_0]</script></p><p>则由定义可知，<script type="math/tex">n = r_{s-1} \cdot m^{s-1} + r_{s-2} \cdot m^{s-2} + ...+ r_0</script></p><p>故 <script type="math/tex">n = m \cdot \left( r_{s-1} \cdot m^{s-2} + r_{s-2} \cdot m^{s-3} + ... + r_1 \right) + r_0</script></p><p>故 $r_0 = n \ \ mod \ \ m$</p><p>又由</p><script type="math/tex; mode=display">\begin{align}p_0 = \lfloor \frac{n}{m} \rfloor &= r_{s-1} \cdot m^{s-2} + r_{s-2} \cdot m^{s-3} + ... + r_1 \\&= m \cdot \left( r_{s-1} \cdot m^{s-3} + r_{s-2} \cdot m^{s-4} + ... + r_2 \right) + r_1\end{align}</script><p>故 $r_1 = p_0 \ \ mod \ \ m$</p><p>以此类推，<script type="math/tex">r_{i} = p_{i-1} \ \ mod \ \ m \ (i=s-2, ..., 1)</script></p><p>故结论成立</p><blockquote><p>Example:</p><p>将十进制数 $508$ 转为八进制数</p><p>解：</p><script type="math/tex; mode=display">\begin{align}508 &= 63 * 8 + 4 \\63 &= 7 * 8 + 7 \\7 &= 0 * 8 + 7\end{align}</script><p>故 $508_{10} = 774_8$</p></blockquote><h3 id="信息的存储"><a href="#信息的存储" class="headerlink" title="信息的存储"></a>信息的存储</h3><h4 id="字长（Word-Size）"><a href="#字长（Word-Size）" class="headerlink" title="字长（Word Size）"></a>字长（Word Size）</h4><p>在计算机中，<strong>字（Word）</strong>是用来表示一次性处理数据的固定长度。字的位数称为<strong>字长（Word Size）</strong>。字长是计算机系统中的一个重要指标，字长的大小决定了<strong>虚拟地址空间的最大大小</strong>。</p><p>对于一个字长为 $w$ 的机器来说，其虚拟地址的范围为 $0$ ～ $2^w-1$，即可以存储 $2^w$ 个字节</p><blockquote><p>Example:</p><p>字长为32的机器的虚拟地址范围为 $0$ ～ $2^{32}-1$，可以存储 $2^{32}$ 个字节</p></blockquote><h4 id="小端序（Little-Endian）和大端序（Big-Endian）"><a href="#小端序（Little-Endian）和大端序（Big-Endian）" class="headerlink" title="小端序（Little Endian）和大端序（Big Endian）"></a>小端序（Little Endian）和大端序（Big Endian）</h4><p>超过一个字节的数据在计算机中有两种排列顺序：小端序（Little Endian）和大端序（Big Endian）。</p><p>小端序：将较低的有效字节放在<strong>较小</strong>的内存地址中。</p><p>大端序：将较低的有效字节放在<strong>较大</strong>的内存地址中。</p><blockquote><p>Example:</p><p>原始数据：12 34 56 78 </p><p>小端序存储：12 34 56 78</p><p>大端序存储：78 56 34 12</p></blockquote><p><strong>注：</strong>使用ASCII码存储的字符数据在任何系统上都能得到相同的结果，不受端序的影响。</p><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><h4 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h4><p>计算机中有以下四种基本位级运算：<strong>按位与（&amp;）</strong>，<strong>按位或（|）</strong>，<strong>按位非（~）</strong>，<strong>按位异或（^）</strong>，其规则与布尔代数中的规则一致。</p><blockquote><p>Example:</p><p>101100 &amp; 100110 = 100100</p><p>101100 | 100110 = 101110</p><p>~101100 = 010011</p><p>101100 ^ 100110 = 001010</p></blockquote><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>计算机中提供了以下三种逻辑运算：<strong>且（&amp;&amp;）</strong>，<strong>或（||）</strong>，<strong>非（!）</strong>，其规则与命题逻辑中的规则一致。</p><p><strong>注：</strong>C语言中的逻辑运算有<strong>提早终止（Early Termination）</strong>的机制，即当两个表达式做逻辑运算时，若前一个表达式已经能确定最终结果，则不再计算后一个表达式。</p><blockquote><p>Example:</p><p>(1+1=2) &amp; (3=3) = 1</p><p>(1-1=0) || (1=2) = 1</p><p>!(2*5=10) = 0</p><p>!0x3F = 0</p></blockquote><h4 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h4><p>计算机中提供了三种位移操作：左移（&lt;&lt;），逻辑右移（&gt;&gt;），算术右移（&gt;&gt;）</p><p>$x$ 左移 $k$ 位：将 $x$ 的最高 $k$ 位丢弃并在最低位后补充 $k$ 个零，相当于 $x \cdot 2^k$</p><p>$x$ 逻辑右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个零，相当于 $\lfloor \frac{x}{2^k} \rfloor$</p><p>算术右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个最高位值</p><h3 id="整数的存储与运算"><a href="#整数的存储与运算" class="headerlink" title="整数的存储与运算"></a>整数的存储与运算</h3><h4 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h4><p>二进制数码不表示符号信息的整数称为无符号整数，其代码的数字与常规的进位计数制规则一致。即若定义 <script type="math/tex">B2U_w(\vec{x}) = \sum_\limits{i=0}^{w-1}x_i 2^i</script>，则一个 $w$ 位的二进制位相量 $\vec{x}$ 所对应的十进制数 $n = B2U_w(\vec{x})$</p><p>由定义可知，一个 $w$ 位的二进制位相量 $\vec{x}$ 可表示的整数范围为 $0$ ～ $2^w-1$</p><h4 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h4><p>有符号整数是采用补码进行存储的整数。补码是对二进制的一种新的解读方式，其严格的定义如下：若定义 <script type="math/tex">B2T_w(\vec{x}) = -x_{w-1} 2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i</script>，则一个 $w$ 位的二进制位相量 $\vec{x}$ 所对应的十进制数 $n = B2T_w(\vec{x})$。通俗来说，补码将原本 $0$ ～ $2^w-1$ 中 $2^{w-1}$ ～ $2^{w} - 1$ 的部分重新解读为负数，从而使得其可以表示负数。从取模的角度来看， 对于一个 $0$ ～ $2^{w-1} - 1$ 中的数 $n$ 和一个 $2^{w-1}$ ～ $2^{w} - 1$ 中的数 $m$，$(n + m) \ \ mod \ \ 2^w = n - (2^w - m)$，故这样定义是合适的。且容易看出其与无符号整数间的转换关系为 </p><script type="math/tex; mode=display">U2T(x) = \left\{\begin{aligned}&x &, &0 \leq x \leq 2^{w-1} - 1 \\&x - 2^w &, &2^{w-1} \leq x \leq 2^w - 1\end{aligned}\right.</script><script type="math/tex; mode=display">T2U(x) = \left\{\begin{aligned}&x &, & 0 \leq x \leq 2^{w-1}-1 \\&x + 2^w &, & -2^{w-1} \leq x \leq -1\end{aligned}\right.</script><p><strong>证明：</strong>设二进制位向量 $\vec{x}$</p><p>当 <script type="math/tex">0 \leq B2U_w(\vec{x}) \leq 2^{w-1} - 1</script> 时</p><script type="math/tex; mode=display">x_{w-1} = 0</script><p>此时 <script type="math/tex">B2T_w(\vec{x}) = \sum_\limits{i=0}^{w-2}x_i 2^i = B2U_w(\vec{x})</script></p><p>故 <script type="math/tex">U2T_w(x) = x</script></p><p>当 <script type="math/tex">2^{w-1} \leq x \leq 2^w - 1</script> 时</p><script type="math/tex; mode=display">x_{w-1} = 1</script><p>此时 </p><script type="math/tex; mode=display">\left\{\begin{aligned}B2T_w(\vec{x}) &= -2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i \\B2U_w(\vec{x}) &= 2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i\end{aligned}\right.</script><p>故 <script type="math/tex">B2T_w(\vec{x}) = B2U_w(\vec{x}) - 2^w</script></p><p>故 <script type="math/tex">U2T_w(\vec{x}) = x - 2^w</script></p><p><script type="math/tex">T2U(x)</script>的情况同理可证</p><p><strong>注：</strong>无符号或有符号整数仅为二进制解读为十进制时的不同解读方式，由于计算机在二进制层面进行运算，故计算机在进行底层运算时并不区分这两种解读方式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Chapter-2：信息的表示和处理&quot;&gt;&lt;a href=&quot;#Chapter-2：信息的表示和处理&quot; class=&quot;headerlink&quot; title=&quot;Chapter 2：信息的表示和处理&quot;&gt;&lt;/a&gt;Chapter 2：信息的表示和处理&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;进制转换&quot;&gt;&lt;a href=&quot;#进制转换&quot; class=&quot;headerlink&quot; title=&quot;进制转换&quot;&gt;&lt;/a&gt;进制转换&lt;/h3&gt;&lt;h4 id=&quot;进位计数制&quot;&gt;&lt;a href=&quot;#进位计数制&quot; class=&quot;headerlink&quot; title=&quot;进位计数制&quot;&gt;&lt;/a&gt;进位计数制&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;设一个 $m$ 进制下$w$ 位的位向量表示为 &lt;script type=&quot;math/tex&quot;&gt;[a_{w-1}, a_{w-2}, ..., a_0]&lt;/script&gt;，则其表示的数为 $\sum_\limits{i=0}^{w-1} a_im^i$&lt;/p&gt;
&lt;h4 id=&quot;m-进制-rightarrow-十进制&quot;&gt;&lt;a href=&quot;#m-进制-rightarrow-十进制&quot; class=&quot;headerlink&quot; title=&quot;$m$ 进制 $\rightarrow$ 十进制&quot;&gt;&lt;/a&gt;$m$ 进制 $\rightarrow$ 十进制&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;设一个 $w$ 位 $m$ 进制整数的位相量表示为 &lt;script type=&quot;math/tex&quot;&gt;\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ]&lt;/script&gt; ，定义函数 $M2D(\vec{x}) = \sum_\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\vec{x})$&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="CSAPP" scheme="http://gonggongjohn.me/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>Strassen矩阵乘法</title>
    <link href="http://gonggongjohn.me/2020/09/25/algorithm/algorithm-exp2/"/>
    <id>http://gonggongjohn.me/2020/09/25/algorithm/algorithm-exp2/</id>
    <published>2020-09-25T03:45:00.000Z</published>
    <updated>2021-04-17T09:44:45.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想"><a href="#内容与设计思想" class="headerlink" title="内容与设计思想"></a>内容与设计思想</h2><ol><li><p>设计一个随机数矩阵生成器，输入参数包括 <script type="math/tex">N, s, t</script>；可随机生成一个大小为 <script type="math/tex">N \times N</script>、数值范围在 <script type="math/tex">[s, t]</script> 之间的矩阵。</p></li><li><p>编程实现普通的矩阵乘法；</p></li><li><p>编程实现<strong>Strassen’s Algorithm</strong>；</p></li><li><p>在不同数据规模情况下（数据规模 <script type="math/tex">N=2^4, 2^8, 2^9, 2^{10}, 2^{11}</script>）下，两种算法的运行时间各是多少；</p></li><li><p>修改<strong>Strassen’s Algorithm</strong>，使之适应矩阵规模 <script type="math/tex">N</script> 不是 <script type="math/tex">2</script> 的幂的情况；</p></li><li><p>改进后的算法与<strong>2</strong>中的算法在相同数据规模下进行比较。</p></li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="矩阵生成器"><a href="#矩阵生成器" class="headerlink" title="矩阵生成器"></a>矩阵生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n, s, t;  </span><br><span class="line">    srand(time(<span class="number">0</span>));  </span><br><span class="line">    <span class="function">ofstream <span class="title">fout1</span><span class="params">(<span class="string">&quot;data1.txt&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">ofstream <span class="title">fout2</span><span class="params">(<span class="string">&quot;data2.txt&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;t;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;  </span><br><span class="line">            fout1 &lt;&lt; s + rand() % (t - s)&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">            fout2 &lt;&lt; s + rand() % (t - s)&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        fout1&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        fout2&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    fout1.close();  </span><br><span class="line">    fout2.close();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="朴素矩阵乘法"><a href="#朴素矩阵乘法" class="headerlink" title="朴素矩阵乘法"></a>朴素矩阵乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">int</span> m1[<span class="number">2048</span>][<span class="number">2048</span>], m2[<span class="number">2048</span>][<span class="number">2048</span>], tm1[<span class="number">2048</span> * <span class="number">2048</span>], tm2[<span class="number">2048</span> * <span class="number">2048</span>];  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> cnt, n, tsum;  </span><br><span class="line">    <span class="function">ifstream <span class="title">fin1</span><span class="params">(<span class="string">&quot;data1.txt&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="function">ifstream <span class="title">fin2</span><span class="params">(<span class="string">&quot;data2.txt&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">while</span> (!fin1.eof())&#123;  </span><br><span class="line">        fin1&gt;&gt;tm1[cnt];  </span><br><span class="line">        fin2&gt;&gt;tm2[cnt];  </span><br><span class="line">        cnt++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cnt--;  </span><br><span class="line">    n = <span class="built_in">sqrt</span>(cnt);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;  </span><br><span class="line">            m1[i][j] = tm1[i * n + j];  </span><br><span class="line">            m2[i][j] = tm2[i * n + j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;  </span><br><span class="line">            tsum = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;  </span><br><span class="line">                tsum += m1[i][k] * m2[k][j];  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;tsum&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    fin1.close();  </span><br><span class="line">    fin2.close();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> row, column;</span><br><span class="line"><span class="keyword">int</span>** m;</span><br><span class="line"></span><br><span class="line">Matrix(<span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">row = r;</span><br><span class="line">column = c;</span><br><span class="line">m = (<span class="keyword">int</span>**) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">m[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix(<span class="keyword">const</span> Matrix&amp; mat) &#123;</span><br><span class="line">row = mat.row;</span><br><span class="line">column = mat.column;</span><br><span class="line">m = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * mat.row);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.row; i++)</span><br><span class="line">m[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * mat.column);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">m[i][j] = mat.m[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Matrix&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Matrix&amp; mat) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;mat) &#123;</span><br><span class="line">row = mat.row;</span><br><span class="line">column = mat.column;</span><br><span class="line">m = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * mat.row);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.row; i++)</span><br><span class="line">m[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * mat.column);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">m[i][j] = mat.m[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Matrix() &#123;</span><br><span class="line"><span class="keyword">if</span> (m != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] m[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tm1[<span class="number">2048</span> * <span class="number">2048</span>], tm2[<span class="number">2048</span> * <span class="number">2048</span>], cntp;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">matAdd</span><span class="params">(Matrix* matA, Matrix* matB)</span> </span>&#123;</span><br><span class="line">Matrix matR = Matrix((*matA).row, (*matA).column);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (*matA).row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (*matA).column; j++) &#123;</span><br><span class="line">matR.m[i][j] = (*matA).m[i][j] + (*matB).m[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matSub</span><span class="params">(Matrix* matA, Matrix* matB)</span> </span>&#123;</span><br><span class="line">Matrix matR = Matrix((*matA).row, (*matA).column);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (*matA).row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (*matA).column; j++) &#123;</span><br><span class="line">matR.m[i][j] = (*matA).m[i][j] - (*matB).m[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matSplit</span><span class="params">(Matrix mat, <span class="keyword">int</span> rowStart, <span class="keyword">int</span> columnStart, <span class="keyword">int</span> rowEnd, <span class="keyword">int</span> columnEnd)</span> </span>&#123;</span><br><span class="line">Matrix matR = Matrix(rowEnd - rowStart + <span class="number">1</span>, columnEnd - columnStart + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowEnd - rowStart; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= columnEnd - columnStart; j++) &#123;</span><br><span class="line">matR.m[i][j] = mat.m[rowStart + i][columnStart + j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matCombine</span><span class="params">(Matrix mat1, Matrix mat2, Matrix mat3, Matrix mat4)</span> </span>&#123;</span><br><span class="line">Matrix matR = Matrix(mat1.row + mat3.row, mat1.column + mat2.column);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat1.row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat1.column; j++)</span><br><span class="line">matR.m[i][j] = mat1.m[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat2.row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat2.column; j++)</span><br><span class="line">matR.m[i][mat1.column + j] = mat2.m[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat3.row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat3.column; j++)</span><br><span class="line">matR.m[mat1.row + i][j] = mat3.m[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat4.row; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat4.column; j++)</span><br><span class="line">matR.m[mat1.row + i][mat1.column + j] = mat4.m[i][j];</span><br><span class="line"><span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matProduct</span><span class="params">(Matrix* matA, Matrix* matB)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((*matA).row == <span class="number">1</span> &amp;&amp; (*matA).column == <span class="number">1</span> &amp;&amp; (*matB).row == <span class="number">1</span> &amp;&amp; (*matB).column == <span class="number">1</span>) &#123;</span><br><span class="line">Matrix matR = Matrix(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">matR.m[<span class="number">0</span>][<span class="number">0</span>] = (*matA).m[<span class="number">0</span>][<span class="number">0</span>] * (*matB).m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> midR = (*matA).row / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> midC = (*matA).column / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">Matrix a11 = matSplit((*matA), <span class="number">0</span>, <span class="number">0</span>, midR, midC);</span><br><span class="line">Matrix a12 = matSplit((*matA), <span class="number">0</span>, midC + <span class="number">1</span>, midR, (*matA).column - <span class="number">1</span>);</span><br><span class="line">Matrix a21 = matSplit((*matA), midR + <span class="number">1</span>, <span class="number">0</span>, (*matA).row - <span class="number">1</span>, midC);</span><br><span class="line">Matrix a22 = matSplit((*matA), midR + <span class="number">1</span>, midC + <span class="number">1</span>, (*matA).row - <span class="number">1</span>, (*matA).column - <span class="number">1</span>);</span><br><span class="line">Matrix b11 = matSplit((*matB), <span class="number">0</span>, <span class="number">0</span>, midR, midC);</span><br><span class="line">Matrix b12 = matSplit((*matB), <span class="number">0</span>, midC + <span class="number">1</span>, midR, (*matA).column - <span class="number">1</span>);</span><br><span class="line">Matrix b21 = matSplit((*matB), midR + <span class="number">1</span>, <span class="number">0</span>, (*matA).row - <span class="number">1</span>, midC);</span><br><span class="line">Matrix b22 = matSplit((*matB), midR + <span class="number">1</span>, midC + <span class="number">1</span>, (*matA).row - <span class="number">1</span>, (*matA).column - <span class="number">1</span>);</span><br><span class="line">Matrix tmp1 = matAdd(&amp;a11, &amp;a22);</span><br><span class="line">Matrix tmp2 = matAdd(&amp;b11, &amp;b22);</span><br><span class="line">Matrix tmp3 = matAdd(&amp;a21, &amp;a22);</span><br><span class="line">Matrix tmp4 = matSub(&amp;b12, &amp;b22);</span><br><span class="line">Matrix tmp5 = matSub(&amp;b21, &amp;b11);</span><br><span class="line">Matrix tmp6 = matAdd(&amp;a11, &amp;a12);</span><br><span class="line">Matrix tmp7 = matSub(&amp;a21, &amp;a11);</span><br><span class="line">Matrix tmp8 = matAdd(&amp;b11, &amp;b12);</span><br><span class="line">Matrix tmp9 = matSub(&amp;a12, &amp;a22);</span><br><span class="line">Matrix tmp10 = matAdd(&amp;b21, &amp;b22);</span><br><span class="line">Matrix m1 = matProduct(&amp;tmp1, &amp;tmp2);</span><br><span class="line">Matrix m2 = matProduct(&amp;tmp3, &amp;b11);</span><br><span class="line">Matrix m3 = matProduct(&amp;a11, &amp;tmp4);</span><br><span class="line">Matrix m4 = matProduct(&amp;a22, &amp;tmp5);</span><br><span class="line">Matrix m5 = matProduct(&amp;tmp6, &amp;b22);</span><br><span class="line">Matrix m6 = matProduct(&amp;tmp7, &amp;tmp8);</span><br><span class="line">Matrix m7 = matProduct(&amp;tmp9, &amp;tmp10);</span><br><span class="line">Matrix mtmp1 = matAdd(&amp;m1, &amp;m4);</span><br><span class="line">Matrix mtmp2 = matSub(&amp;mtmp1, &amp;m5);</span><br><span class="line">Matrix mtmp3 = matSub(&amp;m1, &amp;m2);</span><br><span class="line">Matrix mtmp4 = matAdd(&amp;mtmp3, &amp;m3);</span><br><span class="line">Matrix c11 = matAdd(&amp;mtmp2, &amp;m7);</span><br><span class="line">Matrix c12 = matAdd(&amp;m3, &amp;m5);</span><br><span class="line">Matrix c21 = matAdd(&amp;m2, &amp;m4);</span><br><span class="line">Matrix c22 = matAdd(&amp;mtmp4, &amp;m6);</span><br><span class="line"><span class="comment">//cntp++;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; cntp &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> matCombine(c11, c12, c21, c22);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, n;</span><br><span class="line"><span class="keyword">clock_t</span> start, stop;</span><br><span class="line"><span class="function">ifstream <span class="title">fin1</span><span class="params">(<span class="string">&quot;data1.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ifstream <span class="title">fin2</span><span class="params">(<span class="string">&quot;data2.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (!fin1.eof() &amp;&amp; !fin2.eof()) &#123;</span><br><span class="line">fin1 &gt;&gt; tm1[cnt];</span><br><span class="line">fin2 &gt;&gt; tm2[cnt];</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">cnt--;</span><br><span class="line">n = <span class="built_in">sqrt</span>(cnt);</span><br><span class="line">Matrix m1 = Matrix(n, n);</span><br><span class="line">Matrix m2 = Matrix(n, n);</span><br><span class="line">Matrix mr = Matrix(n, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">m1.m[i][j] = tm1[i * n + j];</span><br><span class="line">m2.m[i][j] = tm2[i * n + j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cntp = <span class="number">0</span>;</span><br><span class="line">start = clock();</span><br><span class="line">mr = matProduct(&amp;m1, &amp;m2);</span><br><span class="line">stop = clock();</span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; mr.m[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Time Cost: &quot;</span>&lt;&lt;(<span class="keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="string">&quot;s&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">fin1.close();</span><br><span class="line">fin2.close();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展的Strassen矩阵乘法"><a href="#扩展的Strassen矩阵乘法" class="headerlink" title="扩展的Strassen矩阵乘法"></a>扩展的Strassen矩阵乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> row, column;</span><br><span class="line">    <span class="keyword">int</span>** m;</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        row = r;</span><br><span class="line">        column = c;</span><br><span class="line">        m = (<span class="keyword">int</span>**) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">            m[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">const</span> Matrix&amp; mat) &#123;</span><br><span class="line">        row = mat.row;</span><br><span class="line">        column = mat.column;</span><br><span class="line">        m = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * mat.row);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.row; i++)</span><br><span class="line">            m[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * mat.column);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">                m[i][j] = mat.m[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Matrix&amp; mat) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;mat) &#123;</span><br><span class="line">            row = mat.row;</span><br><span class="line">            column = mat.column;</span><br><span class="line">            m = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * mat.row);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.row; i++)</span><br><span class="line">                m[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * mat.column);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">                    m[i][j] = mat.m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Matrix() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">                <span class="keyword">delete</span>[] m[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tm1[<span class="number">2048</span> * <span class="number">2048</span>], tm2[<span class="number">2048</span> * <span class="number">2048</span>], cntp;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">matExtend</span><span class="params">(Matrix* mat)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, exn;</span><br><span class="line">    <span class="keyword">int</span> n = (*mat).row;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        pos++;</span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(((*mat).row &amp; ((*mat).row - <span class="number">1</span>)) == <span class="number">0</span>) exn = (*mat).row;</span><br><span class="line">    <span class="keyword">else</span> exn = <span class="number">1</span>&lt;&lt;pos;</span><br><span class="line">    Matrix matR = Matrix(exn, exn);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (*mat).row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (*mat).column; j++)</span><br><span class="line">            matR.m[i][j] = (*mat).m[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (*mat).row; i &lt; exn; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = (*mat).column; j &lt; exn; j++)</span><br><span class="line">            matR.m[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matAdd</span><span class="params">(Matrix* matA, Matrix* matB)</span> </span>&#123;</span><br><span class="line">    Matrix matR = Matrix((*matA).row, (*matA).column);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (*matA).row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (*matA).column; j++) &#123;</span><br><span class="line">            matR.m[i][j] = (*matA).m[i][j] + (*matB).m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matSub</span><span class="params">(Matrix* matA, Matrix* matB)</span> </span>&#123;</span><br><span class="line">    Matrix matR = Matrix((*matA).row, (*matA).column);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (*matA).row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (*matA).column; j++) &#123;</span><br><span class="line">            matR.m[i][j] = (*matA).m[i][j] - (*matB).m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matSplit</span><span class="params">(Matrix mat, <span class="keyword">int</span> rowStart, <span class="keyword">int</span> columnStart, <span class="keyword">int</span> rowEnd, <span class="keyword">int</span> columnEnd)</span> </span>&#123;</span><br><span class="line">    Matrix matR = Matrix(rowEnd - rowStart + <span class="number">1</span>, columnEnd - columnStart + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowEnd - rowStart; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= columnEnd - columnStart; j++) &#123;</span><br><span class="line">            matR.m[i][j] = mat.m[rowStart + i][columnStart + j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matCombine</span><span class="params">(Matrix mat1, Matrix mat2, Matrix mat3, Matrix mat4)</span> </span>&#123;</span><br><span class="line">    Matrix matR = Matrix(mat1.row + mat3.row, mat1.column + mat2.column);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat1.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat1.column; j++)</span><br><span class="line">            matR.m[i][j] = mat1.m[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat2.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat2.column; j++)</span><br><span class="line">            matR.m[i][mat1.column + j] = mat2.m[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat3.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat3.column; j++)</span><br><span class="line">            matR.m[mat1.row + i][j] = mat3.m[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat4.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat4.column; j++)</span><br><span class="line">            matR.m[mat1.row + i][mat1.column + j] = mat4.m[i][j];</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matProduct</span><span class="params">(Matrix* matA, Matrix* matB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*matA).row == <span class="number">1</span> &amp;&amp; (*matA).column == <span class="number">1</span> &amp;&amp; (*matB).row == <span class="number">1</span> &amp;&amp; (*matB).column == <span class="number">1</span>) &#123;</span><br><span class="line">        Matrix matR = Matrix(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        matR.m[<span class="number">0</span>][<span class="number">0</span>] = (*matA).m[<span class="number">0</span>][<span class="number">0</span>] * (*matB).m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> matR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> midR = (*matA).row / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> midC = (*matA).column / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    Matrix a11 = matSplit((*matA), <span class="number">0</span>, <span class="number">0</span>, midR, midC);</span><br><span class="line">    Matrix a12 = matSplit((*matA), <span class="number">0</span>, midC + <span class="number">1</span>, midR, (*matA).column - <span class="number">1</span>);</span><br><span class="line">    Matrix a21 = matSplit((*matA), midR + <span class="number">1</span>, <span class="number">0</span>, (*matA).row - <span class="number">1</span>, midC);</span><br><span class="line">    Matrix a22 = matSplit((*matA), midR + <span class="number">1</span>, midC + <span class="number">1</span>, (*matA).row - <span class="number">1</span>, (*matA).column - <span class="number">1</span>);</span><br><span class="line">    Matrix b11 = matSplit((*matB), <span class="number">0</span>, <span class="number">0</span>, midR, midC);</span><br><span class="line">    Matrix b12 = matSplit((*matB), <span class="number">0</span>, midC + <span class="number">1</span>, midR, (*matA).column - <span class="number">1</span>);</span><br><span class="line">    Matrix b21 = matSplit((*matB), midR + <span class="number">1</span>, <span class="number">0</span>, (*matA).row - <span class="number">1</span>, midC);</span><br><span class="line">    Matrix b22 = matSplit((*matB), midR + <span class="number">1</span>, midC + <span class="number">1</span>, (*matA).row - <span class="number">1</span>, (*matA).column - <span class="number">1</span>);</span><br><span class="line">    Matrix tmp1 = matAdd(&amp;a11, &amp;a22);</span><br><span class="line">    Matrix tmp2 = matAdd(&amp;b11, &amp;b22);</span><br><span class="line">    Matrix tmp3 = matAdd(&amp;a21, &amp;a22);</span><br><span class="line">    Matrix tmp4 = matSub(&amp;b12, &amp;b22);</span><br><span class="line">    Matrix tmp5 = matSub(&amp;b21, &amp;b11);</span><br><span class="line">    Matrix tmp6 = matAdd(&amp;a11, &amp;a12);</span><br><span class="line">    Matrix tmp7 = matSub(&amp;a21, &amp;a11);</span><br><span class="line">    Matrix tmp8 = matAdd(&amp;b11, &amp;b12);</span><br><span class="line">    Matrix tmp9 = matSub(&amp;a12, &amp;a22);</span><br><span class="line">    Matrix tmp10 = matAdd(&amp;b21, &amp;b22);</span><br><span class="line">    Matrix m1 = matProduct(&amp;tmp1, &amp;tmp2);</span><br><span class="line">    Matrix m2 = matProduct(&amp;tmp3, &amp;b11);</span><br><span class="line">    Matrix m3 = matProduct(&amp;a11, &amp;tmp4);</span><br><span class="line">    Matrix m4 = matProduct(&amp;a22, &amp;tmp5);</span><br><span class="line">    Matrix m5 = matProduct(&amp;tmp6, &amp;b22);</span><br><span class="line">    Matrix m6 = matProduct(&amp;tmp7, &amp;tmp8);</span><br><span class="line">    Matrix m7 = matProduct(&amp;tmp9, &amp;tmp10);</span><br><span class="line">    Matrix mtmp1 = matAdd(&amp;m1, &amp;m4);</span><br><span class="line">    Matrix mtmp2 = matSub(&amp;mtmp1, &amp;m5);</span><br><span class="line">    Matrix mtmp3 = matSub(&amp;m1, &amp;m2);</span><br><span class="line">    Matrix mtmp4 = matAdd(&amp;mtmp3, &amp;m3);</span><br><span class="line">    Matrix c11 = matAdd(&amp;mtmp2, &amp;m7);</span><br><span class="line">    Matrix c12 = matAdd(&amp;m3, &amp;m5);</span><br><span class="line">    Matrix c21 = matAdd(&amp;m2, &amp;m4);</span><br><span class="line">    Matrix c22 = matAdd(&amp;mtmp4, &amp;m6);</span><br><span class="line">    <span class="comment">//cntp++;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; cntp &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> matCombine(c11, c12, c21, c22);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, n;</span><br><span class="line">    <span class="keyword">clock_t</span> start, stop;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin1</span><span class="params">(<span class="string">&quot;data1.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin2</span><span class="params">(<span class="string">&quot;data2.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!fin1.eof() &amp;&amp; !fin2.eof()) &#123;</span><br><span class="line">        fin1 &gt;&gt; tm1[cnt];</span><br><span class="line">        fin2 &gt;&gt; tm2[cnt];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt--;</span><br><span class="line">    n = <span class="built_in">sqrt</span>(cnt);</span><br><span class="line">    Matrix m1 = Matrix(n, n);</span><br><span class="line">    Matrix m2 = Matrix(n, n);</span><br><span class="line">    Matrix mr = Matrix(n, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            m1.m[i][j] = tm1[i * n + j];</span><br><span class="line">            m2.m[i][j] = tm2[i * n + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cntp = <span class="number">0</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    Matrix m1e = matExtend(&amp;m1);</span><br><span class="line">    Matrix m2e = matExtend(&amp;m2);</span><br><span class="line">    mr = matProduct(&amp;m1e, &amp;m2e);</span><br><span class="line">    stop = clock();</span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; mr.m[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Time Cost: &quot;</span>&lt;&lt;(<span class="keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="string">&quot;s&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fin1.close();</span><br><span class="line">    fin2.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Strassen矩阵乘法（剪枝优化）"><a href="#Strassen矩阵乘法（剪枝优化）" class="headerlink" title="Strassen矩阵乘法（剪枝优化）"></a>Strassen矩阵乘法（剪枝优化）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> row, column;</span><br><span class="line">    <span class="keyword">int</span>** m;</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        row = r;</span><br><span class="line">        column = c;</span><br><span class="line">        m = (<span class="keyword">int</span>**) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">            m[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">const</span> Matrix&amp; mat) &#123;</span><br><span class="line">        row = mat.row;</span><br><span class="line">        column = mat.column;</span><br><span class="line">        m = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * mat.row);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.row; i++)</span><br><span class="line">            m[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * mat.column);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">                m[i][j] = mat.m[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Matrix&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Matrix&amp; mat) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;mat) &#123;</span><br><span class="line">            row = mat.row;</span><br><span class="line">            column = mat.column;</span><br><span class="line">            m = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * mat.row);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat.row; i++)</span><br><span class="line">                m[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * mat.column);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">                    m[i][j] = mat.m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Matrix() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">                <span class="keyword">delete</span>[] m[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span>[] m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tm1[<span class="number">2048</span> * <span class="number">2048</span>], tm2[<span class="number">2048</span> * <span class="number">2048</span>], cntp;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">matAdd</span><span class="params">(Matrix* matA, Matrix* matB)</span> </span>&#123;</span><br><span class="line">    Matrix matR = Matrix((*matA).row, (*matA).column);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (*matA).row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (*matA).column; j++) &#123;</span><br><span class="line">            matR.m[i][j] = (*matA).m[i][j] + (*matB).m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matSub</span><span class="params">(Matrix* matA, Matrix* matB)</span> </span>&#123;</span><br><span class="line">    Matrix matR = Matrix((*matA).row, (*matA).column);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (*matA).row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (*matA).column; j++) &#123;</span><br><span class="line">            matR.m[i][j] = (*matA).m[i][j] - (*matB).m[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matSplit</span><span class="params">(Matrix mat, <span class="keyword">int</span> rowStart, <span class="keyword">int</span> columnStart, <span class="keyword">int</span> rowEnd, <span class="keyword">int</span> columnEnd)</span> </span>&#123;</span><br><span class="line">    Matrix matR = Matrix(rowEnd - rowStart + <span class="number">1</span>, columnEnd - columnStart + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowEnd - rowStart; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= columnEnd - columnStart; j++) &#123;</span><br><span class="line">            matR.m[i][j] = mat.m[rowStart + i][columnStart + j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matCombine</span><span class="params">(Matrix mat1, Matrix mat2, Matrix mat3, Matrix mat4)</span> </span>&#123;</span><br><span class="line">    Matrix matR = Matrix(mat1.row + mat3.row, mat1.column + mat2.column);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat1.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat1.column; j++)</span><br><span class="line">            matR.m[i][j] = mat1.m[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat2.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat2.column; j++)</span><br><span class="line">            matR.m[i][mat1.column + j] = mat2.m[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat3.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat3.column; j++)</span><br><span class="line">            matR.m[mat1.row + i][j] = mat3.m[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mat4.row; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mat4.column; j++)</span><br><span class="line">            matR.m[mat1.row + i][mat1.column + j] = mat4.m[i][j];</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Matrix <span class="title">matProduct</span><span class="params">(Matrix* matA, Matrix* matB, <span class="keyword">int</span> leafcut)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((*matA).row &lt;= leafcut &amp;&amp; (*matA).column &lt;= leafcut &amp;&amp; (*matB).row &lt;= leafcut &amp;&amp; (*matB).column &lt;= leafcut) &#123;</span><br><span class="line">        Matrix matR = Matrix(leafcut, leafcut);</span><br><span class="line">        <span class="keyword">int</span> tsum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leafcut; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; leafcut; j++) &#123;</span><br><span class="line">                tsum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; leafcut; k++) &#123;</span><br><span class="line">                    matR.m[i][j] += (*matA).m[i][k] * (*matB).m[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> midR = (*matA).row / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> midC = (*matA).column / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    Matrix a11 = matSplit((*matA), <span class="number">0</span>, <span class="number">0</span>, midR, midC);</span><br><span class="line">    Matrix a12 = matSplit((*matA), <span class="number">0</span>, midC + <span class="number">1</span>, midR, (*matA).column - <span class="number">1</span>);</span><br><span class="line">    Matrix a21 = matSplit((*matA), midR + <span class="number">1</span>, <span class="number">0</span>, (*matA).row - <span class="number">1</span>, midC);</span><br><span class="line">    Matrix a22 = matSplit((*matA), midR + <span class="number">1</span>, midC + <span class="number">1</span>, (*matA).row - <span class="number">1</span>, (*matA).column - <span class="number">1</span>);</span><br><span class="line">    Matrix b11 = matSplit((*matB), <span class="number">0</span>, <span class="number">0</span>, midR, midC);</span><br><span class="line">    Matrix b12 = matSplit((*matB), <span class="number">0</span>, midC + <span class="number">1</span>, midR, (*matA).column - <span class="number">1</span>);</span><br><span class="line">    Matrix b21 = matSplit((*matB), midR + <span class="number">1</span>, <span class="number">0</span>, (*matA).row - <span class="number">1</span>, midC);</span><br><span class="line">    Matrix b22 = matSplit((*matB), midR + <span class="number">1</span>, midC + <span class="number">1</span>, (*matA).row - <span class="number">1</span>, (*matA).column - <span class="number">1</span>);</span><br><span class="line">    Matrix tmp1 = matAdd(&amp;a11, &amp;a22);</span><br><span class="line">    Matrix tmp2 = matAdd(&amp;b11, &amp;b22);</span><br><span class="line">    Matrix tmp3 = matAdd(&amp;a21, &amp;a22);</span><br><span class="line">    Matrix tmp4 = matSub(&amp;b12, &amp;b22);</span><br><span class="line">    Matrix tmp5 = matSub(&amp;b21, &amp;b11);</span><br><span class="line">    Matrix tmp6 = matAdd(&amp;a11, &amp;a12);</span><br><span class="line">    Matrix tmp7 = matSub(&amp;a21, &amp;a11);</span><br><span class="line">    Matrix tmp8 = matAdd(&amp;b11, &amp;b12);</span><br><span class="line">    Matrix tmp9 = matSub(&amp;a12, &amp;a22);</span><br><span class="line">    Matrix tmp10 = matAdd(&amp;b21, &amp;b22);</span><br><span class="line">    Matrix m1 = matProduct(&amp;tmp1, &amp;tmp2, leafcut);</span><br><span class="line">    Matrix m2 = matProduct(&amp;tmp3, &amp;b11, leafcut);</span><br><span class="line">    Matrix m3 = matProduct(&amp;a11, &amp;tmp4, leafcut);</span><br><span class="line">    Matrix m4 = matProduct(&amp;a22, &amp;tmp5, leafcut);</span><br><span class="line">    Matrix m5 = matProduct(&amp;tmp6, &amp;b22, leafcut);</span><br><span class="line">    Matrix m6 = matProduct(&amp;tmp7, &amp;tmp8, leafcut);</span><br><span class="line">    Matrix m7 = matProduct(&amp;tmp9, &amp;tmp10, leafcut);</span><br><span class="line">    Matrix mtmp1 = matAdd(&amp;m1, &amp;m4);</span><br><span class="line">    Matrix mtmp2 = matSub(&amp;mtmp1, &amp;m5);</span><br><span class="line">    Matrix mtmp3 = matSub(&amp;m1, &amp;m2);</span><br><span class="line">    Matrix mtmp4 = matAdd(&amp;mtmp3, &amp;m3);</span><br><span class="line">    Matrix c11 = matAdd(&amp;mtmp2, &amp;m7);</span><br><span class="line">    Matrix c12 = matAdd(&amp;m3, &amp;m5);</span><br><span class="line">    Matrix c21 = matAdd(&amp;m2, &amp;m4);</span><br><span class="line">    Matrix c22 = matAdd(&amp;mtmp4, &amp;m6);</span><br><span class="line">    <span class="comment">//cntp++;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; cntp &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> matCombine(c11, c12, c21, c22);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, n;</span><br><span class="line">    <span class="keyword">clock_t</span> start, stop;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin1</span><span class="params">(<span class="string">&quot;data1.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin2</span><span class="params">(<span class="string">&quot;data2.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!fin1.eof() &amp;&amp; !fin2.eof()) &#123;</span><br><span class="line">        fin1 &gt;&gt; tm1[cnt];</span><br><span class="line">        fin2 &gt;&gt; tm2[cnt];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt--;</span><br><span class="line">    n = <span class="built_in">sqrt</span>(cnt);</span><br><span class="line">    Matrix m1 = Matrix(n, n);</span><br><span class="line">    Matrix m2 = Matrix(n, n);</span><br><span class="line">    Matrix mr = Matrix(n, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            m1.m[i][j] = tm1[i * n + j];</span><br><span class="line">            m2.m[i][j] = tm2[i * n + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cntp = <span class="number">0</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    mr = matProduct(&amp;m1, &amp;m2, <span class="number">16</span>);</span><br><span class="line">    stop = clock();</span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">// for (int j = 0; j &lt; n; j++) &#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; mr.m[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Time Cost: &quot;</span>&lt;&lt;(<span class="keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="string">&quot;s&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fin1.close();</span><br><span class="line">    fin2.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行效率"><a href="#运行效率" class="headerlink" title="运行效率"></a>运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><p><img src="1.png" alt="1"></p><p><img src="2.png" alt="2"></p><p><img src="3.png" alt="3"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从理论上看，Strassen算法的时间复杂度为<script type="math/tex">\mathcal{O}(n^{\lg 7})</script>，相比朴素矩阵乘法 <script type="math/tex">\mathcal{O}(n^3)</script> 的复杂度略快，但由于其在规模较小时的常数很大，相比朴素矩阵乘法优势并不明显。此外，由于使用Strassen算法需要动态申请大量的临时空间，而申请、访问和删除这些辅助空间的代价远大于运算本身的代价（使用Visual Studio性能检测工具分析程序可以发现仅创建和删除这些临时空间的耗时就占了整个程序运行时间的70%左右），因此从实际测试结果来看Strassen算法甚至还远慢于朴素矩阵乘法。</p><p><img src="analysis-vscode.png" alt="analysis-vscode"></p><p>为了避免常数和内存交互时间对测试结果造成影响，我们可以对原算法进行适当的剪枝（Leaf-Cut）优化，即当矩阵规模缩小到一个固定值后改用朴素矩阵乘法继续处理该矩阵。经实测表明，当剪枝范围为16～64之间时，性能瓶颈得到了极大的缓解，且随着数据规模的增大，改进后的算法相比纯朴素矩阵乘法逐渐出现显著的性能优势，与理论计算值基本吻合。<br>对于矩阵大小不为2的幂次时，可以先将原矩阵扩展至最邻近的2的幂次大小（扩展部分全部用0补齐），随后即可使用Strassen算法进行分治计算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内容与设计思想&quot;&gt;&lt;a href=&quot;#内容与设计思想&quot; class=&quot;headerlink&quot; title=&quot;内容与设计思想&quot;&gt;&lt;/a&gt;内容与设计思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设计一个随机数矩阵生成器，输入参数包括 &lt;script type=&quot;math/te</summary>
      
    
    
    
    <category term="算法" scheme="http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.me/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>GDB使用指南</title>
    <link href="http://gonggongjohn.me/2020/09/19/gdb-guide/"/>
    <id>http://gonggongjohn.me/2020/09/19/gdb-guide/</id>
    <published>2020-09-19T04:24:40.000Z</published>
    <updated>2020-09-28T08:06:30.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB使用指南"><a href="#GDB使用指南" class="headerlink" title="GDB使用指南"></a>GDB使用指南</h1><p>GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。</p><p>GDB官网：<a href="http://www.gnu.org/software/gdb/">GDB: The GNU Project Debugger</a></p><a id="more"></a><h2 id="GDB和LLDB"><a href="#GDB和LLDB" class="headerlink" title="GDB和LLDB"></a>GDB和LLDB</h2><p>LLDB是一款开源的具有REPL（Read-Evaluation-Print-Loop）特征的调试工具，相比GDB在部分场景下更加先进和高效。Xcode自4.3版本后默认内置了LLDB，因此<strong>macOS用户可以直接使用LLDB对程序进行调试</strong>。（当然macOS同样也可以安装GDB调试工具）</p><p>GDB与LLDB命令对照表：<a href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map</a></p><h2 id="WINDOWS下安装GCC和GDB"><a href="#WINDOWS下安装GCC和GDB" class="headerlink" title="WINDOWS下安装GCC和GDB"></a>WINDOWS下安装GCC和GDB</h2><p>MinGW（Minimalist GNU For Windows）是Windows下的一个小型GNU工具集。新版MinGW中集成了GCC和GDB的相关工具，因此只需安装MinGW即可使用GCC和GDB。</p><h3 id="下载MinGW及GCC包"><a href="#下载MinGW及GCC包" class="headerlink" title="下载MinGW及GCC包"></a>下载MinGW及GCC包</h3><p>首先前往MinGW官方网站：<a href="http://www.mingw.org">MinGW</a> 并在Download界面下载MinGW管理工具。</p><p><img src="mingw-1.png" alt="mingw-2"></p><p><img src="mingw-2.png" alt="mingw-2"></p><p>安装MinGW管理工具并打开。</p><p><img src="mingw-3.JPG" alt="mingw-3"></p><p>选择所需的工具集，点击左上角的<strong>Installation-&gt;Apply Changes</strong>即可安装。（由于受国内网络环境影响，可能会出现下载失败的情况，可以多尝试几次或使用其他网络连接方式下载）。若使用C/C++进行开发，通常仅需安装<strong>mingw32-base-bin</strong>及<strong>mingw32-gcc-g++-bin</strong>即可。</p><h3 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h3><p>安装完成后，我们需要配置系统环境变量使得其可以在CMD中执行。</p><p><strong>右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</strong>，在系统变量框中找到<strong>Path</strong>变量，选择编辑，在最后新增一行填入<strong>你的MinGW安装路径\bin</strong>，确定退出。</p><p><img src="mingw-4.JPG" alt="mingw-4"></p><p>打开CMD，输入<strong>gcc -v</strong>及<strong>gdb -v</strong>，若显示相关版本信息，表明环境变量配置成功。</p><p><img src="mingw-5.JPG" alt="mingw-5"></p><h2 id="在其他IDE中调用GDB"><a href="#在其他IDE中调用GDB" class="headerlink" title="在其他IDE中调用GDB"></a>在其他IDE中调用GDB</h2><h3 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h3><p>CLion本身已经集成了十分完善的可视化调试工具，但如果想在CLion中使用GDB或LLDB调试程序同样十分方便。</p><p>使用通常的方法在需要的地方打上断点启动调试，在下方的Debug窗口中就可以看到GDB/LLDB窗口，在其中输入命令即可。</p><p><img src="clion-1.png" alt="clion-1"></p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>VSCode本身并不自带GCC和GDB的相关功能，因此<strong>使用VSCode进行调试同样需要额外安装GDB/LLDB调试工具</strong>。不过，VSCode提供了一个可视化的C/C++调试插件，相比命令行调试会直观很多。该插件可直接在插件商店里搜索并安装。</p><p><img src="vscode-1.png" alt="vscode-1"></p><p>和其他大型IDE类似，VSCode将一个目录视为一个项目，因此在创建项目时，你需要指定一个空的文件夹来存放项目文件<strong>（这也是一些人装了辅助插件却被提示要手动配置调试文件的一大重要原因）</strong>。在第一次运行程序时，选择<strong>Run-&gt;Start Debugging</strong>，在弹出的选项框中选择一个要使用的调试环境及编译环境，VSCode就会自动在当前的项目目录下创建相应的配置文件。（当然也可以手动指定配置文件，具体配置方法可参考VSCode官方文档）</p><p><img src="vscode-2.png" alt="vscode-2"></p><p><img src="vscode-3.png" alt="vscode-3"></p><p>随后即可在调试界面中看到相关的调试信息。你也可以在下方的Debug Console中输入相关的GDB/LLDB命令来进行进一步的调试。</p><p><img src="vscode-4.png" alt="vscode-4"></p><h2 id="GDB的基本使用"><a href="#GDB的基本使用" class="headerlink" title="GDB的基本使用"></a>GDB的基本使用</h2><h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><p>若要使用GDB来调试程序，需要在使用GCC编译源文件的时候打开-g选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g [源文件名] -o [目标文件名]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g test.c -o test</span><br></pre></td></tr></table></figure></blockquote><p><strong>若不打开调试选项，则在调试时无法添加断点。</strong></p><p>使用gdb打开生成的可执行文件即可开始调试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [目标文件名]</span><br></pre></td></tr></table></figure><p>GDB还可以关联正在运行的程序进行调试。我们可以通过ps命令查询目标进程的PID，随后进入GDB使用attach命令关联进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep [进程名]</span><br><span class="line">gdb</span><br><span class="line">(gdb) attach [PID]</span><br></pre></td></tr></table></figure><p>Linux用户在这一过程过可能会遇到权限不足的情况。解决方法：切换至root用户，进入<strong>/etc/stsctl.d/10-ptrace.conf</strong>中将<code>kernel.yama.ptrace_scpoe = 1</code>改为<code>kernel.yama.ptrace_scpoe = 0</code>即可。</p><h3 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h3><p>通常在调试过程中，我们需要在程序的某个位置添加断点，并让程序运行到这一位置时自动暂停以分析程序当前的运行状态。在GDB环境下，我们可以通过break命令来快速添加断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [源文件名称]:[行号] #执行到某一行时中断</span><br><span class="line">(gdb) break [函数名] #执行到某个函数时中断</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:5</span><br><span class="line">(gdb) break main</span><br></pre></td></tr></table></figure></blockquote><p>有时我们希望程序在特定条件下中断，这个时候我们可以使用break+if或condition语句来设置条件断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [中断位置] if 触发条件</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:10 if a==5</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [中断位置]</span><br><span class="line">(gdb) condition [断点号] [触发条件]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:10</span><br><span class="line">(gdb) condition 1 a==5</span><br></pre></td></tr></table></figure></blockquote><p>我们可以使用info指令查看已设置断点的断点号及相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure><p>通过clear和delete命令可以删除已创建的断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear [目标文件名]:[行号] #删除某一行处的断点</span><br><span class="line">(gdb) clear [函数名] #删除某个函数处的断点</span><br><span class="line">(gdb) delete #删除所有断点</span><br><span class="line">(gdb) delete [断点号] #删除某一特定断点</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear test:5</span><br><span class="line">(gdb) delete 1</span><br></pre></td></tr></table></figure></blockquote><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>对于不需要向main函数传递参数的程序，可以直接使用run指令开始运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><p>对于需要向main函数传递参数的程序，可以使用set args指令或直接在run后跟参数的方式运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args [参数]</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args para1 para2 para3</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run [参数]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run para1 para2 para3</span><br></pre></td></tr></table></figure></blockquote><p>程序运行后，会一直运行至第一个断点处并暂停。若没有设置断点，则效果等同于直接运行程序。</p><p>当程序中断后，GDB提供了以下几种继续运行的指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next #单步执行（不进入函数内部，等同于Clion中的Step Over）</span><br><span class="line">(gdb) step #单步进入（进入函数内部，等同于Clion的Step Into）</span><br><span class="line">(gdb) continue #继续执行至下一个断点处</span><br><span class="line">(gdb) until [行号] #继续执行直至某一行</span><br><span class="line">(gdb) finish #运行至程序结尾</span><br></pre></td></tr></table></figure><h3 id="查看变量及内存"><a href="#查看变量及内存" class="headerlink" title="查看变量及内存"></a>查看变量及内存</h3><p>在程序中断时，GDB提供了一系列指令来查看当前变量及内存中的各种信息。</p><p>通过print指令可以打印变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print &#x27;[源文件名/函数名]&#x27;::[变量名/表达式]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print &#x27;main&#x27;::a</span><br><span class="line">(gdb) print &#x27;test.c&#x27;::b</span><br><span class="line">(gdb) print &#x27;main&#x27;::*p</span><br></pre></td></tr></table></figure></blockquote><p>通过display命令可以使得每次程序中断时自动打印某个变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display [变量名/表达式]</span><br></pre></td></tr></table></figure><p>此外，我们还可以通过watch指令追踪某一变量，使其值发生改变时中断程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch [变量名]</span><br></pre></td></tr></table></figure><p>通过backtrace指令可以查看函数调用栈的存储情况及相关信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace</span><br></pre></td></tr></table></figure><p>更多其他命令的详细用法，可以通过help指令查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help [命令]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GDB使用指南&quot;&gt;&lt;a href=&quot;#GDB使用指南&quot; class=&quot;headerlink&quot; title=&quot;GDB使用指南&quot;&gt;&lt;/a&gt;GDB使用指南&lt;/h1&gt;&lt;p&gt;GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。&lt;/p&gt;
&lt;p&gt;GDB官网：&lt;a href=&quot;http://www.gnu.org/software/gdb/&quot;&gt;GDB: The GNU Project Debugger&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Language" scheme="http://gonggongjohn.me/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>插入排序、归并排序及冒泡排序</title>
    <link href="http://gonggongjohn.me/2020/09/18/algorithm/algorithm-exp1/"/>
    <id>http://gonggongjohn.me/2020/09/18/algorithm/algorithm-exp1/</id>
    <published>2020-09-18T03:45:00.000Z</published>
    <updated>2021-04-17T09:26:32.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想"><a href="#内容与设计思想" class="headerlink" title="内容与设计思想"></a>内容与设计思想</h2><ol><li><p>设计一个数据生成器，输入参数包括 <script type="math/tex">N, s, t, T</script>；可随机生成一个大小为<script type="math/tex">N</script>、数值范围在 <script type="math/tex">[s, t]</script> 之间、类型为 <script type="math/tex">T</script> 的数据集合；<script type="math/tex">T</script> 包括三种类型（顺序递增、顺序递减、随机取值）</p></li><li><p>编程实现<strong>Merge sort</strong>算法和<strong>Insertion sort</strong>算法。</p></li><li><p>对于<strong>顺序递增</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<script type="math/tex">10^2, 10^3, 10^4, 10^5, 10^6</script>）下，两种算法的运行时间各是多少？</p></li><li><p>对于<strong>顺序递减</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<script type="math/tex">10^2, 10^3, 10^4, 10^5, 10^6</script>）下，两种算法的运行时间各是多少？</p></li><li><p>对于<strong>随机取值</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<script type="math/tex">10^2, 10^3, 10^4, 10^5, 10^6</script>）下，两种算法的运行时间各是多少？</p></li><li><p>编程实现<strong>Bubble sort</strong>算法，并与上面两个算法进行对比。</p></li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,s,t,type,a[<span class="number">1000000</span>];</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;t&gt;&gt;type;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = s + rand() % (t - s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</span><br><span class="line">        sort(a, a + n, cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++)&#123;</span><br><span class="line">        fout&lt;&lt;a[w]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000000</span>], n, key, j;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!fin.eof())&#123;</span><br><span class="line">        fin&gt;&gt;a[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        key = a[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key)&#123;</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[w]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>], t[<span class="number">1000000</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    merge(left, mid);</span><br><span class="line">    merge(mid, right);</span><br><span class="line">    <span class="keyword">int</span> p = left, q = mid, cur = left;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= mid || (q &lt; right &amp;&amp; a[p] &gt; a[q]))</span><br><span class="line">            t[cur++] = a[q++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[cur++] = a[p++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!fin.eof()) &#123;</span><br><span class="line">        fin &gt;&gt; a[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    merge(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[w] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000000</span>], n, temp;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!fin.eof())&#123;</span><br><span class="line">        fin&gt;&gt;a[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[i + <span class="number">1</span>])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++) <span class="built_in">cout</span>&lt;&lt;a[w]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行效率"><a href="#运行效率" class="headerlink" title="运行效率"></a>运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><p>（图待补全）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的图表中可以发现，当数据集合为已经排序好（顺序递增）的集合时，插入排序和冒泡排序的运行效率高于归并排序。但当数据集合为顺序递减或随机取值时，归并排序的运行效率要明显高于插入排序和冒泡排序。且随着数据规模的增大，归并排序所需的运行时间增长较为缓慢，而插入排序和冒泡排序的运行时间迅速增长，且冒泡排序的增长幅度要高于插入排序。通过理论计算可以得知插入排序的最好时间复杂度为 <script type="math/tex">\mathcal{O}(n)</script>，平均和最坏时间复杂度均为 <script type="math/tex">\mathcal{O}(n^2)</script>；归并排序的最好，平均，最坏时间复杂度均为 <script type="math/tex">\mathcal{O}(n \lg n)</script>；冒泡排序的最好时间复杂度为 <script type="math/tex">\mathcal{O}(n)</script>，平均和最坏时间复杂度均为 <script type="math/tex">\mathcal{O}(n^2)</script>，这与实验结果基本吻合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内容与设计思想&quot;&gt;&lt;a href=&quot;#内容与设计思想&quot; class=&quot;headerlink&quot; title=&quot;内容与设计思想&quot;&gt;&lt;/a&gt;内容与设计思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设计一个数据生成器，输入参数包括 &lt;script type=&quot;math/tex&quot;&gt;</summary>
      
    
    
    
    <category term="算法" scheme="http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.me/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>插入排序、归并排序及冒泡排序</title>
    <link href="http://gonggongjohn.me/2020/09/18/algorithm/algorithm-exp3/"/>
    <id>http://gonggongjohn.me/2020/09/18/algorithm/algorithm-exp3/</id>
    <published>2020-09-18T03:45:00.000Z</published>
    <updated>2021-04-17T09:26:32.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想"><a href="#内容与设计思想" class="headerlink" title="内容与设计思想"></a>内容与设计思想</h2><ol><li><p>设计一个数据生成器，输入参数包括 <script type="math/tex">N, s, t, T</script>；可随机生成一个大小为<script type="math/tex">N</script>、数值范围在 <script type="math/tex">[s, t]</script> 之间、类型为 <script type="math/tex">T</script> 的数据集合；<script type="math/tex">T</script> 包括三种类型（顺序递增、顺序递减、随机取值）</p></li><li><p>编程实现<strong>Merge sort</strong>算法和<strong>Insertion sort</strong>算法。</p></li><li><p>对于<strong>顺序递增</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<script type="math/tex">10^2, 10^3, 10^4, 10^5, 10^6</script>）下，两种算法的运行时间各是多少？</p></li><li><p>对于<strong>顺序递减</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<script type="math/tex">10^2, 10^3, 10^4, 10^5, 10^6</script>）下，两种算法的运行时间各是多少？</p></li><li><p>对于<strong>随机取值</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<script type="math/tex">10^2, 10^3, 10^4, 10^5, 10^6</script>）下，两种算法的运行时间各是多少？</p></li><li><p>编程实现<strong>Bubble sort</strong>算法，并与上面两个算法进行对比。</p></li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,s,t,type,a[<span class="number">1000000</span>];</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;t&gt;&gt;type;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = s + rand() % (t - s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</span><br><span class="line">        sort(a, a + n, cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++)&#123;</span><br><span class="line">        fout&lt;&lt;a[w]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000000</span>], n, key, j;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!fin.eof())&#123;</span><br><span class="line">        fin&gt;&gt;a[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        key = a[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key)&#123;</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[w]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>], t[<span class="number">1000000</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    merge(left, mid);</span><br><span class="line">    merge(mid, right);</span><br><span class="line">    <span class="keyword">int</span> p = left, q = mid, cur = left;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= mid || (q &lt; right &amp;&amp; a[p] &gt; a[q]))</span><br><span class="line">            t[cur++] = a[q++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[cur++] = a[p++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!fin.eof()) &#123;</span><br><span class="line">        fin &gt;&gt; a[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    merge(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[w] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000000</span>], n, temp;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!fin.eof())&#123;</span><br><span class="line">        fin&gt;&gt;a[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[i + <span class="number">1</span>])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++) <span class="built_in">cout</span>&lt;&lt;a[w]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行效率"><a href="#运行效率" class="headerlink" title="运行效率"></a>运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><p>（图待补全）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的图表中可以发现，当数据集合为已经排序好（顺序递增）的集合时，插入排序和冒泡排序的运行效率高于归并排序。但当数据集合为顺序递减或随机取值时，归并排序的运行效率要明显高于插入排序和冒泡排序。且随着数据规模的增大，归并排序所需的运行时间增长较为缓慢，而插入排序和冒泡排序的运行时间迅速增长，且冒泡排序的增长幅度要高于插入排序。通过理论计算可以得知插入排序的最好时间复杂度为 <script type="math/tex">\mathcal{O}(n)</script>，平均和最坏时间复杂度均为 <script type="math/tex">\mathcal{O}(n^2)</script>；归并排序的最好，平均，最坏时间复杂度均为 <script type="math/tex">\mathcal{O}(n \lg n)</script>；冒泡排序的最好时间复杂度为 <script type="math/tex">\mathcal{O}(n)</script>，平均和最坏时间复杂度均为 <script type="math/tex">\mathcal{O}(n^2)</script>，这与实验结果基本吻合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内容与设计思想&quot;&gt;&lt;a href=&quot;#内容与设计思想&quot; class=&quot;headerlink&quot; title=&quot;内容与设计思想&quot;&gt;&lt;/a&gt;内容与设计思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设计一个数据生成器，输入参数包括 &lt;script type=&quot;math/tex&quot;&gt;</summary>
      
    
    
    
    <category term="算法" scheme="http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.me/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>插入排序、归并排序及冒泡排序</title>
    <link href="http://gonggongjohn.me/2020/09/18/algorithm/algorithm-exp4/"/>
    <id>http://gonggongjohn.me/2020/09/18/algorithm/algorithm-exp4/</id>
    <published>2020-09-18T03:45:00.000Z</published>
    <updated>2021-04-17T09:26:32.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想"><a href="#内容与设计思想" class="headerlink" title="内容与设计思想"></a>内容与设计思想</h2><ol><li><p>设计一个数据生成器，输入参数包括 <script type="math/tex">N, s, t, T</script>；可随机生成一个大小为<script type="math/tex">N</script>、数值范围在 <script type="math/tex">[s, t]</script> 之间、类型为 <script type="math/tex">T</script> 的数据集合；<script type="math/tex">T</script> 包括三种类型（顺序递增、顺序递减、随机取值）</p></li><li><p>编程实现<strong>Merge sort</strong>算法和<strong>Insertion sort</strong>算法。</p></li><li><p>对于<strong>顺序递增</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<script type="math/tex">10^2, 10^3, 10^4, 10^5, 10^6</script>）下，两种算法的运行时间各是多少？</p></li><li><p>对于<strong>顺序递减</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<script type="math/tex">10^2, 10^3, 10^4, 10^5, 10^6</script>）下，两种算法的运行时间各是多少？</p></li><li><p>对于<strong>随机取值</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<script type="math/tex">10^2, 10^3, 10^4, 10^5, 10^6</script>）下，两种算法的运行时间各是多少？</p></li><li><p>编程实现<strong>Bubble sort</strong>算法，并与上面两个算法进行对比。</p></li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,s,t,type,a[<span class="number">1000000</span>];</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;t&gt;&gt;type;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        a[i] = s + rand() % (t - s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</span><br><span class="line">        sort(a, a + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</span><br><span class="line">        sort(a, a + n, cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++)&#123;</span><br><span class="line">        fout&lt;&lt;a[w]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fout.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000000</span>], n, key, j;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!fin.eof())&#123;</span><br><span class="line">        fin&gt;&gt;a[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        key = a[i];</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; key)&#123;</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[w]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>], t[<span class="number">1000000</span>], n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    merge(left, mid);</span><br><span class="line">    merge(mid, right);</span><br><span class="line">    <span class="keyword">int</span> p = left, q = mid, cur = left;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= mid || (q &lt; right &amp;&amp; a[p] &gt; a[q]))</span><br><span class="line">            t[cur++] = a[q++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t[cur++] = a[p++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!fin.eof()) &#123;</span><br><span class="line">        fin &gt;&gt; a[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    merge(<span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[w] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000000</span>], n, temp;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!fin.eof())&#123;</span><br><span class="line">        fin&gt;&gt;a[n];</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[i + <span class="number">1</span>])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">                a[i + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; n; w++) <span class="built_in">cout</span>&lt;&lt;a[w]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  fin.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行效率"><a href="#运行效率" class="headerlink" title="运行效率"></a>运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><p>（图待补全）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的图表中可以发现，当数据集合为已经排序好（顺序递增）的集合时，插入排序和冒泡排序的运行效率高于归并排序。但当数据集合为顺序递减或随机取值时，归并排序的运行效率要明显高于插入排序和冒泡排序。且随着数据规模的增大，归并排序所需的运行时间增长较为缓慢，而插入排序和冒泡排序的运行时间迅速增长，且冒泡排序的增长幅度要高于插入排序。通过理论计算可以得知插入排序的最好时间复杂度为 <script type="math/tex">\mathcal{O}(n)</script>，平均和最坏时间复杂度均为 <script type="math/tex">\mathcal{O}(n^2)</script>；归并排序的最好，平均，最坏时间复杂度均为 <script type="math/tex">\mathcal{O}(n \lg n)</script>；冒泡排序的最好时间复杂度为 <script type="math/tex">\mathcal{O}(n)</script>，平均和最坏时间复杂度均为 <script type="math/tex">\mathcal{O}(n^2)</script>，这与实验结果基本吻合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内容与设计思想&quot;&gt;&lt;a href=&quot;#内容与设计思想&quot; class=&quot;headerlink&quot; title=&quot;内容与设计思想&quot;&gt;&lt;/a&gt;内容与设计思想&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设计一个数据生成器，输入参数包括 &lt;script type=&quot;math/tex&quot;&gt;</summary>
      
    
    
    
    <category term="算法" scheme="http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.me/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.me/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>实数的严格定义</title>
    <link href="http://gonggongjohn.me/2020/08/26/real-number/"/>
    <id>http://gonggongjohn.me/2020/08/26/real-number/</id>
    <published>2020-08-26T11:03:01.000Z</published>
    <updated>2021-01-21T07:09:14.876Z</updated>
    
    <content type="html"><![CDATA[<p>对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="分析学" scheme="http://gonggongjohn.me/categories/%E5%88%86%E6%9E%90%E5%AD%A6/"/>
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.me/tags/Mathematics/"/>
    
    <category term="Analysis" scheme="http://gonggongjohn.me/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>代数概念整理：映射</title>
    <link href="http://gonggongjohn.me/2020/07/31/algebra-projection/"/>
    <id>http://gonggongjohn.me/2020/07/31/algebra-projection/</id>
    <published>2020-07-31T07:00:00.000Z</published>
    <updated>2021-01-21T07:09:04.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li><p>设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个<strong>映射</strong>，记为 $f:X \to Y$ ， $X$ 称为 $f$ 的<strong>定义域</strong>， $Y$ 称为 $f$ 的<strong>陪域</strong></p></li><li><p>设 $f:X \to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的<strong>象</strong>，记为 $f(a)$ ； $a$ 称为 $b$ 的<strong>原象</strong>，记为 $f^{-1}(b)$ ；集合 ${f(x) \big| x \in X}$ 称为 $f$ 的<strong>值域</strong>或 $f$ 的<strong>象</strong>，记为$f(X)$ 或 $Imf$</p></li><li><p>设 $f:X \to Y$ 为一映射，若 $\forall x_1 \neq x_2 \in X, f(x_1) \neq f(x_2)$ ，则称 $f$ 为一个<strong>单射</strong></p></li><li><p>设 $f:X \to Y$ 为一映射，若 $\forall y \in Y, \exists x \in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个<strong>满射</strong></p><a id="more"></a></li><li><p>设 $f:X \to Y$ 为一映射，若 $f$ 即是<strong>单射</strong>又是<strong>满射</strong>，则称 $f$ 为一个<strong>双射</strong></p></li><li><p>设 $f: X \to Y$ 为一映射，若 $Y=X$ ，且 $\forall x \in X, f(x) = x$ ，则称 $f$ 为一个<strong>恒等映射</strong>，记为 $Id_X$ 或 $e_X$</p></li><li><p>设 $f: A \to C, g: B \to D$ 为两个映射，若 $A = B,C=D$ ，且 $\forall x \in A, f(x)=g(x)$ ，则称映射 $f$ 与 $g$ <strong>相等</strong></p></li><li><p>设 $f: X \to Y, g: Y \to Z$ 为两个映射，则由法则 $(g \circ f)(x) = g(f(x))$ 定义的映射称为 $f$ 与 $g$ 的<strong>合成</strong>，记为 $g \circ f: X \to Z$ 或 $gf: X \to Z$</p></li><li><p>设 $f:X \to Y,g: Y \to X$ 为两个映射，若 $g \circ f = e_X$ ，则称 $g$ 为 $f$ 的<strong>左逆</strong>， $f$ 为 $g$ 的<strong>右逆</strong>；若  $g \circ f = e_X,f \circ g = e_Y$ ,则称 $g$ 为 $f$ 的<strong>双边逆</strong>或<strong>逆</strong></p></li></ol><h1 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h1><p><strong>1、（映射的合成律）</strong> 设 $f: X \to Y, g: Y \to Z, h: Z \to W$ 为三个映射，则 $h(gf)=(hg)f$</p><p><strong>证明：</strong> 对于 $ h(gf) $ ，$(X \to Y \to Z) \to W=X \to W$ ；对于 $(hg)f$ ，$X \to (Y \to Z \to W)=X \to W$</p><p>$\therefore$ $h(gf)$ 与 $(hg)f$ 的定义域及陪域相同</p><p>$\forall x \in X$ ，由<strong>定义8</strong>可知</p><p>$(h(gf))(x)=h((gf)(x))=h(g(f(x)))=(hg)(f(x))=((hg)f)(x)$</p><p>$\therefore$ 由<strong>定义7</strong>可知，$h(gf)=(hg)f$</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个&lt;strong&gt;映射&lt;/strong&gt;，记为 $f:X \to Y$ ， $X$ 称为 $f$ 的&lt;strong&gt;定义域&lt;/strong&gt;， $Y$ 称为 $f$ 的&lt;strong&gt;陪域&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的&lt;strong&gt;象&lt;/strong&gt;，记为 $f(a)$ ； $a$ 称为 $b$ 的&lt;strong&gt;原象&lt;/strong&gt;，记为 $f^{-1}(b)$ ；集合 ${f(x) \big| x \in X}$ 称为 $f$ 的&lt;strong&gt;值域&lt;/strong&gt;或 $f$ 的&lt;strong&gt;象&lt;/strong&gt;，记为$f(X)$ 或 $Imf$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，若 $\forall x_1 \neq x_2 \in X, f(x_1) \neq f(x_2)$ ，则称 $f$ 为一个&lt;strong&gt;单射&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，若 $\forall y \in Y, \exists x \in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个&lt;strong&gt;满射&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="代数学" scheme="http://gonggongjohn.me/categories/%E4%BB%A3%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.me/tags/Mathematics/"/>
    
    <category term="Algebra" scheme="http://gonggongjohn.me/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title>代数概念整理：集合</title>
    <link href="http://gonggongjohn.me/2020/07/30/algebra-set/"/>
    <id>http://gonggongjohn.me/2020/07/30/algebra-set/</id>
    <published>2020-07-30T07:31:34.000Z</published>
    <updated>2021-01-21T07:08:51.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li><p>若 $a$ 为 $S$ 中的一个元素，则称 $a$ <strong>包含于</strong> $S$ ，记为 $a \in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ <strong>不包含于</strong> $S$ ，记为 $a \notin S$</p></li><li><p>设 $S,T$ 为两个集合，若 $\forall a \in S$ ，成立 $a \in T$ ，则称 $S$ 是 $T$ 的一个<strong>子集</strong>，记为 $S \subset T$</p></li><li><p>设 $S,T$ 为两个集合，若 $S \subset T, T \subset S$ ，则称 $S$ 与 $T$ <strong>相等</strong>，记为 $S=T$</p></li><li><p>设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \in T }$ 称为 $S$ 与 $T$ 的<strong>交集</strong>，记为 $S \cap T$ ；将集合 ${ x \big| x \in S \lor x \in T }$ 称为 $S$ 与 $T$ 的<strong>并集</strong>，记为 $S \cup T$</p><a id="more"></a></li><li><p>设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \notin T }$ 称为 $S$ 与 $T$ 的<strong>差集</strong>，记为 $S \setminus T$</p></li><li><p>设 $S,T$ 为两个集合，若 $T \subset S$ ，则将集合 $S \setminus T$ 称为 $T$ 在 $S$ 中的的<strong>补集</strong>，记为 $\complement_S{T}$</p></li><li><p>设 $S,T$ 为两个集合，则将集合 ${(x,y) \big| x \in S, y \in T}$ 称为 $S$ 与 $T$ 的<strong>笛卡尔积</strong> ，记为 $S \times T$ ；将 $\underbrace{X \times X \times … \times X}_{k个}$ 简记为 $X^k$</p></li><li><p>设 $S$ 为一个集合，则将 $S$ 中元素的个数记为 $S$ 的<strong>基数</strong>，记为 $|S|$</p></li></ol><h1 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h1><p><strong>1、（集合分配律）</strong>设 $R,S,T$ 为三个集合，则</p><p><strong>①</strong> $R \cap (S \cup T)=(R \cap S) \cup (R \cap T)$</p><p><strong>②</strong> $R \cup (S \cap T) = (R \cup S) \cap (R \cup T)$</p><p><strong>证明：①</strong> $\forall x \in R \cap (S \cup T)$ </p><p>$\therefore x \in R$ 且 $x \in S \cup T$</p><p>$\therefore$ （ $x \in R$ 且 $x \in S$ ） 或 （ $x \in R 且 x \in T$ ）</p><p>$ \therefore x \in (R \cap S) \cup (R \cap T)$</p><p>$\therefore$ 由<strong>定义2</strong>可知， $R \cap (S \cup T)\subset (R \cap S) \cup (R \cap T)$</p><p>反之， $\forall x \in (R \cap S) \cup (R \cap T)$</p><p>$\therefore$ $x \in R \cap S$ 或 $x \in R \cap T$</p><p>$\therefore x \in R$ 且（ $x \in S$ 或 $x \in T$ ）</p><p>$\therefore$ 由<strong>定义2</strong>可知，$(R \cap S) \cup (R \cap T) \subset R \cap (S \cup T)$</p><p>$\therefore$ 由<strong>定义3</strong>可知， $R \cap (S \cup T)=(R \cap S) \cup (R \cap T)$</p><p><strong>② 同理即可证得结论</strong></p><p><strong>2、</strong> 设 $X,Y$ 为两个集合，且 $|X|=n,|Y|=m$ ，则</p><p><strong>①</strong> $|X \times Y|=n \cdot m$</p><p><strong>②</strong> $|X \cup Y|=n +m-|X \cap Y|$</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;若 $a$ 为 $S$ 中的一个元素，则称 $a$ &lt;strong&gt;包含于&lt;/strong&gt; $S$ ，记为 $a \in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ &lt;strong&gt;不包含于&lt;/strong&gt; $S$ ，记为 $a \notin S$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，若 $\forall a \in S$ ，成立 $a \in T$ ，则称 $S$ 是 $T$ 的一个&lt;strong&gt;子集&lt;/strong&gt;，记为 $S \subset T$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，若 $S \subset T, T \subset S$ ，则称 $S$ 与 $T$ &lt;strong&gt;相等&lt;/strong&gt;，记为 $S=T$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \in T }$ 称为 $S$ 与 $T$ 的&lt;strong&gt;交集&lt;/strong&gt;，记为 $S \cap T$ ；将集合 ${ x \big| x \in S \lor x \in T }$ 称为 $S$ 与 $T$ 的&lt;strong&gt;并集&lt;/strong&gt;，记为 $S \cup T$&lt;/p&gt;</summary>
    
    
    
    <category term="代数学" scheme="http://gonggongjohn.me/categories/%E4%BB%A3%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.me/tags/Mathematics/"/>
    
    <category term="Algebra" scheme="http://gonggongjohn.me/tags/Algebra/"/>
    
  </entry>
  
</feed>
