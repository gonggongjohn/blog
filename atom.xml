<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GONGGONGJOHN&#39;s Blog</title>
  
  
  <link href="http://gonggongjohn.github.io/blog/atom.xml" rel="self"/>
  
  <link href="http://gonggongjohn.github.io/blog/"/>
  <updated>2020-11-26T10:34:49.815Z</updated>
  <id>http://gonggongjohn.github.io/blog/</id>
  
  <author>
    <name>GONGGONGJOHN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从主方法到Akra-Bazzi定理</title>
    <link href="http://gonggongjohn.github.io/blog/2020/11/25/akra-bazzi/"/>
    <id>http://gonggongjohn.github.io/blog/2020/11/25/akra-bazzi/</id>
    <published>2020-11-25T03:34:14.000Z</published>
    <updated>2020-11-26T10:34:49.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h2><p>在算法分析中，当我们使用分治法求解问题时，通常会遇到以递归式定义的算法运行时间函数。要得到此类算法的时间复杂度，就必须求出该递归式的渐近表达式。通常情况下，我们可以通过如下公式直接得到大部分不太复杂的递归式的渐近解。<strong>《算法导论》</strong>一书中将该方法称为<strong>“主方法”</strong>。</p><a id="more"></a><blockquote><p><strong>Theorem: </strong>设<script type="math/tex">a\geq 1, b >1</script>，<script type="math/tex">f(n)</script>为一定义在非负整数上的函数， <script type="math/tex">T(n)=aT\left(\frac{n}{b}\right) + f(n)</script>（当 <script type="math/tex">\frac{n}{b}</script> 不为整数时代表 <script type="math/tex">\lfloor{\frac{n}{b}\rfloor}</script> 或 <script type="math/tex">\lceil{\frac{n}{b}\rceil}</script>），则</p><ol><li><p>若存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \mathcal{O}\left(n^{\log_b a - \varepsilon}\right)</script>，则 <script type="math/tex">T(n) = \Theta\left(n^{\log_b a}\right)</script></p></li><li><p>若存在 <script type="math/tex">k \geq 0</script>，使得 <script type="math/tex">f(n) = \Theta\left(n^{\log_b a} \lg^k n\right)</script>，则 <script type="math/tex">T(n) = \Theta\left(n^{\log_b a} \lg^{k+1} n\right)</script></p></li><li><p>若存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \Omega\left(n^{\log_b a + \varepsilon}\right)</script>，且存在 <script type="math/tex">0<c<1</script>及正整数 <script type="math/tex">N</script>，使得当 <script type="math/tex">n>N</script> 时，有 <script type="math/tex">af\left(\frac{n}{b}\right) \leq cf(n)</script>，则 <script type="math/tex">T(n) = \Theta(f(n))</script></p></li></ol></blockquote><p>通过该定理，我们可以快速得到一些算法的时间复杂度。</p><blockquote><p><strong>Example1:</strong> Strassen矩阵算法的运行时间函数 <script type="math/tex">T(n)=7T\left(\frac{n}{2}\right) + \Theta(n^2)</script>，求Strassen矩阵算法的时间复杂度</p><p><strong>解：</strong>由 <script type="math/tex">\log_2 7 > \log_2 4 = 2</script> 可知，存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \Theta(n^2) = \mathcal{O}(n^{\log_2 7 - \varepsilon})</script></p><p>故由主定理可知，<script type="math/tex">T(n) = \Theta(n^{\log_2 7})</script></p><p><strong>Example2:</strong> 归并排序算法的运行时间函数 <script type="math/tex">T(n) = 2T\left(\frac{n}{2}\right) + \Theta(n)</script>，求归并排序算法的时间复杂度</p><p><strong>解：</strong>由 <script type="math/tex">\log_2 2 = 1</script> 可知，存在 <script type="math/tex">k=0</script>，使得 <script type="math/tex">f(n) = \Theta(n) = \Theta(n^{\log_2 2} \lg^k n)</script></p><p>故由主定理可知，<script type="math/tex">T(n) = \Theta(n \lg n)</script></p><p><strong>Example3:</strong> 若一个算法的运行时间函数 <script type="math/tex">T(n)=2T\left(\frac{n}{2}\right) + \Theta(n^2)</script>，求该算法的时间复杂度</p><p><strong>解：</strong>由 <script type="math/tex">\log_2 2 = 1</script> 可知，存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \Theta(n^2) = \Omega(n^{\log_2 2 + \varepsilon})</script></p><p>又由于 <script type="math/tex">af\left(\frac{n}{b}\right) = 2 \left(\frac{n}{2}\right)^2 = \frac{n^2}{2}</script></p><p>因此仅需取 <script type="math/tex">\frac{1}{2} \leq c < 1</script>，则有 <script type="math/tex">af\left(\frac{n}{b}\right) \leq cf(n)</script></p><p>故由主定理可知，<script type="math/tex">T(n) = \Theta(n^2)</script></p></blockquote><h2 id="主定理的证明"><a href="#主定理的证明" class="headerlink" title="主定理的证明"></a>主定理的证明</h2><p>下面我们来尝试证明主定理。</p><p>主定理的证明思路如下：首先我们考虑当 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的某个幂次时的情况，此时可以保证 <script type="math/tex">\frac{n}{b}</script> 是一个整数，因此可以直接做递推并求出其阶数。随后，通过放缩，我们可以将其推广到一切正整数的情况上去。</p><p>首先我们考虑当 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的 <script type="math/tex">k</script> 次幂时的情况。此时原递归式可写为</p><script type="math/tex; mode=display">T(n)=\left\{\begin{aligned}&\Theta(1) &, &n = 1 \\&aT\left(\frac{n}{b}\right)+f(n) &, &n=b^i(i=1,2,...,k)\end{aligned}\right.</script><p>作递推，可得</p><script type="math/tex; mode=display">\begin{aligned}T(n)&=aT\left(\frac{n}{b}\right) + f(n) \\&=a^2T\left(\frac{n}{b^2}\right) + af\left(\frac{n}{b}\right) + f(n) \\&=a^3T\left(\frac{n}{b^3}\right) + a^2f\left(\frac{n}{b^2}\right) + af\left(\frac{n}{b}\right) + f(n) \\&=... \\&=a^{\log_b n} T(1) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right) \\&=n^{\log_b a} \Theta(1) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right) \\&=\Theta \left(n^{\log_b a} \right) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)\end{aligned}</script><p>因此我们只需要考察 <script type="math/tex">\sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)</script> 的渐近表达式即可得到 <script type="math/tex">T(n)</script> 的渐近解。</p><p>现在我们来证明如下的的引理成立</p><blockquote><p><strong>Lemma:</strong> 设 <script type="math/tex">g(n) = \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)</script> （其中 <script type="math/tex">a \geq 1, b > 1</script>，<script type="math/tex">n=b^k</script>），则</p><ol><li><p>若存在 <script type="math/tex">\varepsilon > 0</script>，使得 <script type="math/tex">f(n) = \mathcal{O} \left(n^{\log_b a - \varepsilon} \right)</script>，则 <script type="math/tex">g(n) = \mathcal{O}\left(n^{\log_b a}\right)</script></p></li><li><p>若存在 <script type="math/tex">k \geq 0</script>，使得 <script type="math/tex">f(n) = \Theta\left(n^{\log_b a} \lg^k n\right)</script>，则 <script type="math/tex">g(n) = \Theta\left(n^{\log_b a} \lg^{k+1} n\right)</script></p></li><li><p>若存在 <script type="math/tex">0<c<1</script>及正整数 <script type="math/tex">N</script>，使得当 <script type="math/tex">n>N</script> 时，有 <script type="math/tex">af\left(\frac{n}{b}\right) \leq cf(n)</script>，则 <script type="math/tex">g(n) = \Theta(f(n))</script></p></li></ol><p><strong>证明：①</strong> 当 <script type="math/tex">f(n) = \mathcal{O} \left(n^{\log_b a - \varepsilon} \right)</script> 时，<script type="math/tex">f\left(\frac{n}{b^i}\right) = \mathcal{O}\left(\left(\frac{n}{b^i}\right)^{\log_b a - \varepsilon}\right)</script></p><p>此时</p><script type="math/tex; mode=display">\begin{aligned}g(n) &= \sum_\limits{i = 0}^{\log_b n - 1} a^i \cdot \mathcal{O}\left(\left(\frac{n}{b^i}\right)^{\log_b a - \varepsilon}\right) \\&=\mathcal{O} \left(\sum_\limits{i = 0}^{\log_b n - 1} a^i \cdot \left(\frac{n}{b^i}\right)^{\log_b a - \varepsilon}\right) \\&=\mathcal{O} \left(n^{\log_b a - \varepsilon} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \left(\frac{a}{b^{\log_b a - \varepsilon}}\right)^i\right) \\&=\mathcal{O} \left(n^{\log_b a - \varepsilon} \cdot \sum_\limits{i = 0}^{\log_b n - 1} b^{i\varepsilon}\right) \\&=\mathcal{O} \left(n^{\log_b a - \varepsilon} \cdot \frac{n^\varepsilon - 1}{b^\varepsilon - 1}\right) \\&=\mathcal{O} \left(\frac{n^{\log_b a}}{b^\varepsilon - 1} - \frac{n^{\log_b a - \varepsilon}}{b^\varepsilon - 1}\right) \\&=\mathcal{O} \left(n^{\log_b a} \right)\end{aligned}</script><p><strong>②</strong> 当 <script type="math/tex">f(n) = \Theta\left(n^{\log_b a} \lg^k n\right)</script> 时，<script type="math/tex">f\left(\frac{n}{b^i}\right) = \Theta \left( \left(\frac{n}{b^i}\right)^{\log_b a} \lg^k \left(\frac{n}{b^i}\right)\right)</script></p><p>此时</p><script type="math/tex; mode=display">\begin{aligned}g(n) &= \sum_\limits{i = 0}^{\log_b n - 1} a^i \cdot \Theta\left(\left(\frac{n}{b^i}\right)^{\log_b a} \lg^k \left(\frac{n}{b^i}\right)\right) \\&= \Theta \left(\sum_\limits{i = 0}^{\log_b n - 1} a^i\left(\frac{n}{b^i}\right)^{\log_b a} \lg^k \left(\frac{n}{b^i}\right)\right) \\&=\Theta \left(n^{\log_b a} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \lg^k \left(\frac{n}{b^i}\right)\right) \\&=\Theta \left(n^{\log_b a} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \left(\lg n - i \lg b \right)^k\right)\end{aligned}</script><p>由二项式定理可知，<script type="math/tex">\left(\lg n - i \lg b \right)^k = \lg^k n + \mathcal{O}\left(\lg^k n\right)</script></p><p>故</p><script type="math/tex; mode=display">\begin{aligned}g(n) &= \Theta \left(n^{\log_b a} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \left(\lg^k n + \mathcal{O} \left(\lg^k n \right)\right)\right) \\&= \Theta \left(n^{\log_b a} \cdot \left(\log_b n \cdot \lg^k n + \log_b n \cdot \mathcal{O} \left(\lg^k n \right)\right)\right) \\&=\Theta \left( n^{\log_b a} \cdot \log_b n \cdot \lg^k n\right) \\&=\Theta \left(n^{\log_b a} \lg^{k+1} n\right)\end{aligned}</script><p><strong>③</strong> 由 <script type="math/tex">g(n) = f(n) + \sum_\limits{i = 1}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)</script> 可知 <script type="math/tex">g(n) = \Omega(f(n))</script></p><p>由条件存在 <script type="math/tex">c<1</script>及正整数 <script type="math/tex">N</script>，使得当 <script type="math/tex">n>N</script> 时，有 <script type="math/tex">af\left(\frac{n}{b}\right) \leq cf(n)</script></p><p>作递推可知，当 <script type="math/tex">\frac{n}{b^{i-1}}>N</script> 时，有 <script type="math/tex">a^i f\left(\frac{n}{b^i}\right) \leq c^if(n)</script></p><p>故</p><script type="math/tex; mode=display">\begin{aligned}g(n) &= \sum_\limits{i = 0}^{\log_b n - \log_b N} a^i f \left( \frac{n}{b^i} \right) + \sum_\limits{i = \log_b n - \log_b N + 1}^{\log_b n - 1} a^i f \left( \frac{n}{b^i} \right) \\&\leq \sum_\limits{i = 0}^{\log_b n - \log_b N}c^if(n) + \Theta(1) \\&=f(n) \sum_\limits{i = 0}^{\log_b n - \log_b N}c^i + \Theta(1) \\&\leq f(n) \sum_\limits{i = 0}^{\infty}c^i + \Theta(1) \\&=\frac{1}{1-c} \cdot f(n) + \Theta(1) \\&=\mathcal{O}(f(n))\end{aligned}</script><p>由此可得 <script type="math/tex">g(n) = \Theta(f(n))</script></p></blockquote><p>由于 <script type="math/tex">T(n)=\Theta \left(n^{\log_b a} \right) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)</script>，故根据引理我们就能快速得到 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的 <script type="math/tex">k</script> 次幂时的主定理。</p><p>下面我们需要将 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的 <script type="math/tex">k</script> 次幂时的主定理推广到 <script type="math/tex">n</script> 为一切整数时的情况以证明完整的主定理成立。</p><p>首先由于</p><script type="math/tex; mode=display">\begin{aligned}T(n)&=aT\left(\lceil{\frac{n}{b}\rceil}\right) + f(n) \\&\geq aT\left(\frac{n}{b}\right) + f(n)\end{aligned}</script><p>故根据 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的幂次时的主定理可知当 <script type="math/tex">T(n)=aT\left(\lceil{\frac{n}{b}\rceil}\right) + f(n)</script> 时，<script type="math/tex">T(n)=\Omega(A)</script> （根据不同情况 <script type="math/tex">A</script> 取 <script type="math/tex">n^{\log_b a}</script>、<script type="math/tex">n^{\log_b a} \lg^{k+1} n</script> 或 <script type="math/tex">f(n)</script>）</p><p>同理可得当 <script type="math/tex">T(n)=aT\left(\lfloor{\frac{n}{b}\rfloor}\right) + f(n)</script> 时，<script type="math/tex">T(n)=\mathcal{O}(A)</script> </p><p>下面我们来证明当 <script type="math/tex">T(n)=aT\left(\lceil{\frac{n}{b}\rceil}\right) + f(n)</script> 时，<script type="math/tex">T(n)=\mathcal{O}(A)</script> </p><p>令 <script type="math/tex">t_0 = n, t_1 = \lceil{\frac{t_0}{b} \rceil}, t_2 = \lceil{\frac{t_1}{b} \rceil}, ..., t_k = \lceil{\frac{t_{k - 1}}{b} \rceil}=\Theta(1)</script></p><p>由于</p><script type="math/tex; mode=display">\begin{aligned}t_1 &\leq \frac{n}{b} + 1 \\t_2 &\leq \frac{t_1}{b} + 1 \leq \frac{n}{b^2} + \frac{1}{b} + 1 \\... \\t_k &\leq \frac{t_{k-1}}{b} + 1 \leq \frac{n}{b^k} + \sum_\limits{i = 0}^{k-1} \frac{1}{b^i}\end{aligned}</script><p>故</p><script type="math/tex; mode=display">\begin{aligned}t_k &\leq \frac{n}{b^k} + \sum_\limits{i = 0}^{\infty} \frac{1}{b^i} \\&=\frac{n}{b^k} + \frac{b}{b-1}\end{aligned}</script><p>由于当 <script type="math/tex">k = \lfloor{\log_b n\rfloor}</script> 时有</p><script type="math/tex; mode=display">\frac{n}{b^k} + \frac{b}{b-1} \leq \frac{n}{b^{\log_b n - 1}} + \frac{b}{b-1} = \frac{b^2}{b-1} = \Theta(1)</script><p>故 <script type="math/tex">k \leq \lfloor{\log_b n\rfloor}</script></p><p>故对原式作递推，可得</p><script type="math/tex; mode=display">\begin{aligned}T(n) &= aT\left(t_1\right) + f(t_0) \\&= a^2T(t_2) + af(t_1) + f(t_0) \\&... \\&\leq \Theta \left(n^{\log_b a} \right) + \sum_\limits{i = 0}^{\lfloor{\log_b n \rfloor} - 1} a^i f\left(t_i\right)\end{aligned}</script><p>因此由上面 <script type="math/tex">n</script> 为 <script type="math/tex">b</script> 的幂次时主定理得推导过程同理可得，<script type="math/tex">T(n) \leq \Theta(A)</script>，即 <script type="math/tex">T(n) = \mathcal{O}(A)</script></p><p>类似的我们同样可以得到当 <script type="math/tex">T(n)=aT\left(\lfloor{\frac{n}{b}\rfloor}\right) + f(n)</script> 时，<script type="math/tex">T(n)=\Omega(A)</script> </p><p>于是综上所述，<script type="math/tex">T(n) = \Theta(A)</script> 可推广到一切正整数，即主定理成立</p><h2 id="主方法的局限性"><a href="#主方法的局限性" class="headerlink" title="主方法的局限性"></a>主方法的局限性</h2><p>通俗来说，若要使用主方法，<script type="math/tex">f(n)</script> 必须多项式意义上的小于或大于 <script type="math/tex">n^{\log_b a}</script>（即 <script type="math/tex">f(n)</script> 与 <script type="math/tex">n^{\log_b a}</script> 的阶数差能够被某个 <script type="math/tex">n^\varepsilon</script> 控制住），或者 <script type="math/tex">f(n)</script> 仅比 <script type="math/tex">n^{\log_b a}</script> 大 <script type="math/tex">\log</script> 阶。而这三种情况并不能覆盖 <script type="math/tex">f(n)</script> 所有可能的函数特征，若 <script type="math/tex">f(n)</script> 的阶数在这三种情况之间，主方法就失效了。</p><p>例如当 <script type="math/tex">T(n) = 3T \left(\frac{n}{3}\right) + \frac{n}{\lg n}</script> 时，对于 <script type="math/tex">f(n) = \frac{n}{\lg n}</script>，无法找到某个 <script type="math/tex">\varepsilon > 0</script> 使得 <script type="math/tex">f(n) = \mathcal{O}(n)</script>，即 <script type="math/tex">f(n)</script> 不是多项式意义上的小于 <script type="math/tex">\log_b a</script>，此时便无法使用主定理得到该递归式的渐近解。</p><p>此外，主方法要求递归式必须由平均划分的子式定义，而对于如 <script type="math/tex">T(n) = T\left(\frac{n}{2} \right) + T\left(\frac{n}{4} \right) + T\left(\frac{n}{8} \right) + n</script> 这样非平均划分子式定义的递归式，同样无法使用主方法求解。</p><p>遇到此类问题，<strong>《算法导论》</strong>中推荐使用<strong>画递归树+数学归纳证明</strong>的方法解决。然而对于一些子问题情况较为复杂的递归式，这种方法的效率十分低下且容易出错，有时并不能很好的作为一种普适的办法使用。</p><h2 id="Akra-Bazzi定理"><a href="#Akra-Bazzi定理" class="headerlink" title="Akra-Bazzi定理"></a>Akra-Bazzi定理</h2><p>Akra-Bazzi定理是由两位黎巴嫩数学家<strong>Mohamad Akra</strong>和<strong>Louay Bazzi</strong>于1998年提出的一种用于求解线性递归式的渐近解的定理。Akra-Bazzi定理相比主定理对递归式的要求更弱，其适用范围也远广于主定理。</p><p>为了引出Akra-Bazzi定理，我们需要定义一个<strong>多项式增长条件</strong></p><blockquote><p><strong>Definition:</strong> 设 <script type="math/tex">g(x)</script> 为一定义在非负实数上的函数，<script type="math/tex">\{b_k\}</script> 为一个含有 <script type="math/tex">k</script> 项的数列且满足 <script type="math/tex">0 < b_i< 1</script>，若存在正常数 <script type="math/tex">c_1, c_2</script> 使得对任意 <script type="math/tex">x \geq 1, 1 \leq i \leq k, u \in [b_i x , x]</script>，均有 <script type="math/tex">c_1 g(x) \leq g(u) \leq c_2 g(x)</script> ，则称 <script type="math/tex">g(x)</script> 满足多项式增长条件</p></blockquote><p>由定义可知，若存在 <script type="math/tex">c > 0</script> ，使得 <script type="math/tex">|g'(x)| \in \mathcal{O}(x^c)</script>，则 <script type="math/tex">g(x)</script> 满足多项式增长条件。例如，对任意 <script type="math/tex">\alpha, \beta \in \mathbb{R}</script>，<script type="math/tex">g(x) = x^{\alpha} \lg^{\beta} x</script> 均满足多项式增长条件。</p><p>下面我们来叙述Akra-Bazzi定理：</p><blockquote><p><strong>Theorem:</strong> 设 <script type="math/tex">g(x)</script> 为一非负函数， <script type="math/tex">T(x) = \left\{ \begin{aligned} &\Theta(1)&, &1 \leq x \leq X_0 \\ &\sum_\limits{i = 1}^k a_i T(b_i x) +g(x)&, &x > X_0 \end{aligned}\right.</script>（其中 <script type="math/tex">k \geq 1, a_i > 0, 0 < b_i < 1</script>，<script type="math/tex">X_0</script> 满足对任意 <script type="math/tex">1 \leq i \leq k</script> 有 <script type="math/tex">X_0 > \frac{1}{b_i}</script> 且 <script type="math/tex">X_0> \frac{1}{1-b_i}</script>），若 <script type="math/tex">g(x)</script> 满足多项式增长条件，<script type="math/tex">p</script> 为方程 <script type="math/tex">\sum_\limits{i = 1}^k a_i b_i^p = 1</script> 的实数解，则</p><script type="math/tex; mode=display">\begin{aligned}T(x) &= \Theta \left(x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\right)\end{aligned}</script></blockquote><p>通过该定理，我们可以快速求解许多主方法无法处理的递归式。</p><blockquote><p><strong>Example1:</strong> 设 <script type="math/tex">T(n) = 2T \left( \frac{n}{4}\right) + 3T \left(\frac{n}{6} \right) + n \lg n</script>，求 <script type="math/tex">T(n)</script> 的渐近解</p><p><strong>解：</strong>由 <script type="math/tex">\frac{2}{4^p} + \frac{3}{6^p} = 1</script> 可知 <script type="math/tex">p = 1</script></p><p>故由Akra-Bazzi定理可知</p><script type="math/tex; mode=display">\begin{aligned}T(n) &= \Theta \left(n \left(1 + \int_1^n \frac{x \lg x}{x^2} dx\right)\right) \\&=\Theta \left(n \left(1 + \frac{1}{2}\lg^2 n \right)\right) \\&=\Theta \left(n \lg^2 n \right)\end{aligned}</script><p><strong>Example2:</strong> 设 <script type="math/tex">T(n) = 3T \left( \frac{n}{3}\right) + \frac{n}{\lg n}</script>（<script type="math/tex">n \geq 2</script>），求 <script type="math/tex">T(n)</script> 的渐近解</p><p><strong>解：</strong>由 <script type="math/tex">\left(\frac{3}{3}\right)^p = 1</script> 可知 <script type="math/tex">p = 1</script></p><p>故由Akra-Bazzi定理可知</p><script type="math/tex; mode=display">\begin{aligned}T(n) &= \Theta \left(n \left( 1 + \int_2^n \frac{\frac{x}{\lg x}}{x^2} dx\right)\right) \\&=\Theta \left(n \left( 1 + \int_2^n \frac{1}{x \lg x} dx\right)\right) \\&=\Theta \left(n \left( 1 + \lg \lg n \right) \right) \\&=\Theta(n \lg \lg n)\end{aligned}</script><p><strong>Example3:</strong> 设 <script type="math/tex">T(n) = \frac{1}{2} T \left( \frac{n}{2} \right) + \frac{1}{n}</script>，求 <script type="math/tex">T(n)</script> 的渐近解</p><p>解：由 <script type="math/tex">\frac{1}{2} \cdot \left(\frac{1}{2}\right)^p = 1</script> 可知 <script type="math/tex">p = -1</script></p><p>故由Akra-Bazzi定理可知</p><script type="math/tex; mode=display">\begin{aligned}T(n) &= \Theta \left(n^{-1} \left( 1 + \int_1^n \frac{\frac{1}{x}}{x^0} dx \right)\right) \\&= \Theta(\left(n^{-1} \left(1 + \ln n \right) \right) \\&= \Theta \left(\frac{\ln n}{n}\right)\end{aligned}</script></blockquote><h2 id="Akra-Bazzi定理的证明"><a href="#Akra-Bazzi定理的证明" class="headerlink" title="Akra-Bazzi定理的证明"></a>Akra-Bazzi定理的证明</h2><p>Akra-Bazzi的原始论文中使用了一种称为<strong>阶变换（Order Transform）</strong>的技巧来导出Akra-Bazzi定理，但完整过程篇幅较长且较为复杂。在已经知道结论的情况下，我们还可以使用数学归纳法来证明Akra-Bazzi定理，这种方法更加简洁且相对容易理解。</p><p>首先我们证明一个引理</p><blockquote><p><strong>Lemma:</strong> 若 <script type="math/tex">g(x)</script> 为一非负函数且满足多项式增长条件，则存在 <script type="math/tex">c_3, c_4 > 0</script>，使得对任意 <script type="math/tex">x \geq 1, 1 \leq i \leq k</script>，有</p><script type="math/tex; mode=display">c_3 g(x) \leq x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du \leq c_4 g(x)</script><p><strong>证明：</strong> <script type="math/tex">g(x)</script> 满足多项式增长条件，即存在正常数 <script type="math/tex">c_1, c_2</script> 使得对任意 <script type="math/tex">x \geq 1, 1 \leq i \leq k, u \in [b_i x , x]</script>，均有 <script type="math/tex">c_1 g(x) \leq g(u) \leq c_2 g(x)</script> </p><p>故</p><script type="math/tex; mode=display">\begin{aligned}x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du &\leq c_2 x^p g(x) \cdot \int_{b_i x}^x \frac{1}{u^{p + 1}} du \\&\leq c_2 x^p g(x) \cdot (x - b_i x) \cdot \max \{ \frac{1}{(b_i x)^{p+1}}, \frac{1}{x^{p+1}}\} \\&=c_2 \cdot (1-b_i) \cdot \max \{\frac{1}{b_i^{p+1}}, 1 \} \cdot g(x)\end{aligned}</script><p>因此仅需令 <script type="math/tex">c_4 \geq c_2 \cdot (1-b_i) \cdot \max \{\frac{1}{b_i^{p+1}}, 1 \}</script>，就有 <script type="math/tex">x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du \leq c_4 g(x)</script></p><p>同理，令 <script type="math/tex">c_3 \leq c_2 \cdot (1-b_i) \cdot \min \{\frac{1}{b_i^{p+1}}, 1 \}</script>，就有 <script type="math/tex">x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du \geq c_3 g(x)</script></p><p>故原命题成立</p></blockquote><p>下面我们使用数学归纳法证明存在 <script type="math/tex">c_5>0, x_1 > 1</script>，使得对任意 <script type="math/tex">x > x_1</script>，有 <script type="math/tex">T(x) \geq c_5 \cdot x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)</script></p><p>由于 <script type="math/tex">T(x)</script> 的取值范围包含大于1的一切实数，我们不能直接对 <script type="math/tex">x</script> 进行归纳。</p><p>为了使用数学归纳法，我们令 <script type="math/tex">I_0 = [1, X_0], I_1 = (X_0+1, X_0+2], ..., I_j = (X_0 + j -1, X_0 + j]</script>。易见 <script type="math/tex">x</script> 必然落在某一个区间 <script type="math/tex">j_0</script> 内，且 <script type="math/tex">b_i x</script> 必然落在 <script type="math/tex">j_0</script> 前面的某一区间内，因此我们可以对 <script type="math/tex">I_j</script> 进行归纳。</p><p>当 <script type="math/tex">j=0</script> 时，由定义可知 <script type="math/tex">T(x) = \Theta(1)</script>，结论显然成立</p><p>若结论对任意 <script type="math/tex">j < j_0</script> 均成立，则当 <script type="math/tex">j=j_0</script> 时，有</p><script type="math/tex; mode=display">\begin{aligned}T(x) &= \sum_\limits{i = 1}^k a_i T(b_i x) +g(x) \\&\geq \sum_\limits{i = 1}^k a_i \cdot c_5 \cdot (b_i x)^p \left( 1 + \int_1^{b_i x} \frac{g(u)}{u^{p+1}} du\right) +g(x) \\&=c_5 x ^p \sum_\limits{i = 1}^k a_i \cdot b_i^p \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du - \int_{b_i x}^{x} \frac{g(u)}{u^{p+1}} du\right) +g(x) \\&\geq c_5 x ^p \cdot \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du - \frac{c_4}{x_p}g(x)\right) \cdot \sum_\limits{i = 1}^k a_i b_i^p +g(x) \\&=c_5 x ^p \cdot \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du - \frac{c_4}{x_p}g(x)\right) +g(x) \\&=c_5 x ^p \cdot \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du \right) - (c_4c_5 - 1) g(x)\end{aligned}</script><p>因此，只需令 <script type="math/tex">c_5 \leq \frac{1}{c_4}</script>，就有 <script type="math/tex">T(x) \geq c_5 \cdot x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)</script> 成立</p><p>即 <script type="math/tex">T(x) = \Omega \left( x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right) \right)</script></p><p>同理可证得  <script type="math/tex">T(x) = \mathcal{O} \left( x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right) \right)</script></p><p>由此我们便证得了最终的结论 <script type="math/tex">T(x) = \Theta \left(x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\right)</script></p><h2 id="推广的Akra-Bazzi定理"><a href="#推广的Akra-Bazzi定理" class="headerlink" title="推广的Akra-Bazzi定理"></a>推广的Akra-Bazzi定理</h2><p>事实上，<strong>Tom Leighton</strong>还给出过一个更一般形式的Akra-Bazzi推广定理</p><blockquote><p><strong>Definition（推广的多项式增长条件）:</strong> 设 <script type="math/tex">g(x),h(x)</script> 均为定义在非负实数上的函数，<script type="math/tex">\{b_k\}</script> 为一个含有 <script type="math/tex">k</script> 项的数列且满足 <script type="math/tex">0 < b_i< 1</script>，若存在正常数 <script type="math/tex">c_1, c_2</script> 使得对任意 <script type="math/tex">x \geq 1, 1 \leq i \leq k, u \in [b_i x + h_i(x), x]</script>，均有 <script type="math/tex">c_1 g(x) \leq g(u) \leq c_2 g(x)</script> ，则称 <script type="math/tex">g(x)</script> 满足多项式增长条件</p><p><strong>Theorem:</strong> 设 <script type="math/tex">g(x)</script> 为一非负函数， <script type="math/tex">T(x) = \left\{ \begin{aligned} &\Theta(1)&, &1 \leq x \leq X_0 \\ &\sum_\limits{i = 1}^k a_i T(b_i x + h_i(x)) +g(x)&, &x > X_0 \end{aligned}\right.</script>，若满足以下四个条件：</p><p>(1) <script type="math/tex">k \geq 1</script>，对任意 <script type="math/tex">1 \leq i \leq k</script>，有 <script type="math/tex">a_i > 0, 0 < b_i < 1</script></p><p>(2) <script type="math/tex">X_0</script> 为一足够大的常数，使得存在 <script type="math/tex">\varepsilon > 0</script>，对任意 <script type="math/tex">1 \leq i \leq k, x \geq X_0</script>，满足以下四个条件：</p><script type="math/tex; mode=display">\begin{aligned}&(a) \left( 1 - \frac{1}{b_i \lg^{1+\varepsilon} x} \right)^p \left( 1 + \frac{1}{\lg^{\frac{\varepsilon}{2}} \left( b_i x + \frac{x}{\lg^{1+\varepsilon} x}\right)} \right) \geq 1+ \frac{1}{\lg^{\frac{\varepsilon}{2}} x} \\&(b) \left( 1 + \frac{1}{b_i \lg^{1+\varepsilon} x} \right)^p \left( 1 - \frac{1}{\lg^{\frac{\varepsilon}{2}} \left( b_i x + \frac{x}{\lg^{1+\varepsilon} x}\right)} \right) \leq 1- \frac{1}{\lg^{\frac{\varepsilon}{2}} x} \\&(c) \frac{1}{2} \left( 1 + \frac{1}{\lg^{\frac{\varepsilon}{2}} x}\right) \leq 1 \\&(d) 2 \left( 1 - \frac{1}{\lg^{\frac{\varepsilon}{2}} x} \right) \geq 1\end{aligned}</script><p>(3) 存在 <script type="math/tex">\varepsilon > 0</script> 使得对任意 <script type="math/tex">1 \leq i \leq k, x > X_0</script>，均有 <script type="math/tex">|h_i(x)| \leq \frac{x}{\lg^{1+\varepsilon} x}</script></p><p>(4) <script type="math/tex">g(x)</script> 满足多项式增长条件</p><p>若设 <script type="math/tex">p</script> 为方程 <script type="math/tex">\sum_\limits{i = 1}^k a_i b_i^p = 1</script> 的实数解，则</p><script type="math/tex; mode=display">\begin{aligned}T(x) &= \Theta \left(x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\right)\end{aligned}</script></blockquote><p>该定理在Akra-Bazzi的基础上，进一步考虑了递归式参数中带余项的情况，因此适用面更广。与Akra-Bazzi类似，其正确性同样可以使用数学归纳法验证，不过篇幅较长，这里就不详细阐述了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;主方法&quot;&gt;&lt;a href=&quot;#主方法&quot; class=&quot;headerlink&quot; title=&quot;主方法&quot;&gt;&lt;/a&gt;主方法&lt;/h2&gt;&lt;p&gt;在算法分析中，当我们使用分治法求解问题时，通常会遇到以递归式定义的算法运行时间函数。要得到此类算法的时间复杂度，就必须求出该递归式的渐近表达式。通常情况下，我们可以通过如下公式直接得到大部分不太复杂的递归式的渐近解。&lt;strong&gt;《算法导论》&lt;/strong&gt;一书中将该方法称为&lt;strong&gt;“主方法”&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.github.io/blog/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.github.io/blog/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数的相关算法</title>
    <link href="http://gonggongjohn.github.io/blog/2020/10/30/fibonacci/"/>
    <id>http://gonggongjohn.github.io/blog/2020/10/30/fibonacci/</id>
    <published>2020-10-30T15:29:04.000Z</published>
    <updated>2020-10-31T06:12:06.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>斐波那契数列由以下递推式定义：</p><script type="math/tex; mode=display">\left\{\begin{aligned}&F(0)=0 \\&F(1)=1 \\&F(n)=F(n-1)+F(n-2),n \geq 2\end{aligned}\right.</script><a id="more"></a><p>下面我们来推导斐波那契数列的通项公式</p><p>设矩阵 <script type="math/tex">M=\begin{pmatrix} m_{11} & m_{12} \\ m_{21} & m_{22} \end{pmatrix}</script>，使得 <script type="math/tex">\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix} =M \begin{pmatrix} F_{n} \\ F_{n-1} \end{pmatrix}</script></p><p>故</p><script type="math/tex; mode=display">\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}=\begin{pmatrix}m_{11} & m_{12} \\m_{21} & m_{22}\end{pmatrix}\begin{pmatrix}F_{n} \\F_{n-1}\end{pmatrix}=\begin{pmatrix}m_{11}F_{n}+m_{12}F_{n-1} \\m_{21}F_{n}+m_{22}F_{n-1}\end{pmatrix}</script><p>对比等式左右可得 <script type="math/tex">m_{11}=m_{12}=m_{21}=1,m_{22}=0</script>，即 <script type="math/tex">M=\begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}</script></p><p>由此可知</p><script type="math/tex; mode=display">\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}=\begin{pmatrix}1 & 1 \\1 & 0\end{pmatrix}\begin{pmatrix}F_{n} \\F_{n-1}\end{pmatrix}</script><p>对该矩阵等式做递推，可得</p><script type="math/tex; mode=display">\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}=\begin{pmatrix}1 & 1 \\1 & 0\end{pmatrix}^n\begin{pmatrix}F_{1} \\F_{0}\end{pmatrix}=\begin{pmatrix}1 & 1 \\1 & 0\end{pmatrix}^n\begin{pmatrix}1 \\0\end{pmatrix}</script><p>易知 <script type="math/tex">\begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}</script> 的特征多项式 <script type="math/tex">f(\lambda) = \begin{vmatrix} \lambda - 1 & -1 \\ -1 & \lambda \end{vmatrix} = \lambda^2 - \lambda - 1</script></p><p>令 <script type="math/tex">f(\lambda) = 0</script>，可得该矩阵的特征值 <script type="math/tex">\lambda_1 = \frac{1 - \sqrt{5}}{2}, \lambda_2 = \frac{1 + \sqrt{5}}{2}</script></p><p>由此可知该矩阵可相似对角化</p><p>对于 <script type="math/tex">\lambda_1 = \frac{1-\sqrt{5}}{2}</script>，其对应的特征向量 <script type="math/tex">\alpha_1 = \left(\frac{1-\sqrt{5}}{2},1\right)</script></p><p>对于 <script type="math/tex">\lambda_2 = \frac{1+\sqrt{5}}{2}</script>，其对应的特征向量 <script type="math/tex">\alpha_2 = \left(\frac{1+\sqrt{5}}{2},1\right)</script></p><p>故若令 <script type="math/tex">P=\begin{pmatrix} \frac{1-\sqrt{5}}{2} & \frac{1+\sqrt{5}}{2} \\ 1 & 1 \end{pmatrix}</script>，则</p><script type="math/tex; mode=display">\begin{pmatrix}1 & 1 \\1 & 0\end{pmatrix}=P\begin{pmatrix}\frac{1-\sqrt{5}}{2} & 0\\ 0 & \frac{1+\sqrt{5}}{2}\end{pmatrix}P^{-1}</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}&=P\begin{pmatrix}\frac{1-\sqrt{5}}{2} & 0\\ 0 & \frac{1+\sqrt{5}}{2}\end{pmatrix}^nP^{-1}\begin{pmatrix}1 \\0\end{pmatrix} \\&=\begin{pmatrix}\frac{1-\sqrt{5}}{2} & \frac{1+\sqrt{5}}{2} \\1 & 1\end{pmatrix}\begin{pmatrix}\left(\frac{1-\sqrt{5}}{2}\right)^n & 0\\ 0 & \left(\frac{1+\sqrt{5}}{2}\right)^n\end{pmatrix}\begin{pmatrix}-\frac{1}{\sqrt{5}} & \frac{5 + \sqrt{5}}{10} \\\frac{1}{\sqrt{5}} & \frac{5 - \sqrt{5}}{10}\end{pmatrix}\begin{pmatrix}1 \\0\end{pmatrix} \\&=\begin{pmatrix}\frac{1-\sqrt{5}}{2} & \frac{1+\sqrt{5}}{2} \\1 & 1\end{pmatrix}\begin{pmatrix}-\frac{1}{\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n \\\frac{1}{\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^n\end{pmatrix} \\&=\begin{pmatrix}\frac{\sqrt{5}-1}{2\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n + \frac{\sqrt{5}+1}{2\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^n \\-\frac{1}{\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n + \frac{1}{\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^n\end{pmatrix}\end{aligned}</script><p>由此我们得到了斐波那契数列的通项公式</p><script type="math/tex; mode=display">F_n = \frac{1}{\sqrt{5}} \left[\left(\frac{1+\sqrt{5}}{2}\right)^n - \left(\frac{1-\sqrt{5}}{2}\right)^n \right]</script><h2 id="朴素递归算法"><a href="#朴素递归算法" class="headerlink" title="朴素递归算法"></a>朴素递归算法</h2><p>朴素递归算法即为递推式定义的程序表达，采用递归的方法实现。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易得该算法时间复杂度的递推表达式为 <script type="math/tex">T(n)=T(n-1)+T(n-2)+\Theta(1)</script></p><p>观察递归树可以发现，所有叶子结点的和就是 <script type="math/tex">\Theta(F_n)</script> ，而所有内部节点的和为 <script type="math/tex">\Theta(F_n-1)</script></p><p>故朴素递归算法的时间复杂度 </p><script type="math/tex; mode=display">\begin{aligned}T(n)&=\Theta(F_n) + \Theta(F_n-1) \\&=\Theta(F_n) \\&=\Theta\left(\left(\frac{1+\sqrt{5}}{2}\right)^n\right) \\&=\mathcal{O}(1.62^n)\end{aligned}</script><h2 id="自下而上算法"><a href="#自下而上算法" class="headerlink" title="自下而上算法"></a>自下而上算法</h2><p>朴素递归算法的时间复杂度为指数级，这显然是难以接受的。观察发现朴素递归算法的主要问题是重复求解了许多子问题，其本质原因在于朴素递归算法是自上而下的求解子问题，而不同子问题中重叠的部分无法相互影响。故我们换一种思路，自下而上的求解，就可以很好的解决这一问题。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[N]; <span class="comment">//N is the biggest possible value</span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易知该算法的时间复杂度 <script type="math/tex">T(n)=n-1=\Theta(n)</script></p><h2 id="矩阵快速幂算法"><a href="#矩阵快速幂算法" class="headerlink" title="矩阵快速幂算法"></a>矩阵快速幂算法</h2><p>自下而上算法已经将原本的指数级时间复杂度降低到了多项式级，我们希望能够进一步的将其降低到对数级别。自然的，我们首先想到的是利用其通项公式并通过快速幂的方法来求解。但斐波那契数列的通项公式中包含无理数，由于计算机的精度限制，计算结果可能并不正确，故这种方法显然是不可靠的。</p><p><strong>注：</strong>事实上，若不存在精度限制的问题，斐波那契数列还可以表示为 <script type="math/tex">F_n = \left[ \left(\frac{1+\sqrt{5}}{2}\right)^n \right]</script> （其中 <script type="math/tex">[x]</script> 表示取整到离 <script type="math/tex">x</script> 最近的整数）</p><p>于是问题转化为是否存在一个仅需在整数域内进行运算的斐波那契通项公式。回顾上面求解斐波那契数列通项公式的过程，注意到 <script type="math/tex">\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix} = \begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}^n \begin{pmatrix} 1 \\ 0 \end{pmatrix}</script>，故我们可以通过求解该矩阵来得到 <script type="math/tex">F_n</script> 的值。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    matrix(<span class="keyword">int</span> a11, <span class="keyword">int</span> a12, <span class="keyword">int</span> a21, <span class="keyword">int</span> a22)&#123;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">0</span>] = a11;</span><br><span class="line">        a[<span class="number">0</span>][<span class="number">1</span>] = a12;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">0</span>] = a21;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>] = a22;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//This function can only handle 2*2 matrix multiplication</span></span><br><span class="line"><span class="function">matrix <span class="title">matrixMult</span><span class="params">(matrix matA, matrix matB)</span></span>&#123;</span><br><span class="line">    <span class="function">matrix <span class="title">matR</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">                matR.a[i][j] += matA.a[i][k] * matB.a[k][j];</span><br><span class="line">    <span class="keyword">return</span> matR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">matrixPow</span><span class="params">(matrix mat, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> mat;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        matrix matT = matrixPow(mat, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> matrixMult(matT, matT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        matrix matT1 = matrixPow(mat, (n - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        matrix matT2 = matrixMult(matT1, matT1);</span><br><span class="line">        <span class="keyword">return</span> matrixMult(matT2, mat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        matrix matT(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        matrix matR = matrixPow(matT, n);</span><br><span class="line">        <span class="keyword">return</span> matR.a[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析该算法，发现其时间复杂度的递推表达式为 <script type="math/tex">T(n) = T\left(\frac{n}{2}\right) + \Theta(1)</script>。故由主定理可知该矩阵快速幂算法的时间复杂度为 <script type="math/tex">T(n) = \Theta(\lg n)</script></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h2&gt;&lt;p&gt;斐波那契数列由以下递推式定义：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\left\{
\begin{aligned}
&amp;F(0)=0 \\
&amp;F(1)=1 \\
&amp;F(n)=F(n-1)+F(n-2),n \geq 2
\end{aligned}
\right.&lt;/script&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.github.io/blog/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.github.io/blog/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>和式的求解方法</title>
    <link href="http://gonggongjohn.github.io/blog/2020/10/11/sum-solve/"/>
    <id>http://gonggongjohn.github.io/blog/2020/10/11/sum-solve/</id>
    <published>2020-10-11T12:40:02.000Z</published>
    <updated>2020-10-11T12:44:47.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扰动法"><a href="#扰动法" class="headerlink" title="扰动法"></a>扰动法</h2><p>扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。</p><a id="more"></a><p>令 <script type="math/tex">S_n = \sum_\limits{0 \leq k \leq n} a_k</script></p><script type="math/tex; mode=display">\begin{aligned}S_n + a_{n+1} &= \sum_\limits{0 \leq k \leq n+1} a_k \\&= a_0 + \sum_\limits{1 \leq k \leq n+1} a_k \\&= a_0 + \sum_\limits{1 \leq k+1 \leq n+1} a_{k+1} \\&= a_0 + \sum_\limits{0 \leq k \leq n} a_{k+1}\end{aligned}</script><p>若能将 <script type="math/tex">\sum_\limits{0 \leq k \leq n} a_{k+1}</script> 写为 <script type="math/tex">S_n</script> 的表达式，即可求出该求和式的通项公式</p><blockquote><p><strong>Example1:</strong></p><p>求等比数列和 <script type="math/tex">S_n = \sum_\limits{0 \leq k \leq n} a q^k \ \ (q \neq 1)</script> 的通项公式</p><p><strong>解：</strong> 由上述公式可知</p><script type="math/tex; mode=display">\begin{aligned}S_n + a_{n+1} &= a + \sum_\limits{0 \leq k \leq n} aq^{k+1} \\&=a + q \sum_\limits{0 \leq k \leq n} aq^k \\&=a + q S_n\end{aligned}</script><p>从而 $(1-q)S_n = a - aq^{n+1}$</p><p>故 $S_n = \frac{a\left(1-q^{n+1} \right)}{1-q} \ \ (q \neq 1)$</p><p><strong>Example2:</strong></p><p>求等比差数列和 <script type="math/tex">S_n = \sum_\limits{0 \leq k \leq n} k \cdot q^k \ \ (q \neq 1)</script> 的通项公式</p><p><strong>解：</strong> 由上述公式可知</p><script type="math/tex; mode=display">\begin{aligned}S_n + a_{n+1} &= 0 + \sum_\limits{0 \leq k \leq n} (k+1) \cdot q^{k+1} \\&=\sum_\limits{0 \leq k \leq n} k \cdot q^{k+1} + \sum_\limits{0 \leq k \leq n} q^{k+1} \\&=q \sum_\limits{0 \leq k \leq n} k \cdot q^k + q \sum_\limits{0 \leq k \leq n} q^k \\&=q S_n + q \cdot \frac{1-q^{n+1}}{1-q}\end{aligned}</script><p>从而 $(1-q)S_n = \frac{q-q^{n+2}}{1-q} - (n+1) \cdot q^{n+1}$</p><p>故 </p><script type="math/tex; mode=display">\begin{aligned}S_n &= \frac{q-q^{n+2}}{(1-q)^2} - \frac{(n+1) \cdot q^{n+1}}{1-q} \\&= \frac{q-(n+1)q^{n+1} + nq^{n+2}}{(1-q)^2} \ \ (q \neq 1)\end{aligned}</script></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;扰动法&quot;&gt;&lt;a href=&quot;#扰动法&quot; class=&quot;headerlink&quot; title=&quot;扰动法&quot;&gt;&lt;/a&gt;扰动法&lt;/h2&gt;&lt;p&gt;扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Sequence" scheme="http://gonggongjohn.github.io/blog/tags/Sequence/"/>
    
  </entry>
  
  <entry>
    <title>递归式的解法</title>
    <link href="http://gonggongjohn.github.io/blog/2020/10/11/recursion-solve/"/>
    <id>http://gonggongjohn.github.io/blog/2020/10/11/recursion-solve/</id>
    <published>2020-10-11T12:39:48.000Z</published>
    <updated>2020-10-11T12:52:00.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="求和因子法"><a href="#求和因子法" class="headerlink" title="求和因子法"></a>求和因子法</h2><p>对于形如 <script type="math/tex">a_n T_n = b_n T_{n-1} + c_n</script>，我们可以求出其通项公式，下面我们来推导这一公式。</p><p>我们考虑通过变量替换的方式将 <script type="math/tex">T_n</script> 前的 <script type="math/tex">a_n</script> 和 <script type="math/tex">b_n</script> 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 <script type="math/tex">b_n T_{n-1}</script> 能够通过 <script type="math/tex">a_n T_n</script> 表示出来（该表达式通常被称为求和因子）。设该表达式为 <script type="math/tex">s_n</script>，两边同乘以 <script type="math/tex">s_n</script>，即为 <script type="math/tex">s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n</script></p><a id="more"></a><p>注意到等式左边均为第 $n$ 项，而右边为 <script type="math/tex">T_{n-1}</script>，故考虑将右边第一项变为 <script type="math/tex">s_{n-1}a_{n-1}T_{n-1}</script>。要做到这一点，就是要让 <script type="math/tex">s_n b_n = s_{n-1} a_{n-1}</script>，也即 <script type="math/tex">s_n = s_{n-1} \cdot \frac{a_{n-1}}{b_n}</script>。做递推，得到 <script type="math/tex">s_n = \frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2} \cdot s_1</script>。故仅需取 <script type="math/tex">s_n = \frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2}</script> 或该式的常数倍即可。</p><p>现在，我们仅需令 <script type="math/tex">P_n = s_n a_n T_n</script>，即可将原式化简为 <script type="math/tex">P_n = P_{n-1} + s_n c_n</script></p><p>故 <script type="math/tex">P_n = P_0 + \sum_\limits{k=1}^n s_k c_k</script></p><p>故 <script type="math/tex">s_n a_n T_n = s_0 a_0 T_0 + \sum_\limits{k=1}^n s_kc_k = s_1b_1T_0 + \sum_\limits{k=1}^n s_kc_k</script></p><p>故 <script type="math/tex">T_n = \frac{1}{s_n a_n} \left( s_1b_1T_0 + \sum_\limits{k=1}^n s_kc_k \right)</script></p><blockquote><p>Example:</p><p>已知Hanoi问题满足以下递归表达式，试求出其通项公式</p><script type="math/tex; mode=display">\left\{\begin{aligned}&T_0 = 0 \\&T_n = 2T_{n-1} + 1\end{aligned}\right.</script><p><strong>解：</strong> 由 $a_n = 1, b_n = 2$ 可知求和因子 $s_n = \frac{1}{2^{n-1}}$。由于 $s_n$ 乘以常数倍不影响其效果 ，故为了方便起见令 $s_n = \frac{1}{2^n}$</p><p>两边同乘以 <script type="math/tex">s_n = \frac{1}{2^n}</script>，得到 <script type="math/tex">\frac{T_n}{2^n} = \frac{T_{n-1}}{2^{n-1}} + \frac{1}{2^n}</script></p><p>令$P_n = \frac{T_n}{2^n}$，则 </p><script type="math/tex; mode=display">\left\{\begin{aligned}&P_n = P_{n-1} + \frac{1}{2^n} \\&P_0 = 0\end{aligned}\right.</script><p>故 <script type="math/tex">P_n = \sum_\limits{k=1}^n \frac{1}{2^k} = 1-\left(\frac{1}{2}\right)^n</script>，即 <script type="math/tex">\frac{T_n}{2^n} = 1-\left(\frac{1}{2}\right)^n</script></p><p>故 <script type="math/tex">T_n = 2^n - 1</script></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;求和因子法&quot;&gt;&lt;a href=&quot;#求和因子法&quot; class=&quot;headerlink&quot; title=&quot;求和因子法&quot;&gt;&lt;/a&gt;求和因子法&lt;/h2&gt;&lt;p&gt;对于形如 &lt;script type=&quot;math/tex&quot;&gt;a_n T_n = b_n T_{n-1} + c_n&lt;/script&gt;，我们可以求出其通项公式，下面我们来推导这一公式。&lt;/p&gt;
&lt;p&gt;我们考虑通过变量替换的方式将 &lt;script type=&quot;math/tex&quot;&gt;T_n&lt;/script&gt; 前的 &lt;script type=&quot;math/tex&quot;&gt;a_n&lt;/script&gt; 和 &lt;script type=&quot;math/tex&quot;&gt;b_n&lt;/script&gt; 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 &lt;script type=&quot;math/tex&quot;&gt;b_n T_{n-1}&lt;/script&gt; 能够通过 &lt;script type=&quot;math/tex&quot;&gt;a_n T_n&lt;/script&gt; 表示出来（该表达式通常被称为求和因子）。设该表达式为 &lt;script type=&quot;math/tex&quot;&gt;s_n&lt;/script&gt;，两边同乘以 &lt;script type=&quot;math/tex&quot;&gt;s_n&lt;/script&gt;，即为 &lt;script type=&quot;math/tex&quot;&gt;s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n&lt;/script&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Sequence" scheme="http://gonggongjohn.github.io/blog/tags/Sequence/"/>
    
  </entry>
  
  <entry>
    <title>快速排序时间复杂度分析</title>
    <link href="http://gonggongjohn.github.io/blog/2020/10/10/qsort-analyze/"/>
    <id>http://gonggongjohn.github.io/blog/2020/10/10/qsort-analyze/</id>
    <published>2020-10-10T07:46:07.000Z</published>
    <updated>2020-11-01T06:42:51.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="随机化快速排序"><a href="#随机化快速排序" class="headerlink" title="随机化快速排序"></a>随机化快速排序</h2><p>随机化快速排序在快速排序的基础上，通过随机数选择一个数作为pivot，使得没有特定的输入数据可以使得该算法达到最坏情况。</p><p>下面我们来分析其平均时间复杂度。</p><a id="more"></a><p>设 <script type="math/tex">X_k</script> 为一个随机变量，使得对任意 <script type="math/tex">k=0,1,...,n-1</script>，有</p><script type="math/tex; mode=display">X_k = \left\{\begin{aligned}1 &, &if \ Partition \ generates \ (k:n-k-1) \ split \\0 &, &otherwise\end{aligned}\right.</script><p>若随机数生成每个数的概率相同，则</p><script type="math/tex; mode=display">\begin{aligned}E[X_k] &= 0 \cdot \Pr \{X_k = 0\} + 1 \cdot \Pr \{X_k = 1\} \\&=\Pr\{X_k = 1\} \\&=\frac{1}{n}\end{aligned}</script><p>设 <script type="math/tex">T(n)</script> 为一个代表总运行时间的随机变量（假设所有的情况均为独立的）</p><p>即</p><script type="math/tex; mode=display">T(n) = \left\{\begin{aligned}T(0) + T(n-1) + \Theta(n) &, &if \ Partition \ generates \ (0:n-1) \ split \\T(1) + T(n-2) + \Theta(n) &, &if \ Partition \ generates \ (1:n-2) \ split \\...... \\T(n-1) + T(0) + \Theta(n) &, &if \ Partition \ generates \ (n-1:0) \ split\end{aligned}\right.</script><p>通过引入 <script type="math/tex">X_k</script>，我们可以把 <script type="math/tex">T(n)</script> 改写为一个和式</p><script type="math/tex; mode=display">T(n) = \sum_\limits{k=0}^{n-1} X_k \left( T(k) + T(n-k-1) + \Theta(n) \right)</script><p>故</p><script type="math/tex; mode=display">\begin{aligned}E[T(n)] &= E \left[\sum_\limits{k=0}^{n-1} X_k \left( T(k) + T(n-k-1) + \Theta(n) \right) \right] \\&=\sum_\limits{k=0}^{n-1} E \left[ X_k \left( T(k) + T(n-k-1) + \Theta(n) \right) \right] \\&=\sum_\limits{k=0}^{n-1} E \left[ X_k \right] \cdot E\left[ \left( T(k) + T(n-k-1) + \Theta(n)\right) \right] \\&=\frac{1}{n} \sum_\limits{k=0}^{n-1} E[T(k)] + \frac{1}{n} \sum_\limits{k=0}^{n-1} E[T(n-k-1)] + \frac{1}{n} \sum_\limits{k=0}^{n-1} E[\Theta(n)] \\&=\frac{2}{n} \sum_\limits{k=0}^{n-1} E[T(k)] + \Theta(n)\end{aligned}</script><p>由此我们得到了一个关于 <script type="math/tex">E[T(n)]</script> 的递推式。下面我们使用<strong>第二数学归纳法</strong>证明：当 <script type="math/tex">n \geq 3</script> 时，存在 <script type="math/tex">a>0</script>，使得 <script type="math/tex">E[T(n)] \leq an \lg n</script></p><p>为了方便起见，我们首先对原式进行适当变形</p><script type="math/tex; mode=display">\begin{aligned}E[T(n)] &=\frac{2}{n} \sum_\limits{k=0}^{n-1} E[T(k)] + \Theta(n) \\&=\frac{2}{n}E[T(0)] + \frac{2}{n}E[T(1)] + \frac{2}{n} \sum_\limits{k=2}^{n-1} E[T(k)] + \Theta(n) \\&=\frac{2}{n} \sum_\limits{k=2}^{n-1} E[T(k)] + \Theta(n)\end{aligned}</script><p>随后，我们需要一个引理</p><blockquote><p>Lemma:</p><script type="math/tex; mode=display">\sum_\limits{k=2}^{n-1} k \lg k \leq \frac{1}{2}n^2 \lg n - \frac{1}{8} n^2</script><p>证明：令 <script type="math/tex">f(x) = x \lg x</script></p><p>则 <script type="math/tex">f'(x) = \lg k + \frac{1}{\ln 2}</script></p><p>故当 <script type="math/tex">x \geq 2</script> 时 <script type="math/tex">f(x)>0</script> 且 <script type="math/tex">f(x)</script> 单调递增</p><p>因此</p><script type="math/tex; mode=display">\begin{aligned}\sum_\limits{k=2}^{n-1} k \lg k &\leq \int_2^n x \lg x dx \\&=\frac{1}{2} \int_2^n \lg x d(x^2) \\&=\frac{1}{2} \left(\left[x^2 \lg x\right]\Big|_2^n - \int_2^n x^2 \cdot \frac{1}{x \ln 2} dx\right) \\&=\frac{1}{2} \left( n^2 \lg n - 4 - \frac{1}{2 \ln 2} \cdot \left[x^2\right]\Big|_2^n\right) \\&=\frac{1}{2}n^2 \lg n - \frac{1}{4 \ln 2}n^2 -2 + \frac{1}{\ln 2} \\&\leq \frac{1}{2}n^2 \lg n -\frac{1}{4\ln2}n^2 \\&\leq \frac{1}{2}n^2 \lg n - \frac{1}{8}n^2\end{aligned}</script></blockquote><p>现在就可以对 <script type="math/tex">n</script> 进行归纳了</p><p>当 <script type="math/tex">n=3</script> 时，<script type="math/tex">E[T(3)]=\Theta(1)</script>，仅需取一足够大的 <script type="math/tex">a</script>，则结论显然成立</p><p>若对 <script type="math/tex">\forall k < n</script>，存在 <script type="math/tex">a>0</script> 使得 <script type="math/tex">E[T(n)] \leq ak \lg k</script> 成立</p><p>则</p><script type="math/tex; mode=display">\begin{aligned}E[T(n)] &\leq \frac{2}{n} \sum_\limits{k=2}^{n-1} ak \lg k + \Theta(n) \\&\leq \frac{2a}{n} \cdot \left( \frac{1}{2}n^2 \lg n - \frac{1}{8}n^2\right) + \Theta(n) \\&=an \lg n - \frac{an}{4} + \Theta(n)\end{aligned}</script><p>故仅需取一足够大的 <script type="math/tex">a</script> 使得 <script type="math/tex">\frac{an}{4}> \Theta(n)</script>，即可使得 <script type="math/tex">E[T(n)] \leq an \lg n</script></p><p>因此 <script type="math/tex">E[T(n)] \leq an \lg n</script> 对 <script type="math/tex">\forall n \geq 3</script> 均成立</p><p>由此可知 <script type="math/tex">E[T(n)] = \mathcal{O}(n \lg n)</script></p><p>同理可得 <script type="math/tex">E[T(n)] = \Omega(n\lg n)</script></p><p>故 <script type="math/tex">E[T(n)] = \Theta(n \lg n)</script></p><p>事实上，原始的快速排序中Partition的操作次数为 <script type="math/tex">n+1</script> 次，故总运行时间的期望还可以进一步写成以下递推式</p><script type="math/tex; mode=display">\left\{\begin{aligned}&E[T(0)] = 0 \\&E[T(n)] = \frac{2}{n}\sum_\limits{k = 0}^{n-1} E[T(k)] + n+1 \ \ (n \geq 1)\end{aligned}\right.</script><p>下面我们来尝试推导该递推式的封闭解</p><p>首先将原式化简为整式，得到 <script type="math/tex">n \cdot E[T(n)] = 2 \sum_\limits{k=0}^{n-1} E[T(k)] + n^2+n</script></p><p>注意到等式右边有一个连续的求和式（即从 <script type="math/tex">E[T(0)]</script> 到 <script type="math/tex">E[T(n-1)]</script> 中没有缺项），故考虑做<strong>差项</strong>消去该求和式。</p><script type="math/tex; mode=display">\left\{\begin{aligned}&n \cdot E[T(n)] = 2 \sum_\limits{k=0}^{n-1} E[T(k)] + n^2+n \\&(n-1) \cdot E[T(n-1)] = 2 \sum_\limits{k=0}^{n-2} E[T(k)] + (n-1)^2+(n-1)\end{aligned}\right.</script><p>两式相减，得到 $n \cdot E[T(n)] - (n-1) \cdot E[T(n-1)] = 2n + 2 \cdot E[T(n-1)]$</p><p>化简得到 <script type="math/tex">n \cdot E[T(n)] = (n+1) \cdot E[T(n-1)] + 2n</script></p><p>接下来我们考虑将 <script type="math/tex">E[T(n)]</script> 和 <script type="math/tex">E[T(n-1)]</script> 前的系数消去以找出通项公式。</p><p>两边同时乘以 <script type="math/tex">\frac{2}{n(n+1)}</script> ，得到 <script type="math/tex">\frac{2}{n+1} \cdot E[T(n)] = \frac{2}{n} \cdot E[T(n-1)] + \frac{4}{n+1}</script></p><p>令 <script type="math/tex">S_n = \frac{2}{n+1} \cdot E[T(n)]</script>，于是原递归式化简为</p><script type="math/tex; mode=display">\left\{\begin{aligned}& S_0 = 0 \\& S_n = S_{n-1} + \frac{4}{n+1}\end{aligned}\right.</script><p>我们可以快速写出该递归式的通项公式 <script type="math/tex">S_n = 4\sum_\limits{k=2}^{n+1} \frac{1}{k}</script></p><p>即 $\frac{2}{n+1} \cdot E[T(n)] =  4\sum_\limits{k=2}^{n+1} \frac{1}{k}$</p><p>化简即得 $E[T(n)] = 2(n+1)\sum_\limits{k=2}^{n+1} \frac{1}{k}$</p><p>引入调和级数符号 $H_n = 1 + \frac{1}{2} + \frac{1}{3} + … + \frac{1}{n}$</p><p>注意到 $\sum_\limits{k=2}^{n+1} \frac{1}{k} = H_n - 1 + \frac{1}{n+1}$</p><p>故我们得到了原递推式的封闭解 <script type="math/tex">E[T(n)] = 2(n+1)H_n - 2n</script></p><p>又由 $H_n = \ln n + \gamma + \mathcal{O}\left(\frac{1}{n} \right)$</p><p>故可得</p><script type="math/tex; mode=display">\begin{aligned}E[T(n)] &= 2(n+1)\left(\ln n + \gamma + \mathcal{O} \left(\frac{1}{n} \right)\right) - 2n \\&= 2n \ln n + 2(\gamma - 1)n + 2\ln n + 2\gamma + \mathcal{O}(1) + \mathcal{O}\left(\frac{1}{n}\right) \\&= \Theta \left( n \ln n \right) \\&= \Theta \left( n \lg n\right)\end{aligned}</script><p>由此我们得到了快速排序的平均时间复杂度为 $\Theta (n \lg n)$</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;随机化快速排序&quot;&gt;&lt;a href=&quot;#随机化快速排序&quot; class=&quot;headerlink&quot; title=&quot;随机化快速排序&quot;&gt;&lt;/a&gt;随机化快速排序&lt;/h2&gt;&lt;p&gt;随机化快速排序在快速排序的基础上，通过随机数选择一个数作为pivot，使得没有特定的输入数据可以使得该算法达到最坏情况。&lt;/p&gt;
&lt;p&gt;下面我们来分析其平均时间复杂度。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.github.io/blog/tags/Computer-Science/"/>
    
    <category term="Algorithm" scheme="http://gonggongjohn.github.io/blog/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》笔记整理（一）</title>
    <link href="http://gonggongjohn.github.io/blog/2020/10/07/csapp-01/"/>
    <id>http://gonggongjohn.github.io/blog/2020/10/07/csapp-01/</id>
    <published>2020-10-07T14:31:17.000Z</published>
    <updated>2020-10-11T12:39:08.176Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Chapter-2：信息的表示和处理"><a href="#Chapter-2：信息的表示和处理" class="headerlink" title="Chapter 2：信息的表示和处理"></a>Chapter 2：信息的表示和处理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><h4 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h4><p><strong>定义：</strong>设一个 $m$ 进制下$w$ 位的位向量表示为 <script type="math/tex">[a_{w-1}, a_{w-2}, ..., a_0]</script>，则其表示的数为 $\sum_\limits{i=0}^{w-1} a_im^i$</p><h4 id="m-进制-rightarrow-十进制"><a href="#m-进制-rightarrow-十进制" class="headerlink" title="$m$ 进制 $\rightarrow$ 十进制"></a>$m$ 进制 $\rightarrow$ 十进制</h4><blockquote><p>设一个 $w$ 位 $m$ 进制整数的位相量表示为 <script type="math/tex">\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ]</script> ，定义函数 $M2D(\vec{x}) = \sum_\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\vec{x})$</p></blockquote><a id="more"></a><p><strong>证明：</strong>由进位计数制的定义可直接得到结论</p><blockquote><p>Example:</p><p>将 $3$ 进制数 $12011$ 转为十进制数</p><p>解： 令 $\vec{x} = [1,2,0,1,1], m = 3$</p><script type="math/tex; mode=display">\begin{align}\therefore n = M2D(\vec{x}) &= 1 \cdot 3^4 + 2 \cdot 3^3 + 1 \cdot 3^1 +1 \cdot 3^0 \\ &= 81+54+3+1 \\ &= 139 \end{align}</script><p>故 <script type="math/tex">12011_3 = 139_{10}</script></p></blockquote><h4 id="十进制-rightarrow-m-进制"><a href="#十进制-rightarrow-m-进制" class="headerlink" title="十进制 $\rightarrow$ $m$ 进制"></a>十进制 $\rightarrow$ $m$ 进制</h4><blockquote><p>设一个十进制整数为 $n$，定义序列 </p><script type="math/tex; mode=display">\begin{align}&p_0 = \lfloor \frac{n}{m} \rfloor, \ r_0 = n \ \ mod \ \ m \\&p_1 = \lfloor \frac{p_0}{m}\rfloor, \ r_1 = p_0 \ \ mod \ \ m \\&... \\&p_{s-1} = \lfloor \frac{p_{s-2}}{m}\rfloor = 0, \ r_{s-1} = p_{s-2} \ \ mod \ \ m \\\end{align}</script><p>则其对应的 $m$ 进制数的位向量表示为 <script type="math/tex">\vec{x} = [r_{s-1}, r_{s-2}, ..., r_0]</script></p></blockquote><p><strong>证明：</strong>设 $n$ 在 $m$ 进制下的位相量表示为 <script type="math/tex">[r_{s-1}, r_{s-2}, ..., r_0]</script></p><p>则由定义可知，<script type="math/tex">n = r_{s-1} \cdot m^{s-1} + r_{s-2} \cdot m^{s-2} + ...+ r_0</script></p><p>故 <script type="math/tex">n = m \cdot \left( r_{s-1} \cdot m^{s-2} + r_{s-2} \cdot m^{s-3} + ... + r_1 \right) + r_0</script></p><p>故 $r_0 = n \ \ mod \ \ m$</p><p>又由</p><script type="math/tex; mode=display">\begin{align}p_0 = \lfloor \frac{n}{m} \rfloor &= r_{s-1} \cdot m^{s-2} + r_{s-2} \cdot m^{s-3} + ... + r_1 \\&= m \cdot \left( r_{s-1} \cdot m^{s-3} + r_{s-2} \cdot m^{s-4} + ... + r_2 \right) + r_1\end{align}</script><p>故 $r_1 = p_0 \ \ mod \ \ m$</p><p>以此类推，<script type="math/tex">r_{i} = p_{i-1} \ \ mod \ \ m \ (i=s-2, ..., 1)</script></p><p>故结论成立</p><blockquote><p>Example:</p><p>将十进制数 $508$ 转为八进制数</p><p>解：</p><script type="math/tex; mode=display">\begin{align}508 &= 63 * 8 + 4 \\63 &= 7 * 8 + 7 \\7 &= 0 * 8 + 7\end{align}</script><p>故 $508_{10} = 774_8$</p></blockquote><h3 id="信息的存储"><a href="#信息的存储" class="headerlink" title="信息的存储"></a>信息的存储</h3><h4 id="字长（Word-Size）"><a href="#字长（Word-Size）" class="headerlink" title="字长（Word Size）"></a>字长（Word Size）</h4><p>在计算机中，<strong>字（Word）</strong>是用来表示一次性处理数据的固定长度。字的位数称为<strong>字长（Word Size）</strong>。字长是计算机系统中的一个重要指标，字长的大小决定了<strong>虚拟地址空间的最大大小</strong>。</p><p>对于一个字长为 $w$ 的机器来说，其虚拟地址的范围为 $0$ ～ $2^w-1$，即可以存储 $2^w$ 个字节</p><blockquote><p>Example:</p><p>字长为32的机器的虚拟地址范围为 $0$ ～ $2^{32}-1$，可以存储 $2^{32}$ 个字节</p></blockquote><h4 id="小端序（Little-Endian）和大端序（Big-Endian）"><a href="#小端序（Little-Endian）和大端序（Big-Endian）" class="headerlink" title="小端序（Little Endian）和大端序（Big Endian）"></a>小端序（Little Endian）和大端序（Big Endian）</h4><p>超过一个字节的数据在计算机中有两种排列顺序：小端序（Little Endian）和大端序（Big Endian）。</p><p>小端序：将较低的有效字节放在<strong>较小</strong>的内存地址中。</p><p>大端序：将较低的有效字节放在<strong>较大</strong>的内存地址中。</p><blockquote><p>Example:</p><p>原始数据：12 34 56 78 </p><p>小端序存储：12 34 56 78</p><p>大端序存储：78 56 34 12</p></blockquote><p><strong>注：</strong>使用ASCII码存储的字符数据在任何系统上都能得到相同的结果，不受端序的影响。</p><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><h4 id="位级运算"><a href="#位级运算" class="headerlink" title="位级运算"></a>位级运算</h4><p>计算机中有以下四种基本位级运算：<strong>按位与（&amp;）</strong>，<strong>按位或（|）</strong>，<strong>按位非（~）</strong>，<strong>按位异或（^）</strong>，其规则与布尔代数中的规则一致。</p><blockquote><p>Example:</p><p>101100 &amp; 100110 = 100100</p><p>101100 | 100110 = 101110</p><p>~101100 = 010011</p><p>101100 ^ 100110 = 001010</p></blockquote><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>计算机中提供了以下三种逻辑运算：<strong>且（&amp;&amp;）</strong>，<strong>或（||）</strong>，<strong>非（!）</strong>，其规则与命题逻辑中的规则一致。</p><p><strong>注：</strong>C语言中的逻辑运算有<strong>提早终止（Early Termination）</strong>的机制，即当两个表达式做逻辑运算时，若前一个表达式已经能确定最终结果，则不再计算后一个表达式。</p><blockquote><p>Example:</p><p>(1+1=2) &amp; (3=3) = 1</p><p>(1-1=0) || (1=2) = 1</p><p>!(2*5=10) = 0</p><p>!0x3F = 0</p></blockquote><h4 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h4><p>计算机中提供了三种位移操作：左移（&lt;&lt;），逻辑右移（&gt;&gt;），算术右移（&gt;&gt;）</p><p>$x$ 左移 $k$ 位：将 $x$ 的最高 $k$ 位丢弃并在最低位后补充 $k$ 个零，相当于 $x \cdot 2^k$</p><p>$x$ 逻辑右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个零，相当于 $\lfloor \frac{x}{2^k} \rfloor$</p><p>算术右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个最高位值</p><h3 id="整数的存储与运算"><a href="#整数的存储与运算" class="headerlink" title="整数的存储与运算"></a>整数的存储与运算</h3><h4 id="无符号整数"><a href="#无符号整数" class="headerlink" title="无符号整数"></a>无符号整数</h4><p>二进制数码不表示符号信息的整数称为无符号整数，其代码的数字与常规的进位计数制规则一致。即若定义 <script type="math/tex">B2U_w(\vec{x}) = \sum_\limits{i=0}^{w-1}x_i 2^i</script>，则一个 $w$ 位的二进制位相量 $\vec{x}$ 所对应的十进制数 $n = B2U_w(\vec{x})$</p><p>由定义可知，一个 $w$ 位的二进制位相量 $\vec{x}$ 可表示的整数范围为 $0$ ～ $2^w-1$</p><h4 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h4><p>有符号整数是采用补码进行存储的整数。补码是对二进制的一种新的解读方式，其严格的定义如下：若定义 <script type="math/tex">B2T_w(\vec{x}) = -x_{w-1} 2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i</script>，则一个 $w$ 位的二进制位相量 $\vec{x}$ 所对应的十进制数 $n = B2T_w(\vec{x})$。通俗来说，补码将原本 $0$ ～ $2^w-1$ 中 $2^{w-1}$ ～ $2^{w} - 1$ 的部分重新解读为负数，从而使得其可以表示负数。从取模的角度来看， 对于一个 $0$ ～ $2^{w-1} - 1$ 中的数 $n$ 和一个 $2^{w-1}$ ～ $2^{w} - 1$ 中的数 $m$，$(n + m) \ \ mod \ \ 2^w = n - (2^w - m)$，故这样定义是合适的。且容易看出其与无符号整数间的转换关系为 </p><script type="math/tex; mode=display">U2T(x) = \left\{\begin{aligned}&x &, &0 \leq x \leq 2^{w-1} - 1 \\&x - 2^w &, &2^{w-1} \leq x \leq 2^w - 1\end{aligned}\right.</script><script type="math/tex; mode=display">T2U(x) = \left\{\begin{aligned}&x &, & 0 \leq x \leq 2^{w-1}-1 \\&x + 2^w &, & -2^{w-1} \leq x \leq -1\end{aligned}\right.</script><p><strong>证明：</strong>设二进制位向量 $\vec{x}$</p><p>当 <script type="math/tex">0 \leq B2U_w(\vec{x}) \leq 2^{w-1} - 1</script> 时</p><script type="math/tex; mode=display">x_{w-1} = 0</script><p>此时 <script type="math/tex">B2T_w(\vec{x}) = \sum_\limits{i=0}^{w-2}x_i 2^i = B2U_w(\vec{x})</script></p><p>故 <script type="math/tex">U2T_w(x) = x</script></p><p>当 <script type="math/tex">2^{w-1} \leq x \leq 2^w - 1</script> 时</p><script type="math/tex; mode=display">x_{w-1} = 1</script><p>此时 </p><script type="math/tex; mode=display">\left\{\begin{aligned}B2T_w(\vec{x}) &= -2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i \\B2U_w(\vec{x}) &= 2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i\end{aligned}\right.</script><p>故 <script type="math/tex">B2T_w(\vec{x}) = B2U_w(\vec{x}) - 2^w</script></p><p>故 <script type="math/tex">U2T_w(\vec{x}) = x - 2^w</script></p><p><script type="math/tex">T2U(x)</script>的情况同理可证</p><p><strong>注：</strong>无符号或有符号整数仅为二进制解读为十进制时的不同解读方式，由于计算机在二进制层面进行运算，故计算机在进行底层运算时并不区分这两种解读方式。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Chapter-2：信息的表示和处理&quot;&gt;&lt;a href=&quot;#Chapter-2：信息的表示和处理&quot; class=&quot;headerlink&quot; title=&quot;Chapter 2：信息的表示和处理&quot;&gt;&lt;/a&gt;Chapter 2：信息的表示和处理&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;进制转换&quot;&gt;&lt;a href=&quot;#进制转换&quot; class=&quot;headerlink&quot; title=&quot;进制转换&quot;&gt;&lt;/a&gt;进制转换&lt;/h3&gt;&lt;h4 id=&quot;进位计数制&quot;&gt;&lt;a href=&quot;#进位计数制&quot; class=&quot;headerlink&quot; title=&quot;进位计数制&quot;&gt;&lt;/a&gt;进位计数制&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;设一个 $m$ 进制下$w$ 位的位向量表示为 &lt;script type=&quot;math/tex&quot;&gt;[a_{w-1}, a_{w-2}, ..., a_0]&lt;/script&gt;，则其表示的数为 $\sum_\limits{i=0}^{w-1} a_im^i$&lt;/p&gt;
&lt;h4 id=&quot;m-进制-rightarrow-十进制&quot;&gt;&lt;a href=&quot;#m-进制-rightarrow-十进制&quot; class=&quot;headerlink&quot; title=&quot;$m$ 进制 $\rightarrow$ 十进制&quot;&gt;&lt;/a&gt;$m$ 进制 $\rightarrow$ 十进制&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;设一个 $w$ 位 $m$ 进制整数的位相量表示为 &lt;script type=&quot;math/tex&quot;&gt;\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ]&lt;/script&gt; ，定义函数 $M2D(\vec{x}) = \sum_\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\vec{x})$&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.github.io/blog/tags/Computer-Science/"/>
    
    <category term="CSAPP" scheme="http://gonggongjohn.github.io/blog/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>GDB使用指南</title>
    <link href="http://gonggongjohn.github.io/blog/2020/09/19/gdb-guide/"/>
    <id>http://gonggongjohn.github.io/blog/2020/09/19/gdb-guide/</id>
    <published>2020-09-19T04:24:40.000Z</published>
    <updated>2020-09-28T08:06:30.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB使用指南"><a href="#GDB使用指南" class="headerlink" title="GDB使用指南"></a>GDB使用指南</h1><p>GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。</p><p>GDB官网：<a href="http://www.gnu.org/software/gdb/">GDB: The GNU Project Debugger</a></p><a id="more"></a><h2 id="GDB和LLDB"><a href="#GDB和LLDB" class="headerlink" title="GDB和LLDB"></a>GDB和LLDB</h2><p>LLDB是一款开源的具有REPL（Read-Evaluation-Print-Loop）特征的调试工具，相比GDB在部分场景下更加先进和高效。Xcode自4.3版本后默认内置了LLDB，因此<strong>macOS用户可以直接使用LLDB对程序进行调试</strong>。（当然macOS同样也可以安装GDB调试工具）</p><p>GDB与LLDB命令对照表：<a href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map</a></p><h2 id="WINDOWS下安装GCC和GDB"><a href="#WINDOWS下安装GCC和GDB" class="headerlink" title="WINDOWS下安装GCC和GDB"></a>WINDOWS下安装GCC和GDB</h2><p>MinGW（Minimalist GNU For Windows）是Windows下的一个小型GNU工具集。新版MinGW中集成了GCC和GDB的相关工具，因此只需安装MinGW即可使用GCC和GDB。</p><h3 id="下载MinGW及GCC包"><a href="#下载MinGW及GCC包" class="headerlink" title="下载MinGW及GCC包"></a>下载MinGW及GCC包</h3><p>首先前往MinGW官方网站：<a href="http://www.mingw.org">MinGW</a> 并在Download界面下载MinGW管理工具。</p><p><img src="mingw-1.png" alt="mingw-2"></p><p><img src="mingw-2.png" alt="mingw-2"></p><p>安装MinGW管理工具并打开。</p><p><img src="mingw-3.JPG" alt="mingw-3"></p><p>选择所需的工具集，点击左上角的<strong>Installation-&gt;Apply Changes</strong>即可安装。（由于受国内网络环境影响，可能会出现下载失败的情况，可以多尝试几次或使用其他网络连接方式下载）。若使用C/C++进行开发，通常仅需安装<strong>mingw32-base-bin</strong>及<strong>mingw32-gcc-g++-bin</strong>即可。</p><h3 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h3><p>安装完成后，我们需要配置系统环境变量使得其可以在CMD中执行。</p><p><strong>右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</strong>，在系统变量框中找到<strong>Path</strong>变量，选择编辑，在最后新增一行填入<strong>你的MinGW安装路径\bin</strong>，确定退出。</p><p><img src="mingw-4.JPG" alt="mingw-4"></p><p>打开CMD，输入<strong>gcc -v</strong>及<strong>gdb -v</strong>，若显示相关版本信息，表明环境变量配置成功。</p><p><img src="mingw-5.JPG" alt="mingw-5"></p><h2 id="在其他IDE中调用GDB"><a href="#在其他IDE中调用GDB" class="headerlink" title="在其他IDE中调用GDB"></a>在其他IDE中调用GDB</h2><h3 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h3><p>CLion本身已经集成了十分完善的可视化调试工具，但如果想在CLion中使用GDB或LLDB调试程序同样十分方便。</p><p>使用通常的方法在需要的地方打上断点启动调试，在下方的Debug窗口中就可以看到GDB/LLDB窗口，在其中输入命令即可。</p><p><img src="clion-1.png" alt="clion-1"></p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>VSCode本身并不自带GCC和GDB的相关功能，因此<strong>使用VSCode进行调试同样需要额外安装GDB/LLDB调试工具</strong>。不过，VSCode提供了一个可视化的C/C++调试插件，相比命令行调试会直观很多。该插件可直接在插件商店里搜索并安装。</p><p><img src="vscode-1.png" alt="vscode-1"></p><p>和其他大型IDE类似，VSCode将一个目录视为一个项目，因此在创建项目时，你需要指定一个空的文件夹来存放项目文件<strong>（这也是一些人装了辅助插件却被提示要手动配置调试文件的一大重要原因）</strong>。在第一次运行程序时，选择<strong>Run-&gt;Start Debugging</strong>，在弹出的选项框中选择一个要使用的调试环境及编译环境，VSCode就会自动在当前的项目目录下创建相应的配置文件。（当然也可以手动指定配置文件，具体配置方法可参考VSCode官方文档）</p><p><img src="vscode-2.png" alt="vscode-2"></p><p><img src="vscode-3.png" alt="vscode-3"></p><p>随后即可在调试界面中看到相关的调试信息。你也可以在下方的Debug Console中输入相关的GDB/LLDB命令来进行进一步的调试。</p><p><img src="vscode-4.png" alt="vscode-4"></p><h2 id="GDB的基本使用"><a href="#GDB的基本使用" class="headerlink" title="GDB的基本使用"></a>GDB的基本使用</h2><h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><p>若要使用GDB来调试程序，需要在使用GCC编译源文件的时候打开-g选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g [源文件名] -o [目标文件名]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g test.c -o test</span><br></pre></td></tr></table></figure></blockquote><p><strong>若不打开调试选项，则在调试时无法添加断点。</strong></p><p>使用gdb打开生成的可执行文件即可开始调试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [目标文件名]</span><br></pre></td></tr></table></figure><p>GDB还可以关联正在运行的程序进行调试。我们可以通过ps命令查询目标进程的PID，随后进入GDB使用attach命令关联进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep [进程名]</span><br><span class="line">gdb</span><br><span class="line">(gdb) attach [PID]</span><br></pre></td></tr></table></figure><p>Linux用户在这一过程过可能会遇到权限不足的情况。解决方法：切换至root用户，进入<strong>/etc/stsctl.d/10-ptrace.conf</strong>中将<code>kernel.yama.ptrace_scpoe = 1</code>改为<code>kernel.yama.ptrace_scpoe = 0</code>即可。</p><h3 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h3><p>通常在调试过程中，我们需要在程序的某个位置添加断点，并让程序运行到这一位置时自动暂停以分析程序当前的运行状态。在GDB环境下，我们可以通过break命令来快速添加断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [源文件名称]:[行号] #执行到某一行时中断</span><br><span class="line">(gdb) break [函数名] #执行到某个函数时中断</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:5</span><br><span class="line">(gdb) break main</span><br></pre></td></tr></table></figure></blockquote><p>有时我们希望程序在特定条件下中断，这个时候我们可以使用break+if或condition语句来设置条件断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [中断位置] if 触发条件</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:10 if a==5</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [中断位置]</span><br><span class="line">(gdb) condition [断点号] [触发条件]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:10</span><br><span class="line">(gdb) condition 1 a==5</span><br></pre></td></tr></table></figure></blockquote><p>我们可以使用info指令查看已设置断点的断点号及相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure><p>通过clear和delete命令可以删除已创建的断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear [目标文件名]:[行号] #删除某一行处的断点</span><br><span class="line">(gdb) clear [函数名] #删除某个函数处的断点</span><br><span class="line">(gdb) delete #删除所有断点</span><br><span class="line">(gdb) delete [断点号] #删除某一特定断点</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear test:5</span><br><span class="line">(gdb) delete 1</span><br></pre></td></tr></table></figure></blockquote><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>对于不需要向main函数传递参数的程序，可以直接使用run指令开始运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><p>对于需要向main函数传递参数的程序，可以使用set args指令或直接在run后跟参数的方式运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args [参数]</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args para1 para2 para3</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run [参数]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run para1 para2 para3</span><br></pre></td></tr></table></figure></blockquote><p>程序运行后，会一直运行至第一个断点处并暂停。若没有设置断点，则效果等同于直接运行程序。</p><p>当程序中断后，GDB提供了以下几种继续运行的指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next #单步执行（不进入函数内部，等同于Clion中的Step Over）</span><br><span class="line">(gdb) step #单步进入（进入函数内部，等同于Clion的Step Into）</span><br><span class="line">(gdb) continue #继续执行至下一个断点处</span><br><span class="line">(gdb) until [行号] #继续执行直至某一行</span><br><span class="line">(gdb) finish #运行至程序结尾</span><br></pre></td></tr></table></figure><h3 id="查看变量及内存"><a href="#查看变量及内存" class="headerlink" title="查看变量及内存"></a>查看变量及内存</h3><p>在程序中断时，GDB提供了一系列指令来查看当前变量及内存中的各种信息。</p><p>通过print指令可以打印变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print &#x27;[源文件名/函数名]&#x27;::[变量名/表达式]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print &#x27;main&#x27;::a</span><br><span class="line">(gdb) print &#x27;test.c&#x27;::b</span><br><span class="line">(gdb) print &#x27;main&#x27;::*p</span><br></pre></td></tr></table></figure></blockquote><p>通过display命令可以使得每次程序中断时自动打印某个变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display [变量名/表达式]</span><br></pre></td></tr></table></figure><p>此外，我们还可以通过watch指令追踪某一变量，使其值发生改变时中断程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch [变量名]</span><br></pre></td></tr></table></figure><p>通过backtrace指令可以查看函数调用栈的存储情况及相关信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace</span><br></pre></td></tr></table></figure><p>更多其他命令的详细用法，可以通过help指令查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help [命令]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GDB使用指南&quot;&gt;&lt;a href=&quot;#GDB使用指南&quot; class=&quot;headerlink&quot; title=&quot;GDB使用指南&quot;&gt;&lt;/a&gt;GDB使用指南&lt;/h1&gt;&lt;p&gt;GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。&lt;/p&gt;
&lt;p&gt;GDB官网：&lt;a href=&quot;http://www.gnu.org/software/gdb/&quot;&gt;GDB: The GNU Project Debugger&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.github.io/blog/tags/Computer-Science/"/>
    
    <category term="Language" scheme="http://gonggongjohn.github.io/blog/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>实数的严格定义</title>
    <link href="http://gonggongjohn.github.io/blog/2020/08/26/analysis-real-number/"/>
    <id>http://gonggongjohn.github.io/blog/2020/08/26/analysis-real-number/</id>
    <published>2020-08-26T11:03:01.000Z</published>
    <updated>2020-08-27T02:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Analysis" scheme="http://gonggongjohn.github.io/blog/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>代数概念整理：映射</title>
    <link href="http://gonggongjohn.github.io/blog/2020/07/31/algebra-projection/"/>
    <id>http://gonggongjohn.github.io/blog/2020/07/31/algebra-projection/</id>
    <published>2020-07-31T07:00:00.000Z</published>
    <updated>2020-09-23T02:33:28.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li><p>设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个<strong>映射</strong>，记为 $f:X \to Y$ ， $X$ 称为 $f$ 的<strong>定义域</strong>， $Y$ 称为 $f$ 的<strong>陪域</strong></p></li><li><p>设 $f:X \to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的<strong>象</strong>，记为 $f(a)$ ； $a$ 称为 $b$ 的<strong>原象</strong>，记为 $f^{-1}(b)$ ；集合 ${f(x) \big| x \in X}$ 称为 $f$ 的<strong>值域</strong>或 $f$ 的<strong>象</strong>，记为$f(X)$ 或 $Imf$</p></li><li><p>设 $f:X \to Y$ 为一映射，若 $\forall x_1 \neq x_2 \in X, f(x_1) \neq f(x_2)$ ，则称 $f$ 为一个<strong>单射</strong></p></li><li><p>设 $f:X \to Y$ 为一映射，若 $\forall y \in Y, \exists x \in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个<strong>满射</strong></p><a id="more"></a></li><li><p>设 $f:X \to Y$ 为一映射，若 $f$ 即是<strong>单射</strong>又是<strong>满射</strong>，则称 $f$ 为一个<strong>双射</strong></p></li><li><p>设 $f: X \to Y$ 为一映射，若 $Y=X$ ，且 $\forall x \in X, f(x) = x$ ，则称 $f$ 为一个<strong>恒等映射</strong>，记为 $Id_X$ 或 $e_X$</p></li><li><p>设 $f: A \to C, g: B \to D$ 为两个映射，若 $A = B,C=D$ ，且 $\forall x \in A, f(x)=g(x)$ ，则称映射 $f$ 与 $g$ <strong>相等</strong></p></li><li><p>设 $f: X \to Y, g: Y \to Z$ 为两个映射，则由法则 $(g \circ f)(x) = g(f(x))$ 定义的映射称为 $f$ 与 $g$ 的<strong>合成</strong>，记为 $g \circ f: X \to Z$ 或 $gf: X \to Z$</p></li><li><p>设 $f:X \to Y,g: Y \to X$ 为两个映射，若 $g \circ f = e_X$ ，则称 $g$ 为 $f$ 的<strong>左逆</strong>， $f$ 为 $g$ 的<strong>右逆</strong>；若  $g \circ f = e_X,f \circ g = e_Y$ ,则称 $g$ 为 $f$ 的<strong>双边逆</strong>或<strong>逆</strong></p></li></ol><h1 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h1><p><strong>1、（映射的合成律）</strong> 设 $f: X \to Y, g: Y \to Z, h: Z \to W$ 为三个映射，则 $h(gf)=(hg)f$</p><p><strong>证明：</strong> 对于 $ h(gf) $ ，$(X \to Y \to Z) \to W=X \to W$ ；对于 $(hg)f$ ，$X \to (Y \to Z \to W)=X \to W$</p><p>$\therefore$ $h(gf)$ 与 $(hg)f$ 的定义域及陪域相同</p><p>$\forall x \in X$ ，由<strong>定义8</strong>可知</p><p>$(h(gf))(x)=h((gf)(x))=h(g(f(x)))=(hg)(f(x))=((hg)f)(x)$</p><p>$\therefore$ 由<strong>定义7</strong>可知，$h(gf)=(hg)f$</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个&lt;strong&gt;映射&lt;/strong&gt;，记为 $f:X \to Y$ ， $X$ 称为 $f$ 的&lt;strong&gt;定义域&lt;/strong&gt;， $Y$ 称为 $f$ 的&lt;strong&gt;陪域&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的&lt;strong&gt;象&lt;/strong&gt;，记为 $f(a)$ ； $a$ 称为 $b$ 的&lt;strong&gt;原象&lt;/strong&gt;，记为 $f^{-1}(b)$ ；集合 ${f(x) \big| x \in X}$ 称为 $f$ 的&lt;strong&gt;值域&lt;/strong&gt;或 $f$ 的&lt;strong&gt;象&lt;/strong&gt;，记为$f(X)$ 或 $Imf$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，若 $\forall x_1 \neq x_2 \in X, f(x_1) \neq f(x_2)$ ，则称 $f$ 为一个&lt;strong&gt;单射&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，若 $\forall y \in Y, \exists x \in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个&lt;strong&gt;满射&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Algebra" scheme="http://gonggongjohn.github.io/blog/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title>代数概念整理：集合</title>
    <link href="http://gonggongjohn.github.io/blog/2020/07/30/algebra-set/"/>
    <id>http://gonggongjohn.github.io/blog/2020/07/30/algebra-set/</id>
    <published>2020-07-30T07:31:34.000Z</published>
    <updated>2020-09-23T02:33:11.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li><p>若 $a$ 为 $S$ 中的一个元素，则称 $a$ <strong>包含于</strong> $S$ ，记为 $a \in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ <strong>不包含于</strong> $S$ ，记为 $a \notin S$</p></li><li><p>设 $S,T$ 为两个集合，若 $\forall a \in S$ ，成立 $a \in T$ ，则称 $S$ 是 $T$ 的一个<strong>子集</strong>，记为 $S \subset T$</p></li><li><p>设 $S,T$ 为两个集合，若 $S \subset T, T \subset S$ ，则称 $S$ 与 $T$ <strong>相等</strong>，记为 $S=T$</p></li><li><p>设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \in T }$ 称为 $S$ 与 $T$ 的<strong>交集</strong>，记为 $S \cap T$ ；将集合 ${ x \big| x \in S \lor x \in T }$ 称为 $S$ 与 $T$ 的<strong>并集</strong>，记为 $S \cup T$</p><a id="more"></a></li><li><p>设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \notin T }$ 称为 $S$ 与 $T$ 的<strong>差集</strong>，记为 $S \setminus T$</p></li><li><p>设 $S,T$ 为两个集合，若 $T \subset S$ ，则将集合 $S \setminus T$ 称为 $T$ 在 $S$ 中的的<strong>补集</strong>，记为 $\complement_S{T}$</p></li><li><p>设 $S,T$ 为两个集合，则将集合 ${(x,y) \big| x \in S, y \in T}$ 称为 $S$ 与 $T$ 的<strong>笛卡尔积</strong> ，记为 $S \times T$ ；将 $\underbrace{X \times X \times … \times X}_{k个}$ 简记为 $X^k$</p></li><li><p>设 $S$ 为一个集合，则将 $S$ 中元素的个数记为 $S$ 的<strong>基数</strong>，记为 $|S|$</p></li></ol><h1 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h1><p><strong>1、（集合分配律）</strong>设 $R,S,T$ 为三个集合，则</p><p><strong>①</strong> $R \cap (S \cup T)=(R \cap S) \cup (R \cap T)$</p><p><strong>②</strong> $R \cup (S \cap T) = (R \cup S) \cap (R \cup T)$</p><p><strong>证明：①</strong> $\forall x \in R \cap (S \cup T)$ </p><p>$\therefore x \in R$ 且 $x \in S \cup T$</p><p>$\therefore$ （ $x \in R$ 且 $x \in S$ ） 或 （ $x \in R 且 x \in T$ ）</p><p>$ \therefore x \in (R \cap S) \cup (R \cap T)$</p><p>$\therefore$ 由<strong>定义2</strong>可知， $R \cap (S \cup T)\subset (R \cap S) \cup (R \cap T)$</p><p>反之， $\forall x \in (R \cap S) \cup (R \cap T)$</p><p>$\therefore$ $x \in R \cap S$ 或 $x \in R \cap T$</p><p>$\therefore x \in R$ 且（ $x \in S$ 或 $x \in T$ ）</p><p>$\therefore$ 由<strong>定义2</strong>可知，$(R \cap S) \cup (R \cap T) \subset R \cap (S \cup T)$</p><p>$\therefore$ 由<strong>定义3</strong>可知， $R \cap (S \cup T)=(R \cap S) \cup (R \cap T)$</p><p><strong>② 同理即可证得结论</strong></p><p><strong>2、</strong> 设 $X,Y$ 为两个集合，且 $|X|=n,|Y|=m$ ，则</p><p><strong>①</strong> $|X \times Y|=n \cdot m$</p><p><strong>②</strong> $|X \cup Y|=n +m-|X \cap Y|$</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;若 $a$ 为 $S$ 中的一个元素，则称 $a$ &lt;strong&gt;包含于&lt;/strong&gt; $S$ ，记为 $a \in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ &lt;strong&gt;不包含于&lt;/strong&gt; $S$ ，记为 $a \notin S$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，若 $\forall a \in S$ ，成立 $a \in T$ ，则称 $S$ 是 $T$ 的一个&lt;strong&gt;子集&lt;/strong&gt;，记为 $S \subset T$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，若 $S \subset T, T \subset S$ ，则称 $S$ 与 $T$ &lt;strong&gt;相等&lt;/strong&gt;，记为 $S=T$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \in T }$ 称为 $S$ 与 $T$ 的&lt;strong&gt;交集&lt;/strong&gt;，记为 $S \cap T$ ；将集合 ${ x \big| x \in S \lor x \in T }$ 称为 $S$ 与 $T$ 的&lt;strong&gt;并集&lt;/strong&gt;，记为 $S \cup T$&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Algebra" scheme="http://gonggongjohn.github.io/blog/tags/Algebra/"/>
    
  </entry>
  
</feed>
