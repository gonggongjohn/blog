<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GONGGONGJOHN&#39;s Blog</title>
  
  
  <link href="http://gonggongjohn.github.io/blog/atom.xml" rel="self"/>
  
  <link href="http://gonggongjohn.github.io/blog/"/>
  <updated>2020-09-23T02:32:07.952Z</updated>
  <id>http://gonggongjohn.github.io/blog/</id>
  
  <author>
    <name>GONGGONGJOHN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GDB使用指南</title>
    <link href="http://gonggongjohn.github.io/blog/2020/09/19/gdb-guide/"/>
    <id>http://gonggongjohn.github.io/blog/2020/09/19/gdb-guide/</id>
    <published>2020-09-19T04:24:40.000Z</published>
    <updated>2020-09-23T02:32:07.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB使用指南"><a href="#GDB使用指南" class="headerlink" title="GDB使用指南"></a>GDB使用指南</h1><p>GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。</p><p>GDB官网：<a href="http://www.gnu.org/software/gdb/">GDB: The GNU Project Debugger</a></p><a id="more"></a><h2 id="GDB和LLDB"><a href="#GDB和LLDB" class="headerlink" title="GDB和LLDB"></a>GDB和LLDB</h2><p>LLDB是一款开源的具有REPL（Read-Evaluation-Print-Loop）特征的调试工具，相比GDB在部分场景下更加先进和高效。Xcode自4.3版本后默认内置了LLDB，因此<strong>macOS用户可以直接使用LLDB对程序进行调试</strong>。（当然macOS同样也可以安装GDB调试工具）</p><p>GDB与LLDB命令对照表：<a href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map</a></p><h2 id="WINDOWS下安装GCC和GDB"><a href="#WINDOWS下安装GCC和GDB" class="headerlink" title="WINDOWS下安装GCC和GDB"></a>WINDOWS下安装GCC和GDB</h2><p>MinGW（Minimalist GNU For Windows）是Windows下的一个小型GNU工具集。新版MinGW中集成了GCC和GDB的相关工具，因此只需安装MinGW即可使用GCC和GDB。</p><h3 id="下载MinGW及GCC包"><a href="#下载MinGW及GCC包" class="headerlink" title="下载MinGW及GCC包"></a>下载MinGW及GCC包</h3><p>首先前往MinGW官方网站：<a href="http://www.mingw.org">MinGW</a> 并在Download界面下载MinGW管理工具。</p><p><img src="mingw-1.png" alt="mingw-2"></p><p><img src="mingw-2.png" alt="mingw-2"></p><p>安装MinGW管理工具并打开。</p><p><img src="mingw-3.JPG" alt="mingw-3"></p><p>选择所需的工具集，点击左上角的<strong>Installation-&gt;Apply Changes</strong>即可安装。（由于受国内网络环境影响，可能会出现下载失败的情况，可以多尝试几次或使用其他网络连接方式下载）。若使用C/C++进行开发，通常仅需安装<strong>mingw32-base-bin</strong>及<strong>mingw32-gcc-g++-bin</strong>即可。</p><h3 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h3><p>安装完成后，我们需要配置系统环境变量使得其可以在CMD中执行。</p><p><strong>右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</strong>，在系统变量框中找到<strong>Path</strong>变量，选择编辑，在最后新增一行填入<strong>你的MinGW安装路径\bin</strong>，确定退出。</p><p><img src="mingw-4.JPG" alt="mingw-4"></p><p>打开CMD，输入<strong>gcc -v</strong>及<strong>gdb -v</strong>，若显示相关版本信息，表明环境变量配置成功。</p><p><img src="mingw-5.JPG" alt="mingw-5"></p><h2 id="在其他IDE中调用GDB"><a href="#在其他IDE中调用GDB" class="headerlink" title="在其他IDE中调用GDB"></a>在其他IDE中调用GDB</h2><h3 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h3><p>CLion本身已经集成了十分完善的可视化调试工具，但如果想在CLion中使用GDB或LLDB调试程序同样十分方便。</p><p>使用通常的方法在需要的地方打上断点启动调试，在下方的Debug窗口中就可以看到GDB/LLDB窗口，在其中输入命令即可。</p><p><img src="clion-1.png" alt="clion-1"></p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>使用VSCode编译和调试C/C++程序需要安装C/C++插件，直接在插件商店里搜索安装即可。此外，使用VSCode进行调试同样需要额外安装GDB/LLDB调试工具。</p><p><img src="vscode-1.png" alt="vscode-1"></p><h2 id="GDB的基本使用"><a href="#GDB的基本使用" class="headerlink" title="GDB的基本使用"></a>GDB的基本使用</h2><h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><p>若要使用GDB来调试程序，需要在使用GCC编译源文件的时候打开-g选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g [源文件名] -o [目标文件名]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g test.c -o test</span><br></pre></td></tr></table></figure></blockquote><p><strong>若不打开调试选项，则在调试时无法添加断点。</strong></p><p>使用gdb打开生成的可执行文件即可开始调试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [目标文件名]</span><br></pre></td></tr></table></figure><p>GDB还可以关联正在运行的程序进行调试。我们可以通过ps命令查询目标进程的PID，随后进入GDB使用attach命令关联进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep [进程名]</span><br><span class="line">gdb</span><br><span class="line">(gdb) attach [PID]</span><br></pre></td></tr></table></figure><p>Linux用户在这一过程过可能会遇到权限不足的情况。解决方法：切换至root用户，进入<strong>/etc/stsctl.d/10-ptrace.conf</strong>中将<code>kernel.yama.ptrace_scpoe = 1</code>改为<code>kernel.yama.ptrace_scpoe = 0</code>即可。</p><h3 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h3><p>通常在调试过程中，我们需要在程序的某个位置添加断点，并让程序运行到这一位置时自动暂停以分析程序当前的运行状态。在GDB环境下，我们可以通过break命令来快速添加断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [源文件名称]:[行号] #执行到某一行时中断</span><br><span class="line">(gdb) break [函数名] #执行到某个函数时中断</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:5</span><br><span class="line">(gdb) break main</span><br></pre></td></tr></table></figure></blockquote><p>有时我们希望程序在特定条件下中断，这个时候我们可以使用break+if或condition语句来设置条件断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [中断位置] if 触发条件</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:10 if a==5</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break [中断位置]</span><br><span class="line">(gdb) condition [断点号] [触发条件]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break test.c:10</span><br><span class="line">(gdb) condition 1 a==5</span><br></pre></td></tr></table></figure></blockquote><p>我们可以使用info指令查看已设置断点的断点号及相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure><p>通过clear和delete命令可以删除已创建的断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear [目标文件名]:[行号] #删除某一行处的断点</span><br><span class="line">(gdb) clear [函数名] #删除某个函数处的断点</span><br><span class="line">(gdb) delete #删除所有断点</span><br><span class="line">(gdb) delete [断点号] #删除某一特定断点</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear test:5</span><br><span class="line">(gdb) delete 1</span><br></pre></td></tr></table></figure></blockquote><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>对于不需要向main函数传递参数的程序，可以直接使用run指令开始运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><p>对于需要向main函数传递参数的程序，可以使用set args指令或直接在run后跟参数的方式运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args [参数]</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args para1 para2 para3</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run [参数]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run para1 para2 para3</span><br></pre></td></tr></table></figure></blockquote><p>程序运行后，会一直运行至第一个断点处并暂停。若没有设置断点，则效果等同于直接运行程序。</p><p>当程序中断后，GDB提供了以下几种继续运行的指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) next #单步执行（不进入函数内部，等同于Clion中的Step Over）</span><br><span class="line">(gdb) step #单步进入（进入函数内部，等同于Clion的Step Into）</span><br><span class="line">(gdb) continue #继续执行至下一个断点处</span><br><span class="line">(gdb) until [行号] #继续执行直至某一行</span><br><span class="line">(gdb) finish #运行至程序结尾</span><br></pre></td></tr></table></figure><h3 id="查看变量及内存"><a href="#查看变量及内存" class="headerlink" title="查看变量及内存"></a>查看变量及内存</h3><p>在程序中断时，GDB提供了一系列指令来查看当前变量及内存中的各种信息。</p><p>通过print指令可以打印变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print &#x27;[源文件名/函数名]&#x27;::[变量名/表达式]</span><br></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print &#x27;main&#x27;::a</span><br><span class="line">(gdb) print &#x27;test.c&#x27;::b</span><br><span class="line">(gdb) print &#x27;main&#x27;::*p</span><br></pre></td></tr></table></figure></blockquote><p>通过display命令可以使得每次程序中断时自动打印某个变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) display [变量名/表达式]</span><br></pre></td></tr></table></figure><p>此外，我们还可以通过watch指令追踪某一变量，使其值发生改变时中断程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) watch [变量名]</span><br></pre></td></tr></table></figure><p>通过backtrace指令可以查看函数调用栈的存储情况及相关信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace</span><br></pre></td></tr></table></figure><p>更多其他命令的详细用法，可以通过help指令查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help [命令]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GDB使用指南&quot;&gt;&lt;a href=&quot;#GDB使用指南&quot; class=&quot;headerlink&quot; title=&quot;GDB使用指南&quot;&gt;&lt;/a&gt;GDB使用指南&lt;/h1&gt;&lt;p&gt;GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。&lt;/p&gt;
&lt;p&gt;GDB官网：&lt;a href=&quot;http://www.gnu.org/software/gdb/&quot;&gt;GDB: The GNU Project Debugger&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Computer-Science" scheme="http://gonggongjohn.github.io/blog/tags/Computer-Science/"/>
    
    <category term="Language" scheme="http://gonggongjohn.github.io/blog/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>实数的严格定义</title>
    <link href="http://gonggongjohn.github.io/blog/2020/08/26/analysis-real-number/"/>
    <id>http://gonggongjohn.github.io/blog/2020/08/26/analysis-real-number/</id>
    <published>2020-08-26T11:03:01.000Z</published>
    <updated>2020-08-27T02:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Analysis" scheme="http://gonggongjohn.github.io/blog/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>代数概念整理：映射</title>
    <link href="http://gonggongjohn.github.io/blog/2020/07/31/algebra-projection/"/>
    <id>http://gonggongjohn.github.io/blog/2020/07/31/algebra-projection/</id>
    <published>2020-07-31T07:00:00.000Z</published>
    <updated>2020-09-23T02:33:28.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li><p>设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个<strong>映射</strong>，记为 $f:X \to Y$ ， $X$ 称为 $f$ 的<strong>定义域</strong>， $Y$ 称为 $f$ 的<strong>陪域</strong></p></li><li><p>设 $f:X \to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的<strong>象</strong>，记为 $f(a)$ ； $a$ 称为 $b$ 的<strong>原象</strong>，记为 $f^{-1}(b)$ ；集合 ${f(x) \big| x \in X}$ 称为 $f$ 的<strong>值域</strong>或 $f$ 的<strong>象</strong>，记为$f(X)$ 或 $Imf$</p></li><li><p>设 $f:X \to Y$ 为一映射，若 $\forall x_1 \neq x_2 \in X, f(x_1) \neq f(x_2)$ ，则称 $f$ 为一个<strong>单射</strong></p></li><li><p>设 $f:X \to Y$ 为一映射，若 $\forall y \in Y, \exists x \in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个<strong>满射</strong></p><a id="more"></a></li><li><p>设 $f:X \to Y$ 为一映射，若 $f$ 即是<strong>单射</strong>又是<strong>满射</strong>，则称 $f$ 为一个<strong>双射</strong></p></li><li><p>设 $f: X \to Y$ 为一映射，若 $Y=X$ ，且 $\forall x \in X, f(x) = x$ ，则称 $f$ 为一个<strong>恒等映射</strong>，记为 $Id_X$ 或 $e_X$</p></li><li><p>设 $f: A \to C, g: B \to D$ 为两个映射，若 $A = B,C=D$ ，且 $\forall x \in A, f(x)=g(x)$ ，则称映射 $f$ 与 $g$ <strong>相等</strong></p></li><li><p>设 $f: X \to Y, g: Y \to Z$ 为两个映射，则由法则 $(g \circ f)(x) = g(f(x))$ 定义的映射称为 $f$ 与 $g$ 的<strong>合成</strong>，记为 $g \circ f: X \to Z$ 或 $gf: X \to Z$</p></li><li><p>设 $f:X \to Y,g: Y \to X$ 为两个映射，若 $g \circ f = e_X$ ，则称 $g$ 为 $f$ 的<strong>左逆</strong>， $f$ 为 $g$ 的<strong>右逆</strong>；若  $g \circ f = e_X,f \circ g = e_Y$ ,则称 $g$ 为 $f$ 的<strong>双边逆</strong>或<strong>逆</strong></p></li></ol><h1 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h1><p><strong>1、（映射的合成律）</strong> 设 $f: X \to Y, g: Y \to Z, h: Z \to W$ 为三个映射，则 $h(gf)=(hg)f$</p><p><strong>证明：</strong> 对于 $ h(gf) $ ，$(X \to Y \to Z) \to W=X \to W$ ；对于 $(hg)f$ ，$X \to (Y \to Z \to W)=X \to W$</p><p>$\therefore$ $h(gf)$ 与 $(hg)f$ 的定义域及陪域相同</p><p>$\forall x \in X$ ，由<strong>定义8</strong>可知</p><p>$(h(gf))(x)=h((gf)(x))=h(g(f(x)))=(hg)(f(x))=((hg)f)(x)$</p><p>$\therefore$ 由<strong>定义7</strong>可知，$h(gf)=(hg)f$</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个&lt;strong&gt;映射&lt;/strong&gt;，记为 $f:X \to Y$ ， $X$ 称为 $f$ 的&lt;strong&gt;定义域&lt;/strong&gt;， $Y$ 称为 $f$ 的&lt;strong&gt;陪域&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的&lt;strong&gt;象&lt;/strong&gt;，记为 $f(a)$ ； $a$ 称为 $b$ 的&lt;strong&gt;原象&lt;/strong&gt;，记为 $f^{-1}(b)$ ；集合 ${f(x) \big| x \in X}$ 称为 $f$ 的&lt;strong&gt;值域&lt;/strong&gt;或 $f$ 的&lt;strong&gt;象&lt;/strong&gt;，记为$f(X)$ 或 $Imf$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，若 $\forall x_1 \neq x_2 \in X, f(x_1) \neq f(x_2)$ ，则称 $f$ 为一个&lt;strong&gt;单射&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $f:X \to Y$ 为一映射，若 $\forall y \in Y, \exists x \in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个&lt;strong&gt;满射&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Algebra" scheme="http://gonggongjohn.github.io/blog/tags/Algebra/"/>
    
  </entry>
  
  <entry>
    <title>代数概念整理：集合</title>
    <link href="http://gonggongjohn.github.io/blog/2020/07/30/algebra-set/"/>
    <id>http://gonggongjohn.github.io/blog/2020/07/30/algebra-set/</id>
    <published>2020-07-30T07:31:34.000Z</published>
    <updated>2020-09-23T02:33:11.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ol><li><p>若 $a$ 为 $S$ 中的一个元素，则称 $a$ <strong>包含于</strong> $S$ ，记为 $a \in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ <strong>不包含于</strong> $S$ ，记为 $a \notin S$</p></li><li><p>设 $S,T$ 为两个集合，若 $\forall a \in S$ ，成立 $a \in T$ ，则称 $S$ 是 $T$ 的一个<strong>子集</strong>，记为 $S \subset T$</p></li><li><p>设 $S,T$ 为两个集合，若 $S \subset T, T \subset S$ ，则称 $S$ 与 $T$ <strong>相等</strong>，记为 $S=T$</p></li><li><p>设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \in T }$ 称为 $S$ 与 $T$ 的<strong>交集</strong>，记为 $S \cap T$ ；将集合 ${ x \big| x \in S \lor x \in T }$ 称为 $S$ 与 $T$ 的<strong>并集</strong>，记为 $S \cup T$</p><a id="more"></a></li><li><p>设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \notin T }$ 称为 $S$ 与 $T$ 的<strong>差集</strong>，记为 $S \setminus T$</p></li><li><p>设 $S,T$ 为两个集合，若 $T \subset S$ ，则将集合 $S \setminus T$ 称为 $T$ 在 $S$ 中的的<strong>补集</strong>，记为 $\complement_S{T}$</p></li><li><p>设 $S,T$ 为两个集合，则将集合 ${(x,y) \big| x \in S, y \in T}$ 称为 $S$ 与 $T$ 的<strong>笛卡尔积</strong> ，记为 $S \times T$ ；将 $\underbrace{X \times X \times … \times X}_{k个}$ 简记为 $X^k$</p></li><li><p>设 $S$ 为一个集合，则将 $S$ 中元素的个数记为 $S$ 的<strong>基数</strong>，记为 $|S|$</p></li></ol><h1 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h1><p><strong>1、（集合分配律）</strong>设 $R,S,T$ 为三个集合，则</p><p><strong>①</strong> $R \cap (S \cup T)=(R \cap S) \cup (R \cap T)$</p><p><strong>②</strong> $R \cup (S \cap T) = (R \cup S) \cap (R \cup T)$</p><p><strong>证明：①</strong> $\forall x \in R \cap (S \cup T)$ </p><p>$\therefore x \in R$ 且 $x \in S \cup T$</p><p>$\therefore$ （ $x \in R$ 且 $x \in S$ ） 或 （ $x \in R 且 x \in T$ ）</p><p>$ \therefore x \in (R \cap S) \cup (R \cap T)$</p><p>$\therefore$ 由<strong>定义2</strong>可知， $R \cap (S \cup T)\subset (R \cap S) \cup (R \cap T)$</p><p>反之， $\forall x \in (R \cap S) \cup (R \cap T)$</p><p>$\therefore$ $x \in R \cap S$ 或 $x \in R \cap T$</p><p>$\therefore x \in R$ 且（ $x \in S$ 或 $x \in T$ ）</p><p>$\therefore$ 由<strong>定义2</strong>可知，$(R \cap S) \cup (R \cap T) \subset R \cap (S \cup T)$</p><p>$\therefore$ 由<strong>定义3</strong>可知， $R \cap (S \cup T)=(R \cap S) \cup (R \cap T)$</p><p><strong>② 同理即可证得结论</strong></p><p><strong>2、</strong> 设 $X,Y$ 为两个集合，且 $|X|=n,|Y|=m$ ，则</p><p><strong>①</strong> $|X \times Y|=n \cdot m$</p><p><strong>②</strong> $|X \cup Y|=n +m-|X \cap Y|$</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;若 $a$ 为 $S$ 中的一个元素，则称 $a$ &lt;strong&gt;包含于&lt;/strong&gt; $S$ ，记为 $a \in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ &lt;strong&gt;不包含于&lt;/strong&gt; $S$ ，记为 $a \notin S$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，若 $\forall a \in S$ ，成立 $a \in T$ ，则称 $S$ 是 $T$ 的一个&lt;strong&gt;子集&lt;/strong&gt;，记为 $S \subset T$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，若 $S \subset T, T \subset S$ ，则称 $S$ 与 $T$ &lt;strong&gt;相等&lt;/strong&gt;，记为 $S=T$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设 $S,T$ 为两个集合，将集合 ${ x \big| x \in S \land x \in T }$ 称为 $S$ 与 $T$ 的&lt;strong&gt;交集&lt;/strong&gt;，记为 $S \cap T$ ；将集合 ${ x \big| x \in S \lor x \in T }$ 称为 $S$ 与 $T$ 的&lt;strong&gt;并集&lt;/strong&gt;，记为 $S \cup T$&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mathematics" scheme="http://gonggongjohn.github.io/blog/tags/Mathematics/"/>
    
    <category term="Algebra" scheme="http://gonggongjohn.github.io/blog/tags/Algebra/"/>
    
  </entry>
  
</feed>
