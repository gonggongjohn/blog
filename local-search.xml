<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据科学与工程算法基础 文本摘要实验</title>
    <link href="/2021/12/24/machine-learning/dase-alg-exp-summary/"/>
    <url>/2021/12/24/machine-learning/dase-alg-exp-summary/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>文本摘要是自然语言处理中一个十分重要的任务，一个好的摘要可以通过少量的文字很好地概括一段长文的核心内容，帮助读者快速理解文章的意思。当前，对于文本摘要任务，其方法大致可分为抽取式（Extractive）和生成式（Generative）两种，而其中前者由于拥有语句级的语法完整性，已经被广泛的应用于各种应用场景下。在抽取式文本摘要中，一种经典的方法是将其转化为最大集合覆盖问题，并采用子模函数（Submodular Function）的方法进行求解。本文详细推导并实现了基于爬山算法的文本抽取方法，讨论了一系列优化及其变体算法，并用其对同一主题下的20段论文语料进行了抽取式文本摘要。随后，我们还将其与另一种经典的抽取式文本摘要方法TextRank进行了对比，比较了两者的适用场景和异同。</p><p><strong>关键字：文本摘要，集合覆盖，子模函数，爬山算法，TextRank</strong></p><p>Text summarization is an important task in natural language processing. A good summary can summarize the crucial content of a long article with a small amount of text and help readers quickly understand the meaning of the article. Currently, the methods for text summarization task can be roughly divided into two types: Extractive and Generative. The former has been widely used in various application scenarios due to its sentence-level grammatical integrity. A classic method in extractive text summarization is to convert it into a maximum coverage problem and use the submodular function method to solve it. In this paper, we derived and implemented the extractive text summarization method based on hill climbing algorithm in detail, discussed a series of optimization and its variant algorithms, and used it to extract text summaries from a corpus of 20 papers under the same topic. Moreover, we compared it with another classic extractive text summarization method —— TextRank, and compared the application scenarios and similarities and differences of the two.</p><p><strong>Keywords: Text summarization, Set coverage, Submodular function, Hill-climbing algorithm, TextRank</strong></p><h2 id="项目概述">项目概述</h2><p>自动文本摘要是自然语言中一个十分重要的任务。这项任务要求我们从一个给定的文本语料（通常拥有较大的文本长度）中生成一段短文本，并使得其能够最大程度上表达原文本的含义。现阶段的文本摘要方法主要分为抽取式和生成式两类。其中，固定长度的抽取式文本摘要可以看作是一个<strong>最大K-子覆盖（Maximum K-Coverage Problem）</strong>，因此我们可以使用组合优化的方法来对其进行求解。本项目要求我们实现一种基于最大K-子覆盖问题的抽取式文本摘要算法，通过其一个从互联网上爬取的语料库中抽取100句话作为其文本摘要，并对摘要的性能进行分析。</p><h2 id="问题描述">问题描述</h2><p>使用最大集合子覆盖问题的语言对抽取式文本摘要问题的描述如下：</p><p>给定一个语料库 <span class="math inline">\(D = \{s_1, s_2, \cdots, s_n \}\)</span>，其中 <span class="math inline">\(s_i(i \in \{1,2,\cdots, n\})\)</span> 为单个句子，我们设其概念单元为 <span class="math inline">\(C = \{c_1, c_2, \cdots, c_m\}\)</span>，其中 <span class="math inline">\(c_i (i \in \{1,2,\cdots, m\}\)</span> 为关键词。抽取式文本摘要的目标是寻找一个子集 <span class="math inline">\(S \subset D\)</span>（其中 <span class="math inline">\(|S| \leq K\)</span>），使其能够覆盖的概念单元 <span class="math inline">\(|C&#39;|(C&#39; \subset C)\)</span> 尽可能的多。若使用优化的语言，则该问题可以写为 <span class="math display">\[\begin{aligned}&amp;\textbf{maximize} &amp;|C&#39;| \\&amp;\textbf{s.t} &amp;|S| \leq K\end{aligned}\]</span> 事实上，我们可以通过<strong>指示器变量（Indicator Variable）</strong>更具体的刻画这一问题。若设 <span class="math inline">\(x_i(i \in \{1, \cdots, n\})\)</span> 为语句选择的指示器变量，<span class="math inline">\(a_{ij}(j \in \{1, \cdots, m\})\)</span> 为关键词选择的指示器变量，也即 <span class="math display">\[\begin{aligned}&amp;x_i = \left\{\begin{aligned}1, s_i \in S \\0, s_i \notin S\end{aligned}\right., \quad&amp;a_{ij} = \left\{\begin{aligned}1, c_j \in s_i \\0, c_j \notin s_i\end{aligned}\right.\end{aligned}\]</span> 则原问题还可以写为 <span class="math display">\[\begin{aligned}&amp;\textbf{maximize} &amp;\left|\left\{j \Big| \sum_{i = 1}^n a_{ij} x_i \geq 1\right\}\right| \\&amp;\textbf{s.t} &amp; \sum_{i = 1}^n x_i \leq K, x_i \in \{0, 1\}\end{aligned}\]</span></p><p>可以看出，这是一个<strong>带有背包限制的最大集合子覆盖问题（MCKP，Maximum Coverage Problem with Knapsack Constraint）</strong>。</p><h2 id="数据集描述">数据集描述</h2><p>为了比较文本摘要算法的性能和效果，我们需要一个相应的语料库。在本文中，我们使用了同一主题下的论文文本作为语料库，论文摘要作为单文档文本摘要的关键词集合，并将一篇同主题下的综述性论文作为多文档文本摘要的关键词集合。具体的，我们爬取了预印本网站<strong>Arxiv</strong>中<strong>计算机视觉和模式识别（Computer Vision and Pattern Recognition, cs.CV）</strong>主题下的20篇有关<strong>目标检测（Object Detection）</strong>的论文，并将其作为目标语料库。此外，我们使用了发表于期刊<strong>Computer Science Review</strong>上的一篇关于目标检测的综述性论文作为多文档文本摘要的目标关键词集。</p><h3 id="数据集获取">数据集获取</h3><p>我们首先来对论文数据进行爬取。论文爬取的过程分为两步，第一步我们搜索所有满足条件的候选论文的相关信息（标题、类别、论文编号等），第二步我们下载论文的实际数据（PDF源码等资源）。</p><p>Arxiv提供了一个可以按主题查看最近一周论文的网页界面（https://arxiv.org/list/cs.CV/pastweek），因此我们首先对该网页进行分析。论文列表网页的HTML元素布局如下图所示：</p><img src="/2021/12/24/machine-learning/dase-alg-exp-summary/overview_html_aspect.png" class="" title="overview_html_aspect"><p>可以看到，对于一个论文信息显示块，其论文编号、论文标题、作者、主题分类被分别放置在标记为<strong>Abstract</strong>、<strong>list-title mathjax</strong>、<strong>list-authors</strong>和<strong>list-subjects</strong>的HTML元素块里。</p><p>我们使用Python自带的<strong>requests</strong>模块对网站发起请求，拉取其页面的HTML字符串，并使用社区开发者提供的<strong>BeautifulSoup</strong>模块对HTML的DOM结构进行解析，取出上述的元素。随后，我们将标题中带有“Object”和“Detection”两个关键词（不区分大小写）的论文取出，作为我们候选语料库文档。筛选的部分结果如下图所示：</p><img src="/2021/12/24/machine-learning/dase-alg-exp-summary/scrap_selected.png" class="" title="scrap_selected"><p>得到了论文编号后，我们就可以对论文的各种元数据（MetaData）进行获取。我们可以通过解析https://arxiv.org/abs/{arXiv_ID}获得论文的摘要，通过{https://arxiv.org/pdf/{arXiv_ID}下载其PDF文档，通过https://arxiv.org/e-print/{arXiv_ID}下载其原始资源，在此不再赘述。</p><p>事实上，Arxiv本身提供了一个可供程序访问的论文资源获取的API（实现完才发现QAQ）。我们只需要使用<strong>布尔查询表达式（Boolean Query Expression）</strong>即可获得相应的论文结果。社区开发者对其接口请求和数据格式进行了封装，因此在Python我们只需直接引入arxiv包即可发起查询并获得论文的<strong>标题</strong>、<strong>摘要</strong>、<strong>PDF文档</strong>及<strong>原始文档（Latex文本及图片等源文件）</strong>等资源。</p><p>同样的，我们使用该API实现了自动爬取论文源数据的相关代码，并获得了最终的语料库。</p><h3 id="文本预处理">文本预处理</h3><h4 id="文本提取">文本提取</h4><p>得到了原始的论文文档后，我们需要对文档集进行整理和清洗，抽取出语料库，并对文本进行预处理。</p><p>我们首先尝试使用<strong>Pdfminer</strong>模块直接对论文的PDF文档进行分析，通过关键字的方式对文本进行抽取，结果如下图所示：</p><img src="/2021/12/24/machine-learning/dase-alg-exp-summary/pdfminer_success.png" class="" title="pdfminer_success"><img src="/2021/12/24/machine-learning/dase-alg-exp-summary/pdfminer_fail.png" class="" title="pdfminer_fail"><p>。可以看到，由于PDF是以矢量图的方式对元素进行排布，其排布并不完全按照视觉上的排布顺序，因此该方法并不能准确的抽取出文档中的相应文本。</p><p>事实上，我们可以通过对PDF文档进行<strong>版面分析（Layout Analysis）</strong>的方式提取论文的原始文本，但这一做法就导致不确定因素更多，使问题变得更为复杂，因此我们不做考虑。</p><p>幸运的是，Arxiv提供了论文源文件的下载地址，这也就意味着我们可以直接获取到论文的Latex源代码。因此，我们只需要直接从Latex文档中对纯文本进行抽取即可。Latex是一种标准化的排版工具，我们可以通过声明式的代码语言在一个Latex文档中插入各种元素。由于我们只需要对其中的纯文本进行分析，因此这些元素在当前的任务下是多余的。这时，我们就需要使用正则表达式对其进行替换。例如，对于<strong>\cite{}</strong>，我们就可以使用正则表达式 <span class="math inline">\(cite\)</span><span class="math inline">\(\{(.*?)\)</span>$}将其匹配出来（Figure ）。</p><h2 id="方法">方法</h2><h3 id="朴素枚举法">朴素枚举法</h3><h3 id="贪心算法爬山算法">贪心算法（爬山算法）</h3><h3 id="带权的贪心算法">带权的贪心算法</h3><h3 id="stack-encoding">Stack Encoding</h3><h3 id="textrank">TextRank</h3><h2 id="实验结果">实验结果</h2><p>最后，我们从摘要质量和摘要推理时间两个方面来对上面的方法进行分析。</p><p>对于摘要质量，我们自然的可以想到使用关键词覆盖率作为其评价指标。沿用上面的记号，若我们将抽取出的概括文本 <span class="math inline">\(S\)</span> 看作词项的集合，则覆盖率被定义为 <span class="math display">\[Coverage = S \cap C\]</span> 。对于文本摘要任务，一个常用的评价指标被称为<strong>ROUGE-N（Recall-Oriented Understudy for Gisting Evaluation-N）</strong>，其定义为 <span class="math display">\[ROUGE-N = \frac{|N-Gram_{Extracted} \cap N-Gram_{Reference}|}{|N-Gram_{Reference}|}\]</span> ，也即抽取的摘要中匹配的N-Gram数除以标准摘要中的N-Gram总数。从定义中我们可以发现，ROUGE-N通常需要一个参考的摘要文本才能计算，而这里我们并没有这样的文本。不过，由于我们有目标关键字，而这可以视作一种1-Gram，因此我们仍然可以计算ROUGE-1的值。</p><h2 id="结论">结论</h2><p>在本实验中，我们首先从集合覆盖的角度分析了抽取式文本摘要问题，并将其转化了为了一个MCKP问题。由于该问题是一个NP-Hard问题，我们无法在可接受的时间内用朴素搜索算法求解出精确解。随后，我们实现了基于贪心算法的最大子覆盖算法，并用其实现了抽取式文本摘要。进一步的，我们对贪心算法实现了一系列的改进，包括考虑文本的权重，以及使用队列的方式进行聚合搜索。最后，我们实现了经典的TextRank算法，并将其与前面的算法进行了比较。</p><p>我们可以很容易的发现，基于最大子覆盖的文本摘要算法能够更好的贴合目标关键字，但其语义连贯性明显不如TextRank算法。这就意味着当我们有一个好的关键词集合或面对多文档摘要场景时，我们可以使用基于最大子覆盖问题的文本摘要算法。而在实际应用场景或单文本的摘要场景下，我们更倾向于使用TextRank等基于语义的文本摘要算法。</p><p>通过本实验，我们对抽取式文本摘要任务和子模函数、最大K-子覆盖问题有了更深入的了解。</p>]]></content>
    
    
    <categories>
      
      <category>数据科学算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Machine-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据科学与工程算法基础 PCA实验</title>
    <link href="/2021/11/29/machine-learning/dase-alg-exp-pca/"/>
    <url>/2021/11/29/machine-learning/dase-alg-exp-pca/</url>
    
    <content type="html"><![CDATA[<h2 id="摘要">摘要</h2><p>图像压缩一直是图像处理中一个重要的任务，一个好的图像压缩算法可以大大降低存储和传输代价。主成分分析（Principal Component Analysis）作为一个经典的降维方法，已经在图像压缩领域得到了极为广泛的运用。在本文中，我们从主成分分析的原理出发，导出并实现了基于特征分解的朴素PCA算法，并使用奇异值分解方法对其计算进行了优化。随后，我们实现了更适合图像处理的2DPCA、其改进方法2D-2DPCA。此外，我们还实现了基于核方法的Kernel PCA来进一步提升主成分的表达能力，并对比了多种不同的核函数下图像的压缩效果。进一步的，我们尝试使用了较为现代的基于神经网络的GHA（Generalized Hebbian Algorithm）算法来迭代得到主成分。最后，我们将实现的结果与时下较为常用的基于离散余弦变换的JPEG图像压缩算法进行了对比。</p><p><strong>关键字：图像压缩，主成分分析，核方法，感知机，余弦变换</strong></p><p>Image compression has long be a fundamental task in image processing, a good image compression algorithm can massively reduce the cost of storage and transmission. As a classic dimension reduction algorithm, Principle Component Analysis has been widely used in the field of image compression. In this article, we derive and implement the naive PCA algorithm based on eigenvalue decomposition, and use the singular value decomposition method to optimize its calculation. Subsequently, we implemented 2DPCA and its improvement version 2D-2DPCA, which is more suitable for image processing. In addition, we implemented Kernel PCA based on the kernel method to further improve the expression ability of principal components, and compared the compression effects of images under a variety of different kernel functions. Further, we tried to use a more modern neural network-based GHA (Generalized Hebbian Algorithm) algorithm to iteratively obtain the principal components. Finally, we compared the achieved results with the contemporary mainstream JPEG image compression algorithm which is based on discrete cosine transform.</p><p><strong>Keywords: Image compression, Principle component analysis, Perceptron, Cosine transformation</strong></p><h2 id="项目概述">项目概述</h2><p>主成分分析（Principal Component Analysis）可以用来减少矩阵（图像）的维度，并将这些新的维度投射到图像上，使其保留质量。本项目要求我们使用PCA方法及其变体，对3组图像（每组包含100张图像）进行压缩，并对图像压缩的性能进行分析。</p><h2 id="问题描述">问题描述</h2><p>一张<span class="math inline">\(8\)</span>位三通道（RGB）正方形彩色图片可视为三个 <span class="math inline">\(N\)</span> 维矩阵 <span class="math inline">\(\boldsymbol{X}\)</span>，其中 <span class="math inline">\(x_{ij} \in \{0,1, \cdots, 255\}\)</span>，其存储代价为 <span class="math inline">\(b\)</span>。图像压缩的目标即为寻找一个映射 <span class="math inline">\(\mathcal{Q}\)</span>，使得 <span class="math inline">\(\mathcal{Q}(\boldsymbol{X}) \in \mathbb{R}^{k \times n}(k \ll n), \mathcal{Q}^{-1} (\mathcal{Q}(\boldsymbol{X})) \approx X\)</span>，且存储 <span class="math inline">\(\mathcal{Q} (\boldsymbol{X})\)</span> 和 <span class="math inline">\(\mathcal{Q}^{-1}\)</span> 所需的空间 <span class="math inline">\(\tilde{b} \ll b\)</span>。</p><h2 id="方法">方法</h2><h3 id="朴素pca">朴素PCA</h3><p>PCA的主要思想是通过将一个高维样本 <span class="math inline">\(\boldsymbol{x} \in \mathbb{R}^n\)</span> 左乘一个正交矩阵 <span class="math inline">\(\boldsymbol{Q} \in \mathbb{R}^{k \times n}(k \ll n)\)</span>，使得其映射到一个较低维的超平面 <span class="math inline">\(\boldsymbol{Q x} \in \mathbb{R}^k\)</span> 上，同时又保证多个数据点映射后的统计性质保持不变。具体来说，这样的超平面要具有如下的性质：</p><ul><li><strong>最近重构性：</strong>样本点到这个超平面的距离足够近</li><li><strong>最大可分性：</strong>样本点在这个超平面上的投影尽可能分开</li></ul><p>由此，我们就有两种角度来求解这一正交矩阵。事实上，在中心化条件下，这两者是等价的。这是由于有如下定理保证：</p><blockquote><p><strong>Theorem:</strong> 对于中心化数据集 <span class="math inline">\(\{\boldsymbol{x}^{(i)}\}_{i = 1}^N\)</span>，最小化重构距离等价于最大化投影方差</p><p><strong>Proof:</strong> 这里仅证明投影到一维时的情形，高维时的情况可自然推广</p><p>设投影直线的方向向量为 <span class="math inline">\(\boldsymbol{v}\)</span>，其中 <span class="math inline">\(||\boldsymbol{v}||^2 = 1\)</span></p><p>则由勾股定理可知，<span class="math inline">\(||\boldsymbol{x}^{(i)} - \boldsymbol{v^T} \boldsymbol{x}^{(i)}\boldsymbol{v}||^2 = ||\boldsymbol{x}^{(i)}||^2 - \left(\boldsymbol{v}^T \boldsymbol{x}^{(i)}\right)^2\)</span></p><p>于是 <span class="math inline">\(\boldsymbol{v}\)</span> 的最优解 <span class="math display">\[\begin{aligned}\boldsymbol{v}^* &amp;= \mathop{\arg\min}_{\boldsymbol{v}: ||\boldsymbol{v}||^2 = 1} \frac{1}{N} \sum_{i = 1}^N ||\boldsymbol{x}^{(i)} - \boldsymbol{v^T} \boldsymbol{x}^{(i)}\boldsymbol{v}||^2 \\&amp;= \mathop{\arg\min}_{\boldsymbol{v}: ||\boldsymbol{v}||^2 = 1} \frac{1}{N} \sum_{i = 1}^N \left( ||\boldsymbol{x}^{(i)}||^2 - \left(\boldsymbol{v}^T \boldsymbol{x}^{(i)}\right)^2 \right) \\&amp;= \mathop{\arg\max}_{\boldsymbol{v}: ||\boldsymbol{v}||^2 = 1} \frac{1}{N} \sum_{i = 1}^N \left(\boldsymbol{v}^T \boldsymbol{x}^{(i)}\right)^2\end{aligned}\]</span> 也即最小化重构距离与最大化投影方差等价</p></blockquote><p>这里我们通过最大化投影方差的方法来求解。 我们知道，对于一个中心化矩阵 <span class="math inline">\(\boldsymbol{X}\)</span>（即 <span class="math inline">\(E(\boldsymbol{X}) = \boldsymbol{0}\)</span>），其协方差矩阵 <span class="math display">\[\begin{aligned}\Sigma (\boldsymbol{X}) &amp;= E \left[ (\boldsymbol{X} - E(\boldsymbol{X})) (\boldsymbol{X} - E(\boldsymbol{X}))^T \right] \\&amp;= \begin{pmatrix}\textrm{Cov}(\boldsymbol{X}_1, \boldsymbol{X}_1) &amp; \textrm{Cov}(\boldsymbol{X}_1, \boldsymbol{X}_2) &amp;\cdots &amp;\textrm{Cov}(\boldsymbol{X}_1, \boldsymbol{X}_n) \\\textrm{Cov}(\boldsymbol{X}_2, \boldsymbol{X}_1) &amp; \textrm{Cov}(\boldsymbol{X}_2, \boldsymbol{X}_2) &amp;\cdots &amp;\textrm{Cov}(\boldsymbol{X}_2, \boldsymbol{X}_n) \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\textrm{Cov}(\boldsymbol{X}_n, \boldsymbol{X}_1) &amp; \textrm{Cov}(\boldsymbol{X}_n, \boldsymbol{X}_2) &amp;\cdots &amp;\textrm{Cov}(\boldsymbol{X}_n, \boldsymbol{X}_n)\end{pmatrix} \\&amp;= \frac{1}{N} \boldsymbol{X} \boldsymbol{X}^T\end{aligned}\]</span> 若将投影矩阵 <span class="math inline">\(\boldsymbol{Q}\)</span> 按行划分为向量组，也即设 <span class="math display">\[\boldsymbol{Q} = \begin{pmatrix}\boldsymbol{q}_1 \\\boldsymbol{q}_2 \\\vdots \\\boldsymbol{q}_k\end{pmatrix}\]</span> ，则要使得投影方差和最大，也即求解 <span class="math display">\[\begin{aligned}\mathop{\arg\max}_{\boldsymbol{Q}: \boldsymbol{Q}\boldsymbol{Q}^T = \boldsymbol{I}} \sum_{i = 1}^k || \boldsymbol{q}_i \boldsymbol{X} ||_2^2 &amp;= \mathop{\arg\max}_{\boldsymbol{Q}: \boldsymbol{Q}\boldsymbol{Q}^T = \boldsymbol{I}} ||\boldsymbol{QX}||_F^2 \\&amp;=\mathop{\arg\max}_{\boldsymbol{Q}: \boldsymbol{Q}\boldsymbol{Q}^T = \boldsymbol{I}} \textrm{tr} \left( \boldsymbol{X}^T \boldsymbol{Q}^T \boldsymbol{Q} \boldsymbol {X} \right)\end{aligned}\]</span> 由此可得优化问题 <span class="math display">\[\begin{aligned}\min \quad &amp; - \textrm{tr} \left( \boldsymbol{X}^T \boldsymbol{Q}^T \boldsymbol{Q} \boldsymbol {X} \right) \\\textbf{s.t} \quad &amp; \boldsymbol{Q} \boldsymbol{Q}^T = \boldsymbol{I}_{k \times k}\end{aligned}\]</span> 利用拉格朗日乘子法，我们可得当目标函数取到最小值时，有 <span class="math display">\[\boldsymbol{Q} \boldsymbol{X} \boldsymbol{X}^T = \boldsymbol{Q} \boldsymbol{\lambda}\]</span> 也即 <span class="math inline">\(\boldsymbol{Q}\)</span> 中的第 <span class="math inline">\(i\)</span> 行为 <span class="math inline">\(\boldsymbol{X} \boldsymbol{X}^T\)</span> 的第 <span class="math inline">\(i\)</span> 个特征值 <span class="math inline">\(\lambda_i\)</span> 对应的特征向量。进一步的，将结果代回原式我们可以发现，由于 <span class="math inline">\(\boldsymbol{Q}\)</span> 为一个 <span class="math inline">\(k \times n\)</span> 的矩阵，因此若要使得目标函数取到最小值，<span class="math inline">\(\boldsymbol{Q}\)</span> 中的行向量应取前 <span class="math inline">\(k\)</span> 大的特征值所对应的特征向量。</p><p>在图像压缩任务中，当将数据集映射到低维空间后，我们还需要将其重构回原来的图像空间以保证图像的可用性。对于使用正交变换的PCA方法，这一重构任务是容易的。由于 <span class="math inline">\(\boldsymbol{Q}\)</span> 为一正交矩阵，其逆矩阵 <span class="math inline">\(\boldsymbol{Q}^{-1} = \boldsymbol{Q}^T\)</span>。因此要重构压缩后的图像，进行我们只需要对降维数据进行逆变换，即左乘 <span class="math inline">\(\boldsymbol{Q}^T\)</span> 即可。</p><p>由此，我们导出了使用朴素PCA方法进行图像压缩的一般过程。需要注意的是，要使用基于特征分解的PCA方法对图像进行分析和处理，我们需要将图像矩阵划分为向量组并进行中心化操作，这里我们采用按列划分的方法。算法的具体流程如下：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/naive_pca_alg.png" class="" title="naive_pca_alg"><p>在选择了不同主成分个数时，使用朴素PCA算法进行图像压缩的效果结果如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/naive_pca_pic.png" class="" title="naive_pca_pic"><p>可以看到，仅使用前10个主成分已经能还原出整体的图像轮廓，当 <span class="math inline">\(k=50\)</span> 时，图像的细节已基本得到恢复。</p><h3 id="基于奇异值分解的pca">基于奇异值分解的PCA</h3><p>可以看到，基于特征值分解的PCA算法中计算开销最大的部分为计算协方差矩阵 <span class="math inline">\(\boldsymbol{X} \boldsymbol{X}^T\)</span> 的特征值与特征向量。事实上，我们可以使用奇异值分解来避免这一高开销计算，一个 <span class="math inline">\(m \times n\)</span> 的矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 的奇异值分解是指将其分解为三个特殊矩阵乘积的形式 <span class="math inline">\(\boldsymbol{A} = \boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^T\)</span>，其中 <span class="math inline">\(\boldsymbol{U}\)</span> 为 <span class="math inline">\(m\)</span> 阶正交矩阵，<span class="math inline">\(\boldsymbol{V}\)</span> 为 <span class="math inline">\(n\)</span> 阶正交矩阵，<span class="math inline">\(\Sigma\)</span> 是由降序排列的非负的对角线元素组成的 <span class="math inline">\(m \times n\)</span> 对角矩阵。</p><p>对于任意实矩阵，我们都能找到它的奇异值分解。这是由于有如下定理保证：</p><blockquote><p><strong>Theorem:</strong> 若 <span class="math inline">\(\boldsymbol{A}\)</span> 为一 <span class="math inline">\(m \times n\)</span> 实矩阵，<span class="math inline">\(\boldsymbol{A} \in \mathbb{R}^{m \times n}\)</span>，则 <span class="math inline">\(\boldsymbol{A}\)</span> 的奇异值分解存在 <span class="math inline">\(\boldsymbol{A} = \boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^T\)</span>其中 <span class="math inline">\(\boldsymbol{U}\)</span> 是 <span class="math inline">\(m\)</span> 阶正交矩阵，<span class="math inline">\(\boldsymbol{V}\)</span> 是 <span class="math inline">\(n\)</span> 阶正交矩阵，<span class="math inline">\(\boldsymbol{\Sigma}\)</span> 是 <span class="math inline">\(m \times n\)</span> 对角矩阵，其前 <span class="math inline">\(r\)</span> 个对角元素 <span class="math inline">\((\sigma_1, \cdots, \sigma_r)\)</span> 为正，且按降序排列，其余均为 <span class="math inline">\(0\)</span>。</p><p><strong>Proof:</strong> 由于 <span class="math inline">\(\boldsymbol{A}^T \boldsymbol{A}\)</span> 为对称半正定矩阵，因此可以对其进行特征分解 <span class="math inline">\(\boldsymbol{A}^T \boldsymbol{A} = \boldsymbol{V} \boldsymbol{\Lambda}_n \boldsymbol{V}^T\)</span>，其中 <span class="math inline">\(V \in \mathbb{R}^{n \times n}\)</span> 是正交矩阵，<span class="math inline">\(\boldsymbol{\Lambda}_n\)</span> 是对称矩阵，并且对角线元素是 <span class="math inline">\(\boldsymbol{A}^T \boldsymbol{A}\)</span> 的特征值 <span class="math inline">\(\lambda_i \geq 0, i = 1, \cdots, n\)</span>，并且是按降序排列的。因为 <span class="math inline">\(\textrm{rank} (\boldsymbol{A}) = \textrm{rank}(\boldsymbol{A}^T \boldsymbol{A}) = r\)</span>，所以前 <span class="math inline">\(r\)</span> 个特征值是正的。</p><p>注意到 <span class="math inline">\(\boldsymbol{A} \boldsymbol{A}^T\)</span> 和 <span class="math inline">\(\boldsymbol{A}^T \boldsymbol{A}\)</span> 有相同的非零特征值，因此他们的秩是相等的。我们定义 <span class="math display">\[\sigma_i = \sqrt{\lambda_i} &gt; 0, i = 1, \cdots, r\]</span> ，记 <span class="math inline">\(\boldsymbol{v}_1, \cdots,\boldsymbol{v}_r\)</span> 是 <span class="math inline">\(\boldsymbol{V}\)</span> 的前 <span class="math inline">\(r\)</span> 列，它们同时也是 <span class="math inline">\(\boldsymbol{A}^T \boldsymbol{A}\)</span> 前 <span class="math inline">\(r\)</span> 个特征值对应的特征向量。即有 <span class="math display">\[\boldsymbol{A}^T \boldsymbol{A} \boldsymbol{v}_i = \lambda_i \boldsymbol{v}_i, i = 1, \cdots, r\]</span> 。因此同时在两边左乘上 <span class="math inline">\(\boldsymbol{A}\)</span> 就有 <span class="math display">\[(\boldsymbol{A} \boldsymbol{A}^T) \boldsymbol{A} \boldsymbol{v}_i = \lambda_i \boldsymbol{A} \boldsymbol{v}_i,i = 1, \cdots, r\]</span> 。这就意味着 <span class="math inline">\(\boldsymbol{A} \boldsymbol{v}_i\)</span> 是 <span class="math inline">\(\boldsymbol{A} \boldsymbol{A}^T\)</span> 的特征向量，因为 <span class="math inline">\(\boldsymbol{v}_i^T \boldsymbol{A}^T \boldsymbol{A} \boldsymbol{v}_j = \lambda_j \boldsymbol{v}_i^T \boldsymbol{v}_j\)</span> 所以这些特征向量也是正交的。所以将他们标准化则有</p><p><span class="math display">\[\boldsymbol{u}_i = \frac{\boldsymbol{A} \boldsymbol{v}_i}{\sqrt{\lambda_i}} = \frac{\boldsymbol{A} \boldsymbol{v}_i}{\sigma_i}, i = 1, \cdots, r\]</span> 这些 <span class="math inline">\(\boldsymbol{u}_1, \cdots, \boldsymbol{u}_r\)</span> 是 <span class="math inline">\(r\)</span> 个 <span class="math inline">\(\boldsymbol{A} \boldsymbol{A}^T\)</span> 关于非零特征值 <span class="math inline">\(\lambda_1, \cdots, \lambda_r\)</span> 的特征向量。因此 <span class="math display">\[\boldsymbol{u}_i^T \boldsymbol{A} \boldsymbol{v}_j = \frac{1}{\sigma_i} \boldsymbol{v}_i^T \boldsymbol{A}^T \boldsymbol{A} \boldsymbol{v}_j = \frac{\lambda_j}{\sigma_i} \boldsymbol{v}_i^T \boldsymbol{v}_j = \left\{\begin{aligned}\sigma_i, &amp; i = j \\0, 其他\end{aligned}\right.\]</span> 以矩阵的方式重写即有</p><p><span class="math display">\[\begin{pmatrix}\boldsymbol{u}_1^T \\\vdots \\\boldsymbol{u}_r^T\end{pmatrix}\boldsymbol{A}(\boldsymbol{v}_1, \cdots, \boldsymbol{v}_r)= \textrm{diag} (\sigma_1, \cdots, \sigma_r) = \boldsymbol{\Sigma}_r\]</span></p><p>注意到根据定义 <span class="math display">\[\boldsymbol{A}^T \boldsymbol{A} \boldsymbol{v}_i = 0, i = r + 1, \cdots, n\]</span> 即有 <span class="math display">\[\boldsymbol{A} \boldsymbol{v}_i = 0, i = r + 1, \cdots, n\]</span> 取相互正交的单位向量 <span class="math inline">\(\boldsymbol{u}_{r+1}, \cdots, \boldsymbol{u}_m\)</span> 均与 <span class="math inline">\(\boldsymbol{u}_1, \cdots, \boldsymbol{u}_r\)</span> 正交，即有 <span class="math display">\[\boldsymbol{u}_i^T \boldsymbol{A} \boldsymbol{v}_j = 0. i = 1, \cdots, m; j = r + 1, \cdots, n\]</span> 它们共同构成了 <span class="math inline">\(\mathbb{R}^m\)</span> 的一组标准正交基。因此，扩展前述奇异值分解式即有 <span class="math display">\[\begin{pmatrix}\boldsymbol{u}_1^T \\\vdots \\\boldsymbol{u}_m^T\end{pmatrix}\boldsymbol{A}(\boldsymbol{v}_1, \cdots, \boldsymbol{v}_n)= \begin{pmatrix}\boldsymbol{\Sigma}_r &amp; \boldsymbol{0}^T \\\boldsymbol{0} &amp; \boldsymbol{O}\end{pmatrix}= \boldsymbol{\Sigma}\]</span> 令 <span class="math inline">\(\boldsymbol{U} = (\boldsymbol{u}_1, \cdots, \boldsymbol{u}_m)\)</span>，<span class="math inline">\(\boldsymbol{V} = (\boldsymbol{v}_1, \cdots, \boldsymbol{v}_n)\)</span>，即有 <span class="math inline">\(\boldsymbol{A} = \boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^T\)</span>。 由此可知，矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 必存在奇异值分解。</p></blockquote><p>根据矩阵的奇异值分解定理，对于中心化图像矩阵 <span class="math inline">\(\boldsymbol{X}\)</span>，我们有 <span class="math display">\[\begin{aligned}\boldsymbol{X}^T \boldsymbol{X} &amp;= \left( \boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^T \right)^T \left( \boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^T \right) \\&amp;= \boldsymbol{V} \boldsymbol{\Sigma} \boldsymbol{V}^T\end{aligned}\]</span> 也即 <span class="math inline">\(\boldsymbol{X}^T \boldsymbol{X} \boldsymbol{V} = \boldsymbol{V} \boldsymbol{\Sigma}\)</span>。由此我们得知协方差矩阵的第 <span class="math inline">\(i\)</span> 个特征向量也即右奇异值矩阵 <span class="math inline">\(\boldsymbol{V}\)</span> 的第 <span class="math inline">\(i\)</span> 列。</p><p>基于奇异值分解的PCA图像压缩算法具体流程如下：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/svd_pca_alg.png" class="" title="svd_pca_alg"><p>同样的，我们使用Python实现了上述算法。对于奇异值分解操作，我们使用Numpy模块中提供的<strong>svd()</strong>函数来完成。Numpy模块使用了LAPACK科学计算包来完成矩阵分解的相关操作。其中，SVD分解采用了<strong>Householder变换</strong>的方式来完成，这一操作的时间开销远低于一般的采用<strong>Gram-Schimdt正交化</strong>的求解方式，也远低于对协方差矩阵作特征值分解的时间开销。</p><h3 id="dpca">2DPCA</h3><p>由于常规的PCA方法是对向量组进行操作，因此当我们使用该方法对图像进行压缩时，需要先将其划分为列向量组再进行处理。由此得到的协方差矩阵规模十分巨大，需要极大的时间开销来完成计算。此外，由于图像压缩通常被作为其他图像处理任务的上游任务，如此操作会导致图像的特征信息出现大量的丢失。因此，之后的研究者提出了另一种简单的图像投影技术，称为<strong>二维主成分分析(2DPCA)</strong>，专门用于图像特征提取。与传统的PCA方法不同，2DPCA基于2D矩阵直接构建图像的协方差矩阵。与PCA的协方差矩阵相比，使用2DPCA的图像协方差矩阵的大小要小得多，这就意味着确定相应的特征向量所需的时间更少。此外，由于其更多的利用了图像的空间信息，对图像的特征也能够更好的保留。</p><p>2DPCA的主要思想是直接利用一个 <span class="math inline">\(n \times k\)</span> 维矩阵对整张图像进行投影。这里我们先考虑投影矩阵为一维时的情况，再将其推广到 <span class="math inline">\(k\)</span> 维上去。</p><p>若设图像矩阵为 <span class="math inline">\(\boldsymbol{A}\)</span>，<span class="math inline">\(\boldsymbol{X}\)</span> 为投影向量，<span class="math inline">\(\boldsymbol{Y} = \boldsymbol{AX}\)</span> 为投影后的特征。则 <span class="math inline">\(\boldsymbol{Y}\)</span> 的协方差矩阵 <span class="math inline">\(\boldsymbol{S}_x\)</span> 可以写为 <span class="math display">\[\begin{aligned}\boldsymbol{S}_x &amp;= E \left[(\boldsymbol{Y} - E[\boldsymbol{Y}])(\boldsymbol{Y} - E[\boldsymbol{Y}])^T \right] \\&amp;=E \left[(\boldsymbol{AX} - E[\boldsymbol{AX}])(\boldsymbol{AX} - E[\boldsymbol{AX}])^T \right] \\&amp;= E \left[((\boldsymbol{A} - E[\boldsymbol{A}]) \boldsymbol{X})((\boldsymbol{A} - E[\boldsymbol{A}]) \boldsymbol{X})^T \right]\end{aligned}\]</span> 与一般的PCA方法类似，我们定义判断投影好坏的评价指标为 <span class="math inline">\(J(\boldsymbol{X}) = \textrm{tr} (\boldsymbol{S}_x)\)</span>，则代入上面的式子就可以写为 <span class="math display">\[\begin{aligned}J(\boldsymbol{X}) &amp;= \textrm{tr} (\boldsymbol{S}_x) \\&amp;= \boldsymbol{X}^T E \left[ (\boldsymbol{A} - E[\boldsymbol{A}])^T (\boldsymbol{A} - E[\boldsymbol{A}]) \right] \boldsymbol{X}\end{aligned}\]</span> 。从上面的式子我们可以看出，2DPCA通常是同时作用于多张图像矩阵上的，这也是其协方差矩阵维度相对较小的原因。若设图像集合为 <span class="math inline">\(\boldsymbol{A}_1, \cdots, \boldsymbol{A}_M\)</span>，则 <span class="math display">\[\begin{aligned}\boldsymbol{G} &amp;\overset{def}{=} E \left[ (\boldsymbol{A} - E[\boldsymbol{A}])^T (\boldsymbol{A} - E[\boldsymbol{A}]) \right] \\&amp;= \frac{1}{M} \sum_{i = 1}^M \left( \boldsymbol{A}_i - \bar{\boldsymbol{A}} \right)^T \left( \boldsymbol{A}_i - \bar{\boldsymbol{A}} \right)\end{aligned}\]</span> 现在我们将投影矩阵推广为 <span class="math inline">\(k\)</span> 维，也即设投影矩阵为 <span class="math inline">\(\boldsymbol{X} = \{\boldsymbol{X}_1, \cdots, \boldsymbol{X}_d \}\)</span>，则优化问题为 <span class="math display">\[\begin{aligned}\min \quad &amp; - J(\boldsymbol{X}) \\\textbf{s.t} \quad &amp; \boldsymbol{X}_i^T \boldsymbol{X}_j = 0, i \neq j\end{aligned}\]</span> 由拉格朗日乘子法我们可以得知，要提取前 <span class="math inline">\(k\)</span> 个特征，投影矩阵的最优解即为 <span class="math inline">\(\boldsymbol{G}\)</span> 前 <span class="math inline">\(k\)</span> 大个特征值对应的特征向量所组成的矩阵。</p><p>由此我们就得到了使用2DPCA进行图像压缩的一般算法：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/2d_pca_alg.png" class="" title="2d_pca_alg"><p>在选择了不同主成分个数时，使用2DPCA算法进行图像压缩的效果结果如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/2d_pca_pic.png" class="" title="2d_pca_pic"><h3 id="d-2dpca">2D-2DPCA</h3><p>在上述介绍的2DPCA中，若我们用 <span class="math inline">\(\boldsymbol{A}^{(t)}\)</span> 来表示矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 的第 <span class="math inline">\(t\)</span> 行，则 <span class="math display">\[\begin{aligned}\boldsymbol{A}_i &amp;= \left( \left( \boldsymbol{A}_i^{(1)} \right)^T,  \cdots, \left( \boldsymbol{A}_i^{(n)} \right)^T \right)^T \\\bar{\boldsymbol{A}} &amp;= \left( \left( \bar{\boldsymbol{A}}^{(1)} \right)^T,  \cdots, \left( \bar{\boldsymbol{A}}^{(n)} \right)^T \right)^T\end{aligned}\]</span> ，于是协方差矩阵 <span class="math inline">\(\boldsymbol{G}\)</span> 就可以被写为 <span class="math display">\[\boldsymbol{G} = \frac{1}{M} \sum_{i = 1}^M \sum_{k = 1}^n \left( \boldsymbol{A}_i^{(k)} - \bar{\boldsymbol{A}}^{(k)}\right)^T \left( \boldsymbol{A}_i^{(k)} - \bar{\boldsymbol{A}}^{(k)}\right)\]</span> 。通过该式我们可以发现，<span class="math inline">\(\boldsymbol{G}\)</span> 可以通过图像集合中行向量的外积得到，这也就意味着2DPCA实际上仅按行提取了图像之间的联系。自然的，我们可以想到是否可以用类似的方法提取图像列之间的联系并将它们结合在一起，从而挖掘出图像更多的特征联系。这一想法也就形成了所谓的<strong>双方向二维主成分分析（2D-2DPCA）</strong>。</p><p>我们设 <span class="math inline">\(\boldsymbol{Z} \in \mathbb{R}^{n \times k}\)</span> 为另一投影矩阵，其作用即为对图像矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 的列进行投影。于是与2DPCA的做法类似，我们设矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 投影得到的特征为 <span class="math display">\[\boldsymbol{B} = \boldsymbol{Z}^T \boldsymbol{A}\]</span> 。于是投影得到的协方差矩阵即为 <span class="math display">\[J(\boldsymbol{Z}) = \boldsymbol{Z}^T E \left[ (\boldsymbol{A} - E[\boldsymbol{A}]) (\boldsymbol{A} - E[\boldsymbol{A}])^T \right] \boldsymbol{Z}\]</span> 我们定义 <span class="math display">\[\begin{aligned}\boldsymbol{G}&#39; &amp;\overset{def}{=} E \left[ (\boldsymbol{A} - E[\boldsymbol{A}]) (\boldsymbol{A} - E[\boldsymbol{A}])^T \right] \\&amp;= \frac{1}{M} \sum_{i = 1}^M  \left( \boldsymbol{A}_i - \bar{\boldsymbol{A}} \right) \left( \boldsymbol{A}_i - \bar{\boldsymbol{A}} \right)^T \\&amp;= \frac{1}{M} \sum_{i = 1}^M \sum_{k = 1}^n \left( \boldsymbol{A}_i^{(k)} - \bar{\boldsymbol{A}}^{(k)}\right) \left( \boldsymbol{A}_i^{(k)} - \bar{\boldsymbol{A}}^{(k)}\right)^T\end{aligned}\]</span> 其中 <span class="math inline">\(\boldsymbol{A}^{(t)}\)</span> 为矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 的第 <span class="math inline">\(t\)</span> 列。</p><p>与上面类似，我们最大化 <span class="math inline">\(J(\boldsymbol{Z})\)</span>，同样可以得到 <span class="math inline">\(\boldsymbol{Z}\)</span> 的最优解即为 <span class="math inline">\(\boldsymbol{G}\)</span> 的前 <span class="math inline">\(k\)</span> 大个特征值对应的特征向量所组成的矩阵。</p><p>将行投影和列投影结合，我们就能得到图像集合中的任一图像 <span class="math inline">\(\boldsymbol{A}\)</span> 经过投影后的特征为 <span class="math display">\[\boldsymbol{C} = \boldsymbol{Z}^T \boldsymbol{A} \boldsymbol{Z}\]</span> ，其重构图像为 <span class="math display">\[\tilde{\boldsymbol{A}} = \boldsymbol{Z} \boldsymbol{C} \boldsymbol{X}^T\]</span> 。由此我们就得到了使用2D-2DPCA进行图像压缩的一般算法：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/2d_2d_pca_alg.png" class="" title="2d_2d_pca_alg"><p>在选择了不同主成分个数时，使用2D-2DPCA算法进行图像压缩的效果结果如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/2d2d_pca_pic.png" class="" title="2d2d_pca_pic"><h3 id="generalized-hebbian-algorithm">Generalized Hebbian Algorithm</h3><p>可以看到，上面几种PCA方法均为基于矩阵分解的求解方法。近年来随着机器学习和神经网络模型的提出，研究者也提出了基于学习的方法来快速提取数据集的主成分。其中较为典型的即为基于Gram-Schmidt正交化方法的<strong>扩展Hebbian算法（Generalized Hebbian Algorithm）</strong>。GHA算法是一种无监督的学习算法，我们可以将其看作Oja方法的一种推广。</p><p>首先我们构建一个单层全连接神经网络（Single-layer Feed Forward Neural Network），如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/gha_network.png" class="" title="gha_network"><p>可以证明，通过GHA算法对该神经网络进行权重调整，则训练完成后，连接每个输出神经元的权重向量即为一个主成分向量。</p><p>首先我们考虑输出层只有 <span class="math inline">\(1\)</span> 个神经元的情况。若设第 <span class="math inline">\(t\)</span> 次迭代的输入向量为 <span class="math inline">\(\boldsymbol{x}_t \in \mathbb{R}\)</span>，网络的权重向量为 <span class="math inline">\(\boldsymbol{w}_t \in \mathbb{R}^n\)</span>，输出 <span class="math inline">\(y_t = \boldsymbol{w}_t^T \boldsymbol{x}_t\)</span>，<span class="math inline">\(\eta\)</span> 为学习率。则根据Oja方法，权重更新公式为 <span class="math display">\[\boldsymbol{w}_{t + 1} = \boldsymbol{w}_{t} + \eta \boldsymbol{y}_{t} (\boldsymbol{x}_{t} - \boldsymbol{y}_{t} \boldsymbol{w}_{t})\]</span> 。现在我们将其推广到 <span class="math inline">\(k\)</span> 个输出时的情况，即求解前 <span class="math inline">\(k\)</span> 个主成分。设 <span class="math inline">\(\boldsymbol{W}_t \in \mathbb{R}^{k \times n}\)</span>，输出 <span class="math inline">\(\boldsymbol{y}_t = \boldsymbol{W}_t \boldsymbol{x}_t\)</span>，则 <span class="math display">\[\boldsymbol{W}_{t + 1} = \eta \left( \boldsymbol{y}_t \boldsymbol{x}_t^T - \textrm{LOWER}(\boldsymbol{y}_t \boldsymbol{y}_t^T) \boldsymbol{W}_t \right)\]</span> ，其中 <span class="math inline">\(\textrm{LOWER}(\boldsymbol{A})\)</span> 为取矩阵 <span class="math inline">\(\boldsymbol{A}\)</span> 的下三角操作（上三角部分置为 <span class="math inline">\(0\)</span>）。</p><p>于是，使用GHA进行图像压缩的算法流程如下：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/gha_alg.png" class="" title="gha_alg"><p>对于训练结果的评价指标，我们定义损失函数 <span class="math display">\[\mathcal{L}(\boldsymbol{W}, \boldsymbol{Q}) = \sum_{i = 1}^k ||\boldsymbol{w}_i - \boldsymbol{q}_i||^2 = ||\boldsymbol{W} - \boldsymbol{Q}||_F^2\]</span> 及向量夹角 <span class="math display">\[\mathcal{A}(\boldsymbol{w}_i, \boldsymbol{q}_i) = \arccos \left(  \frac{\boldsymbol{w}_i \cdot \boldsymbol{q}_i}{|| \boldsymbol{w}_i ||_2 \cdot ||\boldsymbol{q}_i||_2} \right)\]</span> 由于该算法的收敛速度较为不可控，因此这里我们仅使用网络提取前两个主成分。我们使用正态分布 <span class="math inline">\(\mathcal{N}(0, 0.5)\)</span> 随机初始化了权重矩阵，并设置学习率 <span class="math inline">\(\eta = 10^{-4}\)</span> 进行了两次模拟，每次对网络进行了 <span class="math inline">\(20000\)</span> 次训练迭代。两次迭代过程中Loss和向量夹角的变化情况如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/gha_pca_exp1.png" class="" title="gha_pca_exp1"><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/gha_pca_exp2.png" class="" title="gha_pca_exp2"><p>可以发现，随着权重矩阵初始值的不同，网络的收敛特征也会随之发生变化。</p><p>使用神经网络算法进行模型训练时一个经典的问题即为学习率过大。事实上，在训练该模型的过程中，我们同样遇到了这一问题，并且固定的学习率很难保证适合整个损失超平面。为此，研究者提出了适用于GHA的自适应学习率优化方法。由于该方法实现过于复杂，在此仅作为了解。</p><h3 id="kernel-pca">Kernel PCA</h3><p>由PCA的推导过程我们可以看出，要对一个数据集使用PCA方法进行降维的一大前提即为数据集必须在当前维度下线性可分，而类似图像这样高度紧凑的数据集通常会出现线性不可分的问题。在这种情况下，我们通常会尝试使用一个映射 <span class="math inline">\(\phi: \mathbb{R}^n \to \mathbb{R}^d, d &gt; n\)</span> 将数据集映射到更高维度的特征空间，使得其在该空间下线性可分，该方法被称为<strong>核方法（Kernel Method）</strong>。利用核方法，我们可以对朴素的PCA方法进行改进，使其能够表达更多的原始特征，这就形成了所谓的<strong>核主成分分析（Kernel PCA）</strong>。</p><p>若设图像矩阵为 <span class="math inline">\(\boldsymbol{X}\)</span>，非线性映射 <span class="math inline">\(\phi(\boldsymbol{X})\)</span> 对应的核函数 <span class="math inline">\(\boldsymbol{K} = \phi(\boldsymbol{X})^T \phi(\boldsymbol{X})\)</span>，特征空间为 <span class="math inline">\(\mathcal{F}\)</span>，则特征空间中的协方差矩阵就可以写为 <span class="math display">\[\boldsymbol{C}_{\mathcal{F}} = \frac{1}{N} \phi(\boldsymbol{X}) (\phi(\boldsymbol{X}))^T\]</span> 其特征值问题的方程 <span class="math inline">\(\boldsymbol{C}_{\mathcal{F}} \boldsymbol{v} = \lambda \boldsymbol{v}\)</span> 就可以写为 <span class="math display">\[\sum_{i = 1}^N \phi(\boldsymbol{x}_i) \phi(\boldsymbol{x}_i)^T \boldsymbol{v} = \lambda \boldsymbol{v}\]</span> 由此我们发现其每一个特征向量 <span class="math inline">\(\boldsymbol{v}_j\)</span> 都可以表示为 <span class="math inline">\(\phi(\boldsymbol{x}_i)\)</span> 的线性组合 <span class="math display">\[\boldsymbol{v} = \sum_{i = 1}^N a_i \phi(\boldsymbol{x}_i) = \phi (\boldsymbol{X}) \boldsymbol{a}\]</span> ，其中 <span class="math inline">\(\boldsymbol{a} = (a_1, \cdots, a_N)^T\)</span>。 引入核函数，化简即可得到 <span class="math display">\[\boldsymbol{K}(\boldsymbol{X}) \boldsymbol{a} = \lambda \boldsymbol{a}\]</span> ，也即经过特征空间所得的降维变换向量即为矩阵 <span class="math inline">\(\boldsymbol{K}\)</span> 的特征向量。</p><p>使用Kernel PCA进行图像压缩时所涉及的变换如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/kernel_pca.png" class="" title="kernel_pca"><p>通常来说，核函数要求矩阵为正定矩阵。在本文中，我们实现了以下几种核函数：</p><ul><li><strong>线性核（Linear Kernel）</strong></li></ul><p><span class="math display">\[\boldsymbol{K}(\boldsymbol{x}, \boldsymbol{y}) = \boldsymbol{x}^T \boldsymbol{y}\]</span></p><ul><li><strong>多项式核（Polynomial Kernel）</strong></li></ul><p><span class="math display">\[\boldsymbol{K}(\boldsymbol{x}, \boldsymbol{y}) = \left( \boldsymbol{x}^T \boldsymbol{y} + c \right)^d\]</span></p><ul><li><strong>高斯核（Gaussian Kernel/Radial Basis Function Kernel）</strong></li></ul><p><span class="math display">\[\boldsymbol{K}(\boldsymbol{x}, \boldsymbol{y}) = \exp \left( - \frac{|| \boldsymbol{x} - \boldsymbol{y} ||^2}{2 \sigma^2} \right) = \exp \left( - \gamma || \boldsymbol{x} - \boldsymbol{y} ||^2 \right)\]</span></p><ul><li><strong>指数核（Exponential Kernel）</strong></li></ul><p><span class="math display">\[\boldsymbol{K}(\boldsymbol{x}, \boldsymbol{y}) = \exp \left( - \frac{|| \boldsymbol{x} - \boldsymbol{y} ||}{2 \sigma^2} \right) = \exp \left( - \gamma || \boldsymbol{x} - \boldsymbol{y} || \right)\]</span></p><ul><li><strong>ANOVA核</strong></li></ul><p><span class="math display">\[\boldsymbol{K}(\boldsymbol{x}, \boldsymbol{y}) = \exp \left( -\sigma \left( \boldsymbol{x}^k - \boldsymbol{y}^k \right)^2 \right)^d\]</span></p><ul><li><strong>Sigmoid核</strong></li></ul><p><span class="math display">\[\boldsymbol{K}(\boldsymbol{x}, \boldsymbol{y}) = \tanh \left( a \boldsymbol{x}^T \boldsymbol{y} + r \right)\]</span></p><p>对于部分核函数，我们还需要给定合适的超参数以达到最好的特征提前效果。以高斯核为例，我们采用网格搜索的方式来选取合适的超参数 <span class="math inline">\(\gamma\)</span>。图像的重构误差随 <span class="math inline">\(\gamma\)</span> 的变化如下图所示：（左一）</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/rbf_param.png" class="" title="rbf_param"><p>可以看到，随着 <span class="math inline">\(\gamma\)</span> 值的增大，图像的重构误差逐渐减少。然而这并不意味着 <span class="math inline">\(\gamma\)</span> 值越大越好，这是由于当 <span class="math inline">\(\gamma\)</span> 值过大时，模型会出现<strong>过拟合（overfitting）</strong>的问题。具体来说，当 <span class="math inline">\(\gamma\)</span> 值过大时，核函数 <span class="math display">\[\boldsymbol{K}(\boldsymbol{x}, \boldsymbol{y}) \approx\left\{\begin{aligned}&amp;e^0 = 1 &amp;,\boldsymbol{x} = \boldsymbol{y} \\&amp;e^{-\infty} = 0 &amp;,\boldsymbol{x} \neq \boldsymbol{y}\end{aligned}\right.\]</span> ，此时核矩阵退化为 <span class="math inline">\(\boldsymbol{I}_n\)</span>，也即单位变换。这就导致了降维空间成为原空间的一个子空间，自然就失去了特征提取的功能。</p><p>若设核矩阵 <span class="math inline">\(\boldsymbol{K}\)</span> 的前 <span class="math inline">\(k\)</span> 个特征值为 <span class="math inline">\(\lambda_1, \cdots, \lambda_k\)</span>，我们定义其方差（该指标衡量了特征值的分散程度）为 <span class="math display">\[Var(\lambda_1, \cdots, \lambda_k) = \frac{1}{k} \sum_{i = 1}^k \left(\lambda_i - \bar{\lambda} \right)^2\]</span> ，则核矩阵方差及核矩阵行列式的值如图所示（上图左二、左三）。易见当 <span class="math inline">\(\gamma \gg 10^{-3}\)</span> 时，核矩阵的方差趋近于 <span class="math inline">\(0\)</span>，其行列式趋近于 <span class="math inline">\(1\)</span>，这也印证了上述的理论论述，表明模型确实出现了过拟合。</p><p>可以看到，由于核函数基本都为非线性函数，其逆变换通常难以求得。因此使用核方法对数据集进行降维的一个很大的问题在于对数据集进行重构，这对于图像压缩问题来说是十分不友好的。</p><p>若设 <span class="math inline">\(\mathcal{H}_K\)</span> 为核 <span class="math inline">\(\boldsymbol{K}(\boldsymbol{x}, \boldsymbol{y})\)</span> 所生成的再生希尔伯特核空间，其对应的特征变换 <span class="math inline">\(\phi(\boldsymbol{x}): \mathbb{R}^n \to \mathcal{H}_k\)</span>，则图像重构问题即为给定 <span class="math inline">\(\mathcal{H}_K\)</span> 中的一点 <span class="math inline">\(\boldsymbol{\Psi}\)</span>，求输入空间中的一点 <span class="math inline">\(\boldsymbol{z} \in \mathbb{R}^n\)</span>，使得 <span class="math display">\[\boldsymbol{z} = \mathop{\arg\min}_{\boldsymbol{z}} || \boldsymbol{\Psi} - \phi (\boldsymbol{z}) ||^2\]</span> 事实上自Kernel PCA被提出以来，已经有大量的研究提出了一系列对KPCA降维后数据进行重构的方法，这些方法大多都是基于近似拟合的方法。其中，基于<strong>梯度下降（Gradient Descent）</strong>的方法和基于<strong>回归（Regression）</strong>的方法是两大较为有代表性的求解方法。由于这一过程实现过于复杂，我们直接使用了Scikit-Learn工具包中提供的<strong>inverse_transform()</strong>函数来完成。</p><p>使用Kernel PCA进行图像压缩的算法流程如下：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/kpca_alg.png" class="" title="kpca_alg"><p>以高斯核为例，在选择了不同主成分个数时，使用Kernel PCA算法进行图像压缩的效果结果如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/kernel_pca_pic.png" class="" title="kernel_pca_pic"><p>可以发现，与朴素PCA方法不同，当选择的主成分个数为10时图像的主要特征仍然没有得到恢复，而当 <span class="math inline">\(k=50\)</span> 时，图像的质量得到了极大的改善。这也表明经过变换后的数据集在核空间下的特征分离方式与原空间下是不同的。</p><h3 id="jpeg">JPEG</h3><p>上面使用的几种图像压缩算法均为即为基于PCA的方法。事实上，在日常场景下，人们更常使用基于信号处理和特殊编码的方法来对图像进行压缩。其中较为典型的代表即为基于离散余弦变换的<strong>JPEG（JFIF）算法</strong>。</p><p>JPEG图像压缩算法的具体流程如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/jpeg_pipeline.png" class="" title="jpeg_pipeline"><p>压缩算法主要分为如下几个步骤：</p><ul><li><p><span class="math inline">\(RGB \to YC_bC_r\)</span> <strong>空间转换</strong></p></li><li><p><strong>下采样</strong></p></li><li><p><strong>图像分割</strong></p></li><li><p><strong>离散余弦变换</strong></p></li><li><p><strong>数据量化</strong></p></li><li><p><strong>Huffman编码</strong></p></li></ul><p>使用JPEG算法进行图像压缩的效果结果如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/jpeg_pic.png" class="" title="jpeg_pic"><p>可以看到，尽管JPEG为有损压缩算法，重构后的图片与原图几乎看不到可见的差异，这也从一定程度上解释了该算法流行的原因。</p><p>事实上，近年来的许多压缩方法还会将JPEG算法及其变体JPEG2000与PCA方法相结合，从而进一步提高压缩率及重构的准确率。例如在高光谱成像领域，由于原始图像通常还会附带许多频谱信息，将这两种方法相结合可以极大的压缩存储图像所需的空间，从而减少数据传输的开销。</p><h2 id="实验结果">实验结果</h2><p>前文中我们提及了一系列图像压缩的方法，现在我们从<strong>压缩率</strong>、<strong>重构质量</strong>和压缩耗时三个维度来对上述提及的所有方法进行分析和比较。</p><p>图像的压缩率被定义为 <span class="math display">\[\eta = 1 - \frac{\textrm{Size}(\tilde{\boldsymbol{X}}) + \textrm{Size}(\boldsymbol{Q})}{\textrm{Size}(\boldsymbol{X})}\]</span> ，其中 <span class="math inline">\(\textrm{Size}(\boldsymbol{A})\)</span> 为 <span class="math inline">\(\boldsymbol{A}\)</span> 的空间度量，<span class="math inline">\(\boldsymbol{X}\)</span> 为原始图像，<span class="math inline">\(\tilde{\boldsymbol{X}}\)</span> 为重构图像，<span class="math inline">\(\boldsymbol{Q}\)</span> 为重构变换矩阵。</p><p>以 <span class="math inline">\(k = 50\)</span> 为例，本文中实现的不同算法的压缩率如下表所示：</p><table><thead><tr class="header"><th>压缩算法</th><th>单张图片压缩率</th><th>100张图片压缩率</th><th>300张图片压缩率</th></tr></thead><tbody><tr class="odd"><td>PCA</td><td><span class="math inline">\(60.94\%\)</span></td><td><span class="math inline">\(60.94\%\)</span></td><td><span class="math inline">\(60.94\%\)</span></td></tr><tr class="even"><td>2DPCA</td><td><span class="math inline">\(60.94\%\)</span></td><td><span class="math inline">\(80.27\%\)</span></td><td><span class="math inline">\(80.40\%\)</span></td></tr><tr class="odd"><td>2D-2DPCA</td><td><span class="math inline">\(41.41\%\)</span></td><td><span class="math inline">\(80.08\%\)</span></td><td><span class="math inline">\(80.34\%\)</span></td></tr><tr class="even"><td>Kernel PCA</td><td><span class="math inline">\(60.94\%\)</span></td><td><span class="math inline">\(60.94\%\)</span></td><td><span class="math inline">\(60.94\%\)</span></td></tr><tr class="odd"><td>JPEG</td><td><span class="math inline">\(84.54\%\)</span></td><td><span class="math inline">\(86.09\%\)</span></td><td><span class="math inline">\(87.22\%\)</span></td></tr></tbody></table><p>可以发现，朴素PCA和Kernel PCA对单张图片计算主成分，因此其在单张图片和多张图片上的压缩率相同；而2DPCA和2D-2DPCA由于对整个数据集计算特征，因此随着数据集的增长，总体的图像压缩率逐渐增长。JPEG在所有算法中拥有最高的压缩率。</p><p>对于重构质量，我们使用<strong>均方误差（Mean Square Error）</strong>和<strong>峰值信噪比（Peak Signal-to-Noise Ratio）</strong>来进行评估。其中，原始图像 <span class="math inline">\(\boldsymbol{X}\)</span> 和重构图像 <span class="math inline">\(\tilde{\boldsymbol{X}}\)</span> 间的均方误差被定义为 <span class="math display">\[\textrm{MSE}(\boldsymbol{X}, \tilde{\boldsymbol{X}}) = \frac{1}{N^2} \sum_{i = 1}^N \sum_{j = 1}^N (x_{ij} - \tilde{x}_{ij})^2\]</span> 其之间的峰值信噪比被定义为 <span class="math display">\[\textrm{PSNR}(\boldsymbol{X}, \tilde{\boldsymbol{X}}) = 10 \cdot \log_{10} \left( \frac{\textrm{MAX}_{\boldsymbol{X}}^2}{\textrm{MSE}(\boldsymbol{X}, \tilde{\boldsymbol{X}})}\right)\]</span> ，其中 <span class="math inline">\(\textrm{MAX}_{\boldsymbol{X}}\)</span> 为矩阵 <span class="math inline">\(\boldsymbol{X}\)</span> 每个元素可能的最大值（对于一张 <span class="math inline">\(8\)</span> 位图像即为 <span class="math inline">\(255\)</span>）。</p><p>当 <span class="math inline">\(k\)</span> 为 <span class="math inline">\(50\)</span> 时，使用不同算法进行压缩重构后得到的MSE和PSNR值由下表给出：</p><table><thead><tr class="header"><th>压缩算法</th><th>MSE</th><th>PSNR</th></tr></thead><tbody><tr class="odd"><td>PCA</td><td><span class="math inline">\(47.8774\)</span></td><td><span class="math inline">\(31.3295\)</span></td></tr><tr class="even"><td>2DPCA</td><td><span class="math inline">\(76.1444\)</span></td><td><span class="math inline">\(29.3144\)</span></td></tr><tr class="odd"><td>2D-2DPCA</td><td><span class="math inline">\(90.1605\)</span></td><td><span class="math inline">\(28.5806\)</span></td></tr><tr class="even"><td>Kernel PCA</td><td><span class="math inline">\(11.1868\)</span></td><td><span class="math inline">\(37.6437\)</span></td></tr><tr class="odd"><td>JPEG</td><td><span class="math inline">\(53.2189\)</span></td><td><span class="math inline">\(30.8701\)</span></td></tr></tbody></table><p>更进一步的，当主成分选择数 <span class="math inline">\(k\)</span> 从 <span class="math inline">\(1\)</span> 上升到 <span class="math inline">\(200\)</span> 的过程中，不同算法的重构质量如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/reconstruct_quality.png" class="" title="reconstruct_quality"><p>可以看到，在所有实现的方法中，Kernel PCA在两项指标中均获得了最好的结果。然而，由于其重构变换使用了近似的方法，这一过程并不稳定，因此其误差曲线出现了一定程度的波动。相比较而言，一般的PCA方法两项评价指标随主成分选择数增加的变化十分稳定。</p><p>最后我们来考察不同压缩算法的压缩耗时。压缩耗时的计算公式被定义为 <span class="math display">\[\mathcal{T} = \mathcal{T}_{Compress} + \mathcal{T}_{Reconstruct}\]</span> 其中 <span class="math inline">\(\mathcal{T}_{Compress}\)</span> 为编码耗时，<span class="math inline">\(\mathcal{T}_{Reconstruct}\)</span> 重构耗时。</p><p>不同算法随着待压缩的图片总量从单张到 <span class="math inline">\(100\)</span> 张所用的时间如下图所示：</p><img src="/2021/11/29/machine-learning/dase-alg-exp-pca/time.png" class="" title="time"><p>可以发现，基于特征分解的朴素PCA算法随着数据集的增长进行压缩所用的时间迅速的增大，这是由于其计算协方差矩阵的特征值和特征向量的巨额时间开销。基于奇异值分解的PCA算法由于使用了更为高效的Householder变换算法，其耗时相比特征值分解得到了显著的下降。在我们的实现中，Kernel PCA同样使用了SVD方法进行优化，但其时间开销仍然十分巨大，表明其主要耗时在图像重构上。2DPCA和2D-2DPCA由于对整个数据集进行统一变换，因此在多张图像数据集上拥有极高的压缩效率。</p><h2 id="结论">结论</h2><p>在本实验中，我们完整推导并实现了<strong>基于特征值分解的 PCA 算法</strong>、基于奇异值分解的 PCA 算法、<strong>基于 GHA 的 PCA 算法</strong>、<strong>2DPCA 算法</strong>、<strong>2D-2DPCA 算法</strong>、<strong>Kernel PCA 算法</strong>及 <strong>JPEG 算法</strong>，并将它们应用于图像压缩任务中。经过比较我们可以发现，在不同的度量标准下， 不同的算法均有着相应的优势和劣势。一般的 PCA 算法具有较好的稳定性和可解释性，2DPCA 和 2D-2DPCA 算法拥有较高的压缩效率，Kernel PCA 算法拥有较高的重构精度。这也表明这些 方法没有严格的好坏之分，在不同任务下需要根据实际情况选择合适的方法。</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>Daniel Báscones, Carlos González, and Daniel Mozos. Hyperspectral image compression using vector quantization, pca and jpeg2000. Remote sensing, 10(6):907, 2018.</li><li>Liang-Hwa Chen and Shyang Chang. An adaptive learning algorithm for principal component analysis. IEEE Transactions on Neural Networks, 6(5):1255–1263, 1995.</li><li>COMP-652 and ECSE-608. Dimensionality reduction. pca. kernel pca. https://www.cs.mcgill.ca/~dprecup/courses/ML/Lectures/ml-lecture13.pdf, 2016.</li><li>Alberto García-González, Antonio Huerta, Sergio Zlotnik, and Pedro Díez. A kernel principal component analysis (kpca) digest with a new backward mapping (pre-image reconstruction) strategy, 2021.</li><li>Matt Gormley. Deriving principal component analysis (pca). https://www.cs.cmu. edu/~mgormley/courses/606-607-f18/slides606/lecture11-pca.pdf, October 2018.</li><li>R.B. Lehoucq. The computation of elementary unitary matrices. Technical report, University of Tennessee, 1994.</li><li>Graphics Mill. Working with jpeg. https://www.graphicsmill.com/docs/gm/ working-with-jpeg.htm.</li><li>Sebastian Mika, Bernhard Schölkopf, Alex Smola, Klaus-Robert Müller, Matthias Scholz, and Gunnar Rätsch. Kernel pca and de-noising in feature spaces. In M. Kearns, S. Solla, and D. Cohn, editors, Advances in Neural Information Processing Systems, volume 11. MIT Press, 1999.</li><li>Erkki Oja. Simplified neuron model as a principal component analyzer. Journal of mathematical biology, 15(3):267–273, 1982.</li><li>Terence D. Sanger. Optimal unsupervised learning in a single-layer linear feedforward neural network, 1989.</li><li>Bernhard Schölkopf, Alexander Smola, and Klaus-Robert Müller. Nonlinear component analysis as a kernel eigenvalue problem. Neural Computation, 10(5):1299–1319, 1998.</li><li>Wikipedia contributors. Jpeg — Wikipedia, the free encyclopedia. https://en.wikipedia.org/w/index.php?title=JPEG&amp;oldid=1056557277, 2021. [Online; accessed 23-November-2021].</li><li>Wikipedia contributors. Singular value decomposition — Wikipedia, the free encyclopedia. https://en.wikipedia.org/w/index.php?title=Singular_value_decomposition&amp;oldid=1055826758, 2021. [Online; accessed 24-November-2021].</li><li>Chih-Wen Wang and Jyh-Horng Jeng. Image compression using pca with clustering. In 2012 International Symposium on Intelligent Signal Processing and Communications Systems, pages 458–462, 2012.</li><li>Frank Wood. http://www.stat.columbia.edu/~fwood/Teaching/w4315/Fall2009/pca.pdf, December 2009.</li><li>Jason Weston, Bernhard Schölkopf, and Gökhan Bakir. Learning to find pre-images. In S. Thrun, L. Saul, and B. Schölkopf, editors, Advances in Neural Information Processing Systems, volume 16. MIT Press, 2004.</li><li>Jian Yang, D. Zhang, A.F. Frangi, and Jing yu Yang. Two-dimensional pca: a new approach to appearance-based face representation and recognition. IEEE Transactions on Pattern Analysis and Machine Intelligence, 26(1):131–137, 2004.</li><li>Daoqiang Zhang and Zhi-Hua Zhou. (2d)2pca: Two-directional two-dimensional pca for eﬀicient face representation and recognition. Neurocomputing, 69(1):224–231, 2005. Neural Networks in Signal Processing.</li><li>周志华. 机器学习. 清华大学出版社, 2016.</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据科学算法基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Machine-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻宝游戏(MongoDB)</title>
    <link href="/2021/10/08/database/db-assignment-1/"/>
    <url>/2021/10/08/database/db-assignment-1/</url>
    
    <content type="html"><![CDATA[<h2 id="实验要求">实验要求</h2><p>考虑以下游戏场景：</p><p>每个游戏玩家都有一定数量的金币、宝物。有一个市场供玩家们买卖宝物。玩家可以将宝物放到市场上挂牌，自己确定价格。其他玩家支付足够的金币，可购买宝物。</p><p>宝物分为两类:一类为工具，它决定持有玩家的工作能力;一类为配饰，它决定持有玩家的运气。</p><p>每位玩家每天可以通过寻宝获得一件宝物，宝物的价值由玩家的运气决定。每位玩家每天可以通过劳动赚取金币，赚得多少由玩家的工作能力决定。（游戏中的一天可以是现实中的 1 分钟、5 分钟、10 分钟，自主设定。）</p><p>每个宝物都有一个自己的名字（尽量不重复）。每位玩家能够佩戴的宝物是有限的（比如一个玩家只能佩戴一个工具和两个配饰）。多余的宝物被放在存储箱中，不起作用，但可以拿到市场出售。</p><p>在市场上挂牌的宝物必须在存储箱中并仍然在存储箱中，直到宝物被卖出。挂牌的宝物可以被收回，并以新的价格重新挂牌。当存储箱装不下时，运气或工作能力值最低的宝物将被系统自动回收。</p><p>假设游戏永不停止而玩家的最终目的是获得最好的宝物。</p><p>请根据以上场景构建一个假想的 Web 游戏，可供多人在线上玩耍。后台的数据库使用 MongoDB。对游戏玩家提供以下几种操作：寻宝（可以自动每天一次）、赚钱（可以自动每天一 次）、佩戴宝物、浏览市场、买宝物、挂牌宝物、收回宝物。</p><h2 id="实验过程">实验过程</h2><h3 id="网站构架">网站构架</h3><p>本次寻宝游戏网站的整体构架如下图所示。</p><figure><img src="system_structure.png" alt="system_structure" /><figcaption aria-hidden="true">system_structure</figcaption></figure><p>由于游戏平台通常会由多个不同的模块构成，且需要不断的迭代和集成，因此我们采用了前后端分离的架构来设计网站。整个网站分为 四个部分，分别为前端维生服务器、前端页面、后端请求服务器及服务器数据库。</p><p>对于前端维生服务器，我们使用了基于 NodeJS 的经典 Web 服务器维持框架 Express。这一 框架提供了一个快速的 Web 应用搭建流程，我们只需要直接将前端页面框架生成的相关资源统 一放在相应的位置，Express 就会帮我们自动托管之后的服务器维持事务。</p><p>对于前端页面，我们使用了经典的 Vue 3 框架来进行搭建。这一框架提供了一整套完善的 UI 及前后端交互流程，可以十分清晰的梳理出各个模块之间的继承及通信关系，方便后续维护。对于 UI 样式，我们使用了基于 Vue 3 的 Quasar Framework 2 框架，这一框架支持流式数据加载 及响应式的交互访问，可以吸引用户访问并使用该平台。</p><p>由于需要应对各种不同的情况，后端服务器由多个模块联合构成。首先，我们使用了 Flask 作为容器实现框架，并通过蓝图（Blueprint）功能将接口分摊至五个子接口集合上以实现业务隔离。随后，由于我们使用了前后端分离架构，自然会涉及到跨域问题。因此我们在请求处理接口 上加上了一层 CORS 包装器。最后，为了应对高并发请求，我们使用了 Gunicorn 网关容器对全 应用进行了封装，并对 Flask 开启了多线程支持。这样在面对高并发请求时系统可以较为均衡的分摊整个负载。</p><p>本次实验使用了 MongoDB 作为服务器存储数据库。作为一个文档型数据库，其类 Json 格 式的数据管理模型更贴近 Web 交互时的数据格式，这使得我们在后续在设计接口数据协议时更为方便。</p><h3 id="数据库设计">数据库设计</h3><h4 id="内嵌存储-v.s-归一化存储">内嵌存储 v.s 归一化存储</h4><p>对于当前应用，我们主要需要存储以下几种数据:系统中可用的宝物及其价值、用户的各种 基本信息、用户正在佩戴的物品、用户当前拥有的物品、市场上正在出售的宝物。</p><p>对于文档型数据库，一个最直接的想法便是将所有的用户数据全部存储在同一个集合中。因此，对于当前应用，一个可能的数据库设计如下图所示。</p><figure><img src="embed_db.png" alt="embed_db" /><figcaption aria-hidden="true">embed_db</figcaption></figure><p>其中，用户已佩戴的物品及储物箱中的物品被以数组的形式嵌入用户集合中。这样做的好处是在每次用户访问其拥有物品 时，我们始终能够以 <span class="math inline">\(O(1)\)</span> 的代价（获取到用户文档之后）完成对用户物品查询。然而，当用户想要变更物品的状态时，系统就需要遍历整个数组以找到对应的物品，此时其时间开销便会变得极为糟糕，在最坏情况下甚至能达到 <span class="math inline">\(O(n)\)</span>（获取到用户文档之后），且索引功能很难帮助优化这 一查询代价。此外，这一存储方式会带来大量的数据冗余，且由于宝物的全部信息均被存储在了用户表中，当系统要对宝物信息进行更新时，就需要对所有集合中的所有玩家的每一条宝物数据进行遍历，当用户规模较大时，这一代价将变得十分巨大，且此时可能出现数据不一致的问题， 破坏了数据库的 ACID 原则。</p><p>在数据库设计中，我们通常还会尽可能的让同一数据在所有集合中尽可能只保留一份以减少数据冗余，即所谓的存储归一化（Storage Normalization）。在这种模式下，数据库可以以下图所示的方式设计。</p><figure><img src="normalize_db.png" alt="normalize_db" /><figcaption aria-hidden="true">normalize_db</figcaption></figure><p>这样做的好处是极大的减少了数据冗余，且从灾备的角度来看， 即使发生了数据丢失，由于宝物和用户的信息是单独存储的，其数据损失的概率也相对较小。此外，当宝物状态需要发生改变时，我们只需要移动其唯一标识即可进行更改，数据移动的开销较小。然而，由于宝物与用户的信息发生了分离，对于用户的每一件物品，我们都需要至少访问两个集合才能获取到所有需要的数据，而访问不同的集合对于 MongoDB 而言开销是巨大的，因此对于本应用来说仍然不是一个合适的选择。</p><h4 id="缓存型存储">缓存型存储</h4><p>为了解决上面两种方式的问题，对于本应用，我们采用了一种称为缓存型存储（或存储反归一化， Storage Denormalization）的思想来设计本应用的数据库结构。与直接存储不同的是，缓存 型存储是先将数据进行归一化，随后再将数据以最适合访问的方式进行冗余缓存，这样既保证了数据修改时的数据一致性，又使得数据能以较高的效率被访问。 本应用的数据库集合设计如下图所示。</p><figure><img src="denormalize_db.png" alt="denormalize_db" /><figcaption aria-hidden="true">denormalize_db</figcaption></figure><p>其中，用户集合包含了用户的全部基本信息，而宝物集合则维护了当前系统中能够被提供的全部宝物信息。持有物品集合中存储了所有玩家所拥有的物品及其相关状态，其在本应用中既用作玩家存储箱信息的维护，也用作市场上物品信息的维护。此外，根据实际的查询需求，我们对宝物集合的 gain 键建立了索引，对持有物品集合的 owner 和 status 两个键分别建立了索引。</p><p>更具体的，每个集合中各个键的数据类型定义如下表所示。</p><figure><img src="table_db_structure.png" alt="table_db_structure" /><figcaption aria-hidden="true">table_db_structure</figcaption></figure><p>这里需要注意的是，对于用户的头像，我们使用了一个对象标识符类型将其指向一个外部的位置。由于 MongoDB 采用了 BSON 作为其文档存储实现，其最大单个文档的大小限制为 4MB。而若要将用户头像这样的二进制数据直接存储在单个文档中，则很容易超过这一限制导致无法存储。为了解决这一问题，MongoDB 提供了一个名为 GridFS 的存储方案。通过将二进制文件拆分为多 个小块（Chunk，通常为 256KB/个），我们便可以将图片等媒体数据存储在数据库中。因此事实上该应用一共有 5 个集合，额外的两个集合（分别名为 fs.chunks 和 fs.files）分别用于存储 大文件的二进制数据及其块索引。</p><p>作为归一化集合，当数据进行更新时，用户集合和宝物集合拥有最高的更新优先级。持有物品集合作为本应用的缓存集合，包含了玩家可能频繁访问的全部物品数据。因此无论玩家是在访问自己的装备物品、存储箱还是市场上正在出售的物品时，我们都只需要访问持有物品这一个集合，极大地提高了数据查询的效率。</p><p>此外，为了保证数据一致性，在每一次应用启动时，系统都会对缓存集合中的数据进行检查。 由于缓存集合中记录了其他集合相关条目的唯一标识符，因此这一同步是可行的。当管理员需要进行某些更新(例如对某件宝物的属性进行调整时)，系统也会先更新宝物和用户集合，再将数据同步至持有物品集合中。</p><p>可以注意到，这里我们没有单独为市场设计一个缓存集合，这是由于用户查询市场上的物品就等价于查询所有玩家中 status=3 的物品，而我们已经对持有物品集合中的 status 键建立了索引，这一查询的效率是极高的，因此无需再另设一个集合专门对市场上的物品进行缓存。此外， 若再设一个缓存集合，则需要花费更高的代价去解决数据不一致的问题，得不偿失，可见这样做是并不合适的。</p><h4 id="odm-与数据库交互实现">ODM 与数据库交互实现</h4><p>MongoDB 提供了对 Python 的原生访问接口模块 pymongo。通过这一模块，我们可以使用和 命令行中类似的类 JSON 方式对数据库中的对象进行 CRUD（Create-Retrieve-Update-Delete）操作。然而，由于其没有与 Python 中对象的直接映射关系，我们无法快速获知当前操作对数据库及 Python 对象进行了怎样的数据变化，这样很容易使得操作逻辑变得不可控（尤其是考虑到文档型数据库中可以动态加入键值的特性）。</p><p>受到 MySQL 等关系型数据库中 ORM 概念的启发，对于对象型编程语言与数据库间的交互，一个极好的办法便是实用所谓的对象-文档映射（ODM，Object Document Mapping）模型。 通过将数据库中的对象映射为 Python 中的类，我们便可以直接使用 Python 中的类操作方法对数据库中的对象进行操作。由于每一个数据库文档中的键都与对象中的一个变量有一一对应关系，我们便可以随时掌握当前操作的内容及其可能的行为，这样就使得整个系统更易于维护。</p><p>幸运的是，对于 MongoDB，Python 中已经存在了一款十分完善的 ODM 实现模块 Mongo-Engine。对于本应用，我们直接使用专门针对 Flask 框架封装的 Flask-MongoEngine 来实现对应的 ODM 模型。对于上述提出的集合结构，其 ODM 模型申明代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">db.Document</span>):</span><br>username = db.StringField(required=<span class="hljs-literal">True</span>)<br>password = db.StringField(required=<span class="hljs-literal">True</span>)<br>nickname = db.StringField()<br>permission = db.IntField(default=<span class="hljs-number">1</span>) <span class="hljs-comment"># 1 - Player; 2 - Admin</span><br>  avatar = db.FileField()<br>coin = db.IntField(default=<span class="hljs-number">10</span>)<br>power = db.IntField(default=<span class="hljs-number">1</span>)<br>luck = db.IntField(default=<span class="hljs-number">1</span>)<br>regtime = db.DateTimeField(default=datetime.now()) tool_equipped = db.IntField(default=<span class="hljs-number">0</span>)<br>accessory_equipped = db.IntField(default=<span class="hljs-number">0</span>)<br>container_usage = db.IntField(default=<span class="hljs-number">0</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Treasure</span>(<span class="hljs-params">db.Document</span>):</span><br>name = db.StringField(required=<span class="hljs-literal">True</span>)<br>type = db.IntField(required=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 1 - Tools; 2 - Accessories</span><br>  gain = db.IntField()<br>meta = &#123;<br><span class="hljs-string">&#x27;indexes&#x27;</span>: [ <span class="hljs-string">&#x27;gain&#x27;</span><br>] &#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span>(<span class="hljs-params">db.Document</span>):</span><br>treasure_id = db.ObjectIdField(required=<span class="hljs-literal">True</span>)<br>treasure_name = db.StringField()<br>treasure_type = db.IntField()<br>treasure_gain = db.IntField()<br>owner = db.ObjectIdField(required=<span class="hljs-literal">True</span>)<br>owner_name = db.StringField()<br>status = db.IntField() <span class="hljs-comment"># 1 - Equipped; 2 - In inventory; 3 - On sale</span><br>  price = db.IntField() <span class="hljs-comment"># Only exists when status = 3</span><br>meta = &#123;<br><span class="hljs-string">&#x27;indexes&#x27;</span>: [ <span class="hljs-string">&#x27;owner&#x27;</span>, <span class="hljs-string">&#x27;status&#x27;</span><br>] &#125;<br></code></pre></td></tr></table></figure><p>在该种映射模型下，数据库的 CRUD 操作变得异常简单。下面以用户表的一次 CRUD 操作 代码为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">user_create = User(username=username, password=password) <span class="hljs-comment"># Create</span><br>user_item = User.objects(username=username).first() <span class="hljs-comment"># Retrieve</span><br>user_item.nickname = abc <span class="hljs-comment"># Update</span><br>user_item.delete() <span class="hljs-comment"># Delete</span><br>user_create.save() <span class="hljs-comment"># Save</span><br></code></pre></td></tr></table></figure><h3 id="业务实现">业务实现</h3><h4 id="账户管理">账户管理</h4><p>对于玩家来说，一款游戏的账户管理系统主要涉及用户注册及用户登录两个功能，因此我们分别设计两个接口/register 及/login 来完成这一交互逻辑。</p><p>首先我们来设计注册接口。当用户发起注册请求时，我们首先从请求中拿到用户所要注册的用户名和密码，随后使用 MongoEngine 提供的查询语句查询数据库中用户名是否已经存在。若用户名不存在，则向数据库的 User 文档集合中插入一条新的用户文档，否则则报错。为了方便后续维护，我们约定/register 接口的返回状态码如下：</p><figure><img src="register_status.png" alt="register_status" /><figcaption aria-hidden="true">register_status</figcaption></figure><p>对于登录接口，我们首先从 request 请求体中获得用户名及密码，随后使用 MongoEngine 查询数据库中用户名符合的第一条记录（由于在注册时对数据库中是否存在重名用户进行了检查， 因此这里可以保证获得的第一条记录是整个数据库中唯一符合条件的记录）。得到记录后，我们只需要对其密码进行比对，并将判断结果返回给用户（前端）即可。</p><p>同样的，这里我们约定/login 接口的返回状态码如下：</p><figure><img src="login_status.png" alt="login_status" /><figcaption aria-hidden="true">login_status</figcaption></figure><p>对于账户管理页面的前端设计，我们使用了 Layout+Page 的模式对其进行了样式统一，并使 界面尽可能的保持简洁。其效果如下图所示。</p><figure><img src="login_page.png" alt="login_page" /><figcaption aria-hidden="true">login_page</figcaption></figure><figure><img src="register_page.png" alt="register_page" /><figcaption aria-hidden="true">register_page</figcaption></figure><h4 id="session-与用户组">Session 与用户组</h4><p>由于后续的请求中大量涉及到用户验证，若每次都需要在请求体中加入用户名和密码，则后续操作将会变得十分复杂，且由于用户信息始终在端与端之间传输，会造成极大的安全隐患。因此这里我们使用会话（Session）技术来保持用户的登录状态。同时，为了保证请求安全性，我们还需要对 Session 进行加密。</p><p>Flask原生提供了对Session的支持，我们可以直接使用键值对的方式对一个应用中的Session 进行操作。对于本应用，我们对除登录注册外的所有接口都设置了 Session 验证，当检测到用户发来的请求头中没有 Session 信息的话，则会直接返回 100 状态码告诉用户无权访问。</p><p>在实际场景下，有时我们需要对游戏中的内容进行更新操作（如添加新的可用宝物），为了方便这一操作，我们将其引入前端的交互界面中。然而一旦将修改全局数据库的操作暴露在公开接口中，我们就需要开始考虑操作的权限验证问题，否则就有可能产生安全问题。得益于 Session 用户验证机制，我们可以通过设置用户组来对用户的访问权限进行限制。</p><p>对于当前应用，我们进行如下的权限组约定：</p><figure><img src="permission_table.png" alt="permission_table" /><figcaption aria-hidden="true">permission_table</figcaption></figure><p>可以看到，在前面的数据库结构设计中，我们在用户集合中设置了一个 permission 键用于标识用户所在的组。当用户注册完成后，该键默认被设置为 1，且不可通过接口请求的方式进行更改。为了方便统一管理，我们将所有的管理员操作专门放到一个/admin 蓝图中。该蓝图中的所有接口均进行了用户组认证。当用户发起请求时，系统会首先检查请求头 Session 中包含的用户信息，若用户的权限组高于 2，则继续处理用户所请求的操作，否则直接返回用户码 2 告诉用户无权修改服务器。</p><p>对于不同的用户组，前端界面的呈现也进行了一定的区分。其中当用户为管理员时，菜单中会多出一栏管理员界面可供用户进行操作，这与常规游戏中的设计也基本吻合。</p><figure><img src="normal_player_navigate.png" alt="normal_player_navigate" /><figcaption aria-hidden="true">normal_player_navigate</figcaption></figure><figure><img src="command_player_navigate.png" alt="command_player_navigate" /><figcaption aria-hidden="true">command_player_navigate</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据科学与工程数学基础 作业7</title>
    <link href="/2021/06/30/dase-math/dase-math-assignment-7/"/>
    <url>/2021/06/30/dase-math/dase-math-assignment-7/</url>
    
    <content type="html"><![CDATA[<h2 id="一">一</h2><blockquote><p>下面的集合哪些是凸集？</p><ol type="1"><li>平板， 即形如 <span class="math inline">\(\left\{ x \in \mathbb{R}^n | \alpha \leq a^T x \leq \beta \right\}\)</span> 的集合。</li><li>矩形， 即形如 <span class="math inline">\(\left\{ x \in \mathbb{R}^n | \alpha_i \leq x_i \leq \beta_i, i = 1, \cdots, n \right\}\)</span> 的集合。当 <span class="math inline">\(n &gt; 2\)</span> 使，矩形有时也称为超矩形。</li><li>楔形，即 <span class="math inline">\(\left\{ x \in \mathbb{R}^n | a_1^T x \leq b_1, a_2^T x \leq b_2 \right\}\)</span>。</li><li>距离给定点比距离给定集合近的点构成的集合，即</li></ol><p><span class="math display">\[\left\{ x | || x - x_0 ||_2 \leq || x - y ||_2, \forall y \in S \right\}\]</span></p><p>，其中 <span class="math inline">\(S \subseteq \mathbb{R}^n\)</span></p></blockquote><p><strong>(a)</strong> 该集合可写为 <span class="math inline">\(\{x \in \mathbb{R}^n | a^Tx \leq \beta \} \cap \{x \in \mathbb{R}^n | a^Tx &gt; \alpha \}\)</span>，故为一个凸集</p><p><strong>(b)</strong> 该集合可写为一组半空间的交集，故为一个凸集</p><p><strong>(c)</strong> 该集合可写为 <span class="math inline">\(\{x \in \mathbb{R}^n | a_1^T x \leq b_1\} \cap \{x \in \mathbb{R}^n | a_2^T x \leq b_2\}\)</span>，故为一个凸集</p><p><strong>(d)</strong> 该集合可写为 <span class="math display">\[\bigcap_{y \in S} \{x | ||x - x_0||_2 \leq ||x-y||_2 \}\]</span> 故为一个凸集</p><h2 id="二">二</h2><blockquote><p>下面的函数哪些是凸函数? 请说明理由：</p><ol type="1"><li><span class="math inline">\(f(x)=e^{x}+1, x \in \mathbb{R}\)</span></li><li><span class="math inline">\(f(x)=\max \left(\|A x+b\|_{2},\left\|x^{T} A x\right\|_{1}\right), A \in \mathbb{R}^{m \times n} x \in \mathbb{R}^{n} b \in \mathbb{R}^{m}\)</span></li><li><span class="math inline">\(f(x)=-\cos x, x \in[-\pi / 2, \pi / 2]\)</span></li></ol></blockquote><p><strong>(a)</strong> <span class="math display">\[f&#39;(x) = e^x, f&#39;&#39;(x) = e^x &gt; 0, x \in \mathbb{R}\]</span> 故 <span class="math inline">\(f(x)\)</span> 为凸函数</p><p><strong>(b)</strong> 由于仿射映射、仿射函数取范数、取最大值为保凸运算，故 <span class="math inline">\(f(x)\)</span> 为凸函数</p><p><strong>(c)</strong> <span class="math display">\[f&#39;(x) = \sin x, f&#39;&#39;(x) = \cos x \geq 0, x \in [-\frac{\pi}{2}, \frac{\pi}{2}]\]</span> 故 <span class="math inline">\(f(x)\)</span> 为凸函数</p><h2 id="三">三</h2><blockquote><p>证明 <span class="math inline">\(x^* = (1, 0.5, -1)\)</span> 是如下优化问题的最优解： <span class="math display">\[\begin{aligned}&amp;\min &amp;\frac{1}{2} x^T P x + q^T x + r \\&amp;\textrm{s.t} &amp; -1 \leq x_i \leq 1, i = 1,2,3\end{aligned}\]</span> 其中 <span class="math display">\[P = \begin{pmatrix}13 &amp; 12 &amp; -2 \\12 &amp; 17 &amp; 6 \\-2 &amp; 6 &amp; 12\end{pmatrix},q = \begin{pmatrix}-22 \\-14.5 \\13\end{pmatrix},r = 1\]</span></p></blockquote><p>由于 <span class="math inline">\(\nabla f_0 = \frac{1}{2} (P+P^T) x +q = px+q\)</span></p><p>故 <span class="math inline">\(\nabla f_0(x^*) = (-1,0,2)^T\)</span></p><p>因此 <span class="math inline">\(\forall y \in [-1,1]^n\)</span>，<span class="math inline">\(\nabla f_0(x^*)^T(y-x) \geq 0\)</span></p><p>即 <span class="math inline">\(x^*\)</span> 满足最优性条件，也即目标函数的最优点</p><h2 id="四">四</h2><blockquote><p>计算函数 <span class="math inline">\(f(x)\)</span> 的共轭函数，以及共轭函数的定义域：</p><ol type="1"><li><span class="math inline">\(f(x) = - \log x\)</span></li><li><span class="math inline">\(f(x) = e^x\)</span></li></ol></blockquote><p><strong>(a)</strong> 由 <span class="math inline">\(f(x)=- \log x\)</span> 可知 <span class="math inline">\(domf = \{x|x&gt;0\}\)</span></p><p>令 <span class="math inline">\(g(x,y) = xy + \log x\)</span></p><p>当 <span class="math inline">\(y \geq 0\)</span> 时，<span class="math inline">\(\sup g(x,y) = +\infty\)</span></p><p>当 <span class="math inline">\(y &lt; 0\)</span> 时，<span class="math inline">\(\sup g(x,y) = -1- \log(-y)\)</span> 当且仅当 <span class="math inline">\(x = -\frac{1}{y}\)</span></p><p>故 <span class="math inline">\(f^*(y) = -1-\log(-y),y &lt; 0\)</span></p><p><strong>(b)</strong> <span class="math inline">\(domf = \mathbb{R}\)</span></p><p>令 <span class="math inline">\(g(x,y) = xy- e^x\)</span></p><p>当 <span class="math inline">\(y&gt;0\)</span> 时，<span class="math inline">\(\sup g(x,y) = y \log y - y\)</span> 当且仅当 <span class="math inline">\(x = \log y\)</span></p><p>当 <span class="math inline">\(y = 0\)</span> 时，<span class="math inline">\(\sup g(x,y) = \sup (-e^x) = 0\)</span></p><p>当 <span class="math inline">\(y &lt;0\)</span> 时，<span class="math inline">\(\sup g(x,y) = +\infty\)</span></p><p>故 <span class="math display">\[f^*(y) = \left\{\begin{aligned}y \log y - y, y &gt; 0 \\0, y = 0\end{aligned}\right.\]</span></p><h2 id="五">五</h2><blockquote><p>求解线性规划 <span class="math display">\[\begin{aligned}&amp;\min &amp;e^T x \\&amp;\textrm{s.t} &amp;G x \leq h \\&amp; &amp;Ax = b\end{aligned}\]</span> 的对偶函数，给出对偶问题。</p></blockquote><p>拉格朗日函数 <span class="math display">\[\begin{aligned}L(x, \lambda, \mu) &amp;= e^T x + \lambda^T (Gx-h) + \mu^T(Ax-b) \\&amp;= (e^T + \lambda G+\mu^T A)x - \lambda^T h - \mu^T b\end{aligned}\]</span> 故 <span class="math display">\[g(\lambda, \mu) = \left\{\begin{aligned}-\lambda^T h - \mu^T b &amp;,&amp; e + G^T \lambda + A^T \mu = 0 \\-\infty&amp;,&amp; otherwise\end{aligned}\right.\]</span> 因此其对偶问题为 <span class="math display">\[\max_{\lambda, \mu} \left( -\lambda^Th-\mu^Tb \right) \\s.t. \ \ e + G^T \lambda + A^T \mu = 0, \lambda \geq 0\]</span></p><h2 id="六">六</h2><blockquote><p>证明：Gauss概率密度函数的累积分布函数 <span class="math display">\[\Phi(x) = \frac{1}{\sqrt{2 \pi}} \int_{- \infty}^x e^{-\frac{u^2}{2}} du\]</span> 是对数-凹函数。即 <span class="math inline">\(\log(\Phi(x))\)</span> 是凹函数。</p></blockquote><p>由于 <span class="math display">\[\Phi&#39;(x) = \frac{1}{\sqrt{2 \pi}} e^{-\frac{x^2}{2}} \\\Phi&#39;&#39;(x) = -\frac{x}{\sqrt{2 \pi}} e^{-\frac{x^2}{2}}\]</span> 故 <span class="math display">\[(\Phi&#39;(x))^2 = \frac{1}{2 \pi} e^{-\frac{x^2}{2}} \\\Phi(x) \Phi&#39;&#39;(x) = -\frac{x}{2 \pi} e^{-\frac{x^2}{2}} \int_{-\infty}^x e^{-\frac{u^2}{2}} du\]</span> 当 <span class="math inline">\(x \geq 0\)</span> 时，易见 <span class="math inline">\(\Phi(x) \Phi&#39;&#39;(x) \leq (\Phi&#39;(x))^2\)</span></p><p>当 <span class="math inline">\(x &lt; 0\)</span> 时，由 <span class="math inline">\(\frac{u^2}{2}\)</span> 的凸性可知 <span class="math display">\[\begin{aligned}\Phi(x) \Phi&#39;&#39;(x) &amp;= -\frac{x}{2 \pi} e^{-\frac{x^2}{2}} \int_{-\infty}^x e^{-\frac{u^2}{2}} du \\&amp;\leq -\frac{x}{2 \pi} e^{-\frac{x^2}{2}} \int_{-\infty}^x e^{-\frac{x^2}{2}-(u-x)x} du \\&amp;=\frac{1}{2\pi} e^{-\frac{x^2}{2}} \\&amp;= \left(\Phi&#39;(x)\right)^2\end{aligned}\]</span> 由此可知 <span class="math inline">\(\Phi(x)\)</span> 时对数凸函数</p><h2 id="七">七</h2><blockquote><p>求优化问题 <span class="math inline">\(\arg\min_{x_1, x_2, x_3} x_1x_2x_3\)</span> 当 <span class="math inline">\(x_1,x_2,x_3\)</span> 满足 <span class="math inline">\(x_1^2 + x_2^2 + x_3^2 = 1\)</span> 的解</p></blockquote><p>拉格朗日函数 <span class="math inline">\(L = x_1x_2x_3 + \lambda (x_1^2 + x_2^2+x_3^2 - 1)\)</span></p><p>令 <span class="math inline">\(\nabla L = 0\)</span>，即 <span class="math display">\[\left\{\begin{aligned}&amp;\frac{\partial L}{\partial x_1} = x_2 x_3 + 2\lambda x_1 = 0 \\&amp;\frac{\partial L}{\partial x_2} = x_1 x_3 + 2\lambda x_2 = 0 \\&amp;\frac{\partial L}{\partial x_3} = x_1 x_2 + 2\lambda x_3 = 0 \\&amp;\frac{\partial L}{\partial \lambda} = x_1^2 + x_2^2 + x_3^2 - 1 = 0 \\\end{aligned}\right.\]</span> 解得 <span class="math inline">\(|x_1| = |x_2| = |x_3| = \frac{1}{\sqrt{3}}\)</span></p><p>故 <span class="math inline">\(|x_1x_2x_3| = \frac{\sqrt{3}}{9}\)</span></p><p>代入原方程可知 <span class="math inline">\(x_1x_2x_3 = -\frac{\sqrt{3}}{9}\)</span></p><h2 id="八">八</h2><blockquote><p>已知矩阵 <span class="math inline">\(A \in \mathbb{R}^{p \times q}, B \in \mathbb{R}^{p \times r}, \textrm{rank}(A) = \min (p,q)\)</span>，未知矩阵 <span class="math inline">\(X \in \mathbb{R}^{q \times r}\)</span>，求以下优化问题：</p><p>若 <span class="math inline">\(p &lt; q\)</span>，求Frobenius范数最小的矩阵 <span class="math inline">\(X\)</span>，使得 <span class="math inline">\(AX = B\)</span>，也即优化问题为 <span class="math display">\[\begin{aligned}&amp;\min &amp;f(X) = \frac{1}{2} ||X||_F^2 \\&amp;\textrm{s.t} &amp;AX = B\end{aligned}\]</span></p></blockquote><p>拉格朗日函数 <span class="math inline">\(L = Tr(\frac{1}{2} X^T X) - Tr(\Lambda^T(AX-B))\)</span></p><p>令 <span class="math inline">\(\nabla L = 0\)</span>，即 <span class="math display">\[\left\{\begin{aligned}&amp;\frac{\partial L}{\partial X} = X-A^T \Lambda = 0 \\&amp;\frac{\partial L}{\partial \Lambda} = AX-B = 0\end{aligned}\right.\]</span> 由于 <span class="math inline">\(A\)</span> 行满秩，故 <span class="math inline">\(AA^T\)</span> 可逆</p><p>故 <span class="math inline">\(AX = B = AA^T(AA^T)^{-1}B\)</span></p><p>即 <span class="math inline">\(X = A^T(AA^T)^{-1} B\)</span></p><h2 id="九">九</h2><blockquote><p>给出优化问题 <span class="math inline">\(\min_x (x^3 - ax)\)</span> 使用牛顿法时的迭代格式。</p></blockquote><p><span class="math display">\[f&#39;(x) = 3x^2-a, f&#39;&#39;(x) = 6x\]</span></p><p>故 <span class="math display">\[x_n = x_{n-1} - \frac{f&#39;(x_n)}{f&#39;&#39;(x_n)} = x_{n-1} - \frac{3x_n^2-a}{6x_n}\]</span></p><h2 id="十">十</h2><blockquote><p>梯度下降法是最常用的优化方法之一。考虑优化问题 <span class="math display">\[\min f(x) = x_1^2 + x_2^2 + 2x_3^2\]</span> 证明:在点 <span class="math inline">\(x_0 = (x_1, x_2, x_3)\)</span> 处沿负梯度方向迭代的最佳步⻓为 <span class="math display">\[\lambda = \frac{x_1^2 + x_2^2 + 4x_3^2}{2x_1^2 + 2x_2^2 + 16 x_3^2}\]</span></p></blockquote><p>令 <span class="math inline">\(x&#39; = x - \lambda \nabla f(x)\)</span></p><p>故 <span class="math display">\[\begin{aligned}g(\lambda) &amp;= f(x&#39;) \\&amp;= f(x - \lambda \nabla f(x)) \\&amp;= (1-2\lambda)^2 x_1^2 + (1-2\lambda)^2 x_2^2 + 2 (1-4\lambda)^2 x_3^2\end{aligned}\]</span> 于是 <span class="math display">\[g&#39;(\lambda) = -4(1-2\lambda)^2 x_1^2 - 4 (1-2\lambda)^2x_2^2 - 16(1-4\lambda)x_3^2\]</span> 令 <span class="math inline">\(g&#39;(\lambda) = 0\)</span></p><p>解得 <span class="math display">\[\lambda = \frac{x_1^2+x_2^2+4x_3^2}{2x_1^2+2x_2^2+16x_3^2}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数据科学数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>DataScience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据科学与工程数学基础 作业6</title>
    <link href="/2021/06/30/dase-math/dase-math-assignment-6/"/>
    <url>/2021/06/30/dase-math/dase-math-assignment-6/</url>
    
    <content type="html"><![CDATA[<h2 id="一">一</h2><blockquote><p>证明：若 <span class="math inline">\(H(Y|X) = 0\)</span> 则 <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(X\)</span> 的函数（即对于满足 <span class="math inline">\(p(x) &gt; 0\)</span> 的任意 <span class="math inline">\(x\)</span>，仅存在一个可能的取值 <span class="math inline">\(y\)</span>，使得 <span class="math inline">\(p(x,y) &gt; 0\)</span>）</p></blockquote><p>由 <span class="math inline">\(H(Y|X) = 0\)</span> 可知，对任意 <span class="math inline">\(x_i\)</span>，存在唯一的 <span class="math inline">\(y_j\)</span> 使得 <span class="math inline">\(P(Y=y_j|X=x_i) = 1\)</span></p><p>故 <span class="math display">\[\begin{aligned}p(x_i, y_j) &amp;= p(y_j|x_i) \cdot p(x_i) \\&amp;=p(x_i), X=x_i \land Y=y_j\end{aligned}\]</span> 也即 <span class="math inline">\(Y\)</span> 是 <span class="math inline">\(X\)</span> 的函数</p><h2 id="二">二</h2><blockquote><p>一个容器里面装有 <span class="math inline">\(a\)</span> 个红球和 <span class="math inline">\(b\)</span> 个白球，若从容器中取出 <span class="math inline">\(k(k \geq 2)\)</span> 个球。对于有放回和无放回两种情况，哪种情况的熵更大?请回答并给予说明。</p></blockquote><p>有放回时，第 <span class="math inline">\(i\)</span> 次摸出红球和白球的概率是相同的</p><p>无放回时， 第 <span class="math inline">\(i\)</span> 次摸出红球和白球的概率与前 <span class="math inline">\(i-1\)</span> 次的结果有关</p><p>于是由熵的极值性可知，有放回的熵更大。</p><h2 id="三">三</h2><blockquote><p>投掷一枚均匀的硬币。硬币出现正面和反面的互信息是多少？</p></blockquote><p><span class="math display">\[I(H,T) = \log \frac{P(H|T)}{P(H)} = -\infty\]</span></p><h2 id="四">四</h2><blockquote><p>投掷一颗 <span class="math inline">\(6\)</span> 面均匀的骰子，出现顶面和前面的互信息是多少？</p></blockquote><p><span class="math display">\[I(Top, Front) = \log \frac{P(Top|Front)}{P(Top)} = -\infty\]</span></p><h2 id="五">五</h2><blockquote><p>求均匀分布 <span class="math inline">\(X \sim U(a,b)\)</span> 的微分熵</p></blockquote><p><span class="math display">\[\begin{aligned}h(X) &amp;= -\int_a^b \frac{1}{b-a} \log \frac{1}{b-a} dx \\&amp;=\log(b-a)\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数据科学数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>DataScience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派在线教学系统</title>
    <link href="/2021/06/29/web/remote-teaching/"/>
    <url>/2021/06/29/web/remote-teaching/</url>
    
    <content type="html"><![CDATA[<h2 id="树莓派部署">树莓派部署</h2><p>​ <strong>树莓派（Raspberry Pi）</strong>是由英国慈善组织“Raspberry Pi基金会”开发的一款ARM微型单片机，其具备了一台标准计算机的绝大部分功能，常被用于提供各类小型服务类应用及嵌入式产品驱动。本项目基于Raspberry Pi 4B型号进行开发。</p><p>​ 树莓派官方提供了一个基于Linux内核的专为树莓派硬件设计的<strong>Raspberry Pi OS</strong>操作系统，可以直接在其官网进行镜像的下载。这里我们使用当前最新版<strong>（Kernel Version: 5.10）</strong>进行开发。</p><a id="more"></a><p><img src="raspberry_os.png" alt="raspberry_os" style="zoom:50%;" /></p><p>​ 将系统烧录至SD卡并引导进入系统后，我们首先打开系统的SSH及VNC服务，使得其可以通过远程访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">&gt; sudo raspi-config<br></code></pre></td></tr></table></figure><p>在弹出的GUI界面中选择<strong>Interfacing Options</strong>，依次打开SSH及VNC配置项即可。</p><p>​ 接下来我们来为树莓派创建一个热点，使得其他设备可以连接到树莓派的WIFI网络中以通过局域网访问后续的教学网站页面。首先我们安装在系统中安装<strong>hostapd</strong>（一个类Unix系统下可以提供热点访问的服务端工具）和<strong>dnsmasq</strong>（一个用于配置DNS和DHCP的工具）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; sudo apt-get install hostapd<br>&gt; sudo apt install dnsmasq<br></code></pre></td></tr></table></figure><p>在<strong>/etc/hostapd/</strong>目录下创建一个<strong>hostapd.conf</strong>配置文件，并在其中指定要创建热点的相关信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">interface</span>=wlan0<br><span class="hljs-attr">driver</span>=nl80211<br><span class="hljs-attr">ssid</span>=graspberry<br><span class="hljs-attr">hw_mode</span>=g<br><span class="hljs-attr">channel</span>=<span class="hljs-number">7</span><br><span class="hljs-attr">wmm_enabled</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">macaddr_acl</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">auth_algs</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">ignore_broadcast_ssid</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">wpa</span>=<span class="hljs-number">2</span><br><span class="hljs-attr">wpa_passphrase</span>=<span class="hljs-number">1029384756</span><br><span class="hljs-attr">wpa_key_mgmt</span>=WPA-PSK<br><span class="hljs-attr">wpa_pairwise</span>=TKIP<br><span class="hljs-attr">rsn_pairwise</span>=CCMP<br></code></pre></td></tr></table></figure><p>随后我们将这一配置文件添加到<strong>/etc/default/hostapd</strong>中：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DAEMON_CONF</span>=<span class="hljs-string">&quot;/etc/hostapd/hostapd.conf&quot;</span><br></code></pre></td></tr></table></figure><p>重启系统后，我们打开hostapd服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; sudo systemctl unmask hostapd<br>&gt; sudo systemctl <span class="hljs-built_in">enable</span> hostapd<br>&gt; sudo systemctl start hostapd<br></code></pre></td></tr></table></figure><p>现在，我们便可以在其他设备上搜索到树莓派的热点信号了：</p><p><img src="raspberry_hotspot.png" alt="raspberry_hotspot" style="zoom:50%;" /></p><p>连接热点后，我们只需要使用SSH工具，便可以远程访问树莓派：</p><p><img src="raspberry_ssh.png" alt="raspberry_ssh" style="zoom:50%;" /></p><p>​ 由于Raspberry Pi OS是Linux系统的一种，我们可以使用与开发环境类似的方式部署网站。首先我们从官网下载并安装Node运行环境包（https://nodejs.org/zh-cn/download/），并配置相应的环境变量：<strong>（.bash_profile）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NODE_HOME=/home/pi/ node-v14.17.2-linux-armv7l<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$NODE_HOME</span>/bin <br><span class="hljs-built_in">export</span> NODE_PATH=<span class="hljs-variable">$NODE_HOME</span>/lib/node_modules<br></code></pre></td></tr></table></figure><p>随后我们使用apt-get安装<strong>MariaDB-Server</strong>作为服务端数据库环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; sudo apt-get install mariadb-server-10.0<br></code></pre></td></tr></table></figure><p>以安全模式进入数据库并修改数据库默认密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; sudo service mysql stop<br>&gt; sudo mysqld_safe --skip-grant-tables &amp;<br>&gt; mysql -u root<br>MariaDB&gt; update mysql.user <span class="hljs-built_in">set</span> authentication_string=PASSWORD(<span class="hljs-string">&#x27;1029384756&#x27;</span>), plugin=<span class="hljs-string">&#x27;mysql_native_password&#x27;</span> <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span>;<br>&gt; sudo service mysql stop<br>&gt; sudo service mysql start<br></code></pre></td></tr></table></figure><p>现在我们的树莓派系统已经可以支持网页应用的部署了。</p><h2 id="系统构架">系统构架</h2><p>​ 整个树莓派在线教学系统分为<strong>用户端（前端）</strong>及<strong>服务端（后端）</strong>，其中用户端又分为<strong>学生端</strong>和<strong>教师端</strong>，其基本系统构架如下图所示：</p><figure><img src="structure.png" alt="structure" /><figcaption aria-hidden="true">structure</figcaption></figure><p>​ 可以看到，整个系统的构架是十分清晰的。用户首先通过用户管理系统登录在线教学系统，系统会根据教师或学生身份分别跳转到教师端的课程路由界面或学生端课程路由界面。随后，系统通过请求后端的课程数据库来返回用户当前参与或教授的所有课程，用户可根据界面提示进入到相应的课程界面中。对于一个课程界面，系统提供了签到、实时聊天、文件下载、在线答题及视频推流5个基本模块，每个模块经过后端路由再传递给服务器文件系统或另一学生/教师客户端。对于学生签到机制，后端会通过深度学习模型对前端传入的照片进行人脸识别，并将相应的签到结果传给教师客户端；而对于在线答题机制，则由教师端先上传一定格式的题目描述及答题限制，再由后端的试题结构解析器进行解析分发给学生客户端，当学生完成答题后，再通过路由送到后端进行结果统计，并将统计结果发送回教师端展示。</p><p>​ 以用户视角来看，教学系统的主体界面效果如下：</p><p><img src="lesson.png" alt="lesson" style="zoom:50%;" /></p><h2 id="quasar-framework与前端整合">Quasar Framework与前端整合</h2><p>​ 由于该网站的前端元素较为繁杂，我们需要一个合适易用的前端框架来避免大量不必要的重复编码。Quasar Framework是一款基于Vue.js的前端UI框架，其开箱即用和跨平台的属性使得我们可以快速的对各类UI元素进行整合。要构架Quasar Framework开发环境是容易的，Quasar官方提供了一个基于Vuex的脚手架，我们以此为起点来进行网站前端的构建。</p><p>​ 首先我们使用npm工具全局安装Quasar-CLI最新版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; npm install -g @quasar/cli<br></code></pre></td></tr></table></figure><p>系统会自动安装相关的必要的组建，包括Vue-CLI脚手架（如果没有自动安装的话，可以手动安装Vue-CLI最新版本）。</p><p>随后，我们在目标位置使用Quasar-CLI生成一个前端开发环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; quasar create frontend<br></code></pre></td></tr></table></figure><p>系统会自动解析并生成所需的相应配置文件，并会在其中询问我们若干次相关参数的设置值，这里我们直接使用默认选项即可。</p><p><img src="quasar_create.png" alt="quasar_create" style="zoom:50%;" /></p><p>生成完成后，我们进入目录安装相应的Node依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; npm install<br></code></pre></td></tr></table></figure><p>现在，我们的前端开发环境就配置完成了。我们可以使用如下命令即时查看开发效果，也可以对整个应用进行打包送至后端进行整合：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; quasar dev <span class="hljs-comment"># 开发环境测试</span><br>&gt; quasar build <span class="hljs-comment"># 打包至生产环境</span><br></code></pre></td></tr></table></figure><p><img src="quasar_build.png" alt="quasar_build" style="zoom:50%;" /></p><p>​ Vue将<strong>布局（Layout）</strong>和<strong>页面（Page）</strong>进行了分离，使得在同种布局下网站中的内容可以进行缺省替换，这正是本项目所需要的。对于本项目，我们设计了两种不同的界面布局，分别用于用户管理和授课窗口。网站的前端路由结构如下图所示：</p><p><img src="frontend_structure.png" alt="frontend_structure" style="zoom:80%;" /></p><h2 id="express与后端路由">Express与后端路由</h2><p>​ 为了与前端达到最佳的适配，我们使用<strong>NodeJS+Express框架</strong>作为服务端的实现基础。与Quasar类似，Express同样提供了一个官方脚手架用于搭建后端的开发环境。我们只需使用npm工具全局安装即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; npm install -g express<br>&gt; npm install -g express-generator<br></code></pre></td></tr></table></figure><p>安装完成后，我们在目标位置生成一个新的后端项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; express backend<br></code></pre></td></tr></table></figure><p>Express脚手架会在目标位置自动生成相关的依赖文件：</p><p><img src="express_create.png" alt="express_create" style="zoom:50%;" /></p><p>生成完后端环境后，我们进入目录，使用npm安装相应的依赖包，即可使用如下命令进行后端的测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; node bin/www<br></code></pre></td></tr></table></figure><p>​ 本项目后端路由的整体结构如图所示：</p><p><img src="backend_structure.png" alt="backend_structure" style="zoom:80%;" /></p><p>可以发现，除了根目录为网页推送接口，其他接口均为前端请求响应接口，故这些接口可以向用户隐去。此外，本项目还需要额外创建一个WebSocket服务器来响应实时的前后端数据交互请求。</p><h2 id="用户管理">用户管理</h2><p>​ 我们在数据库中创建一张表<strong>user</strong>来管理用户的基本信息。对于一个用户而言，我们需要记录其<strong>用户名（username）</strong>、<strong>密码（password）</strong>、<strong>邮箱（email）</strong>和<strong>身份（identity）</strong>。此外，我们还需要记录其<strong>参加/开设的课程编号（lessons）</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE user(<br>    &#96;id&#96; INT NOT NULL AUTO_INCREMENT,<br>    &#96;username&#96; TEXT NOT NULL,<br>    &#96;password&#96; TEXT NOT NULL,<br>    &#96;email&#96; TEXT,<br>    &#96;identity&#96; INT NOT NULL,<br>    &#96;lessons&#96; TEXT,<br>    PRIMARY KEY (&#96;id&#96;)<br>);<br></code></pre></td></tr></table></figure><p>​ 用户的基本管理逻辑分为注册和登录。我们将两个逻辑分别封装在两个独立的函数中，并采用<strong>回调函数</strong>的方式让路由调用。对于用户登录，我们只需要查询表中是否存在对应username键和password键的行即可。由于Node.JS中的Mysql插件为<strong>异步</strong>访问的，这里我们需要使用<strong>Promise</strong>函数来确保其执行顺序。为了向回调函数提供统一的接口，我们使用<strong>status</strong>状态字来指示查询的结果和状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> login = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username, password, callback</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> sql_str = <span class="hljs-string">&quot;SELECT username,password FROM user WHERE username=?&quot;</span>;<br>    <span class="hljs-keyword">var</span> sql_param = [username];<br>    <span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>        mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>                reject(err);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                resolve(result);<br>            &#125;<br>        &#125;);<br>    &#125;);<br>    promise.then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">var</span> status = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 - 未确定; 1 - 成功; 2 - 用户名不存在; 3 - 密码错误 */</span><br>        <span class="hljs-keyword">if</span>(result == <span class="hljs-literal">undefined</span> || result.length == <span class="hljs-number">0</span>)&#123;<br>            status = <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result[<span class="hljs-number">0</span>].password == password)&#123;<br>            status = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            status = <span class="hljs-number">3</span>;<br>        &#125;<br>        callback(status);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 注册的逻辑同登录类似，只需将Mysql查询语句改为插入语句即可。这里需要注意的是，为了确保用户名的唯一性，我们在插入数据之前需首先查询表中是否已经存在对应的username键值，如果存在相同用户名，我们需要返回用户一个“用户名已存在”的错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> register = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username, password, email, identity, callback</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> sql_str = <span class="hljs-string">&quot;SELECT username FROM user WHERE username=?&quot;</span>;<br>    <span class="hljs-keyword">var</span> sql_param = [username];<br>    <span class="hljs-keyword">var</span> promise_query = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>        mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>                reject(err);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                resolve(result);<br>            &#125;<br>        &#125;);<br>    &#125;);<br>    promise_query.then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">var</span> status = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 - 未确定; 1 - 成功; 2 - 用户名已存在 */</span><br>        <span class="hljs-keyword">if</span>(result.length &gt; <span class="hljs-number">0</span>)&#123;<br>            status = <span class="hljs-number">2</span>;<br>            callback(status);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            sql_str = <span class="hljs-string">&quot;INSERT INTO user(username, password, email, identity) VALUES (?,?,?,?)&quot;</span>;<br>            sql_param = [username, password, email, identity];<br>            <span class="hljs-keyword">var</span> promise_insert = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>                mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>                    <span class="hljs-keyword">if</span>(err)&#123;<br>                        reject(err);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        resolve(result);<br>                    &#125;<br>                &#125;);<br>            &#125;);<br>            promise_insert.then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>                status = <span class="hljs-number">1</span>;<br>                callback(status);<br>            &#125;)<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="课程管理">课程管理</h2><p>​ 为了提高整个系统的可扩展性，我们希望能够并行的同时进行多个课程的在线教学。要做到这一点，我们需要将每个课程的工作环境隔离开来。幸运的是，在Mysql数据库中，我们可以创建一个唯一的ID使得其在每次插入数据的时候进行自增，因此我们可以直接使用这一ID作为课程的唯一标识。</p><p>​ 我们首先创建一张<strong>lesson</strong>表用于维护整个系统中的全局课程信息，这张表中应当维护<strong>课程名（name）</strong>、<strong>授课教师ID（teacher）</strong>及<strong>学生列表（students）</strong>三个关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE lesson(<br>    &#96;id&#96; INT NOT NULL AUTO_INCREMENT,<br>    &#96;name&#96; TEXT NOT NULL,<br>    &#96;teacher&#96; TEXT,<br>    &#96;students&#96; TEXT,<br>    PRIMARY KEY (&#96;id&#96;)<br>);<br></code></pre></td></tr></table></figure><p>​ 随后，我们需要封装一系列函数来对这一表格内容进行维护。当教师新创建一门课程时，前端会向教师询问课程名，并请求后端的<strong>/lesson_create</strong>口进行课程创建：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">q-page</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex flex-top-left&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%; margin-top: 2%&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">q-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;secondary&quot;</span> <span class="hljs-attr">hidden</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">padding</span>=<span class="hljs-string">&quot;sm xl&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;create_btn&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-left: 3%&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;创建课程&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;createLesson = true&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">q-dialog</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;createLesson&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">q-card</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">q-card-section</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">q-input</span> <span class="hljs-attr">outlined</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lesson_name&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;q-pa-sm&quot;</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;[val =&gt; !!val || &#x27;课程名称不能为空！&#x27;]&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;课程名称&quot;</span> /&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">q-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;secondary&quot;</span> <span class="hljs-attr">padding</span>=<span class="hljs-string">&quot;sm xl&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;创建课程&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onCreateLesson&quot;</span> <span class="hljs-attr">v-close-popup</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">q-card-section</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">q-card</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">q-dialog</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">q-page</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">        name: <span class="hljs-string">&#x27;lessonList&#x27;</span>,</span><br>        data()&#123;<br><span class="javascript">            <span class="hljs-keyword">return</span>&#123;</span><br><span class="javascript">                username: <span class="hljs-string">&quot;&quot;</span>,</span><br><span class="javascript">                createLesson: <span class="hljs-literal">false</span>,</span><br><span class="javascript">                lesson_name: <span class="hljs-string">&quot;&quot;</span>,</span><br>            &#125;<br>        &#125;,<br>        methods: &#123;<br>            onCreateLesson()&#123;<br><span class="javascript">                <span class="hljs-keyword">var</span> full_url = <span class="hljs-string">&#x27;lesson_create?name=&#x27;</span> + <span class="hljs-built_in">this</span>.lesson_name + <span class="hljs-string">&#x27;&amp;teacher=&#x27;</span> + <span class="hljs-built_in">this</span>.username;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.axios.get(full_url).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;</span><br><span class="javascript">                    <span class="hljs-keyword">var</span> status = response.data.status;</span><br>                    if(status == 1)&#123;<br><span class="javascript">                        alert(<span class="hljs-string">&quot;创建成功！&quot;</span>);</span><br>                    &#125;<br><span class="javascript">                    <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">                        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Error occurred!&quot;</span>);</span><br>                    &#125;<br><span class="javascript">                &#125;).catch(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;</span><br><span class="javascript">                    <span class="hljs-built_in">console</span>.log(response);</span><br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建课程的基本逻辑为<strong>无重名确认-&gt;创建课程-&gt;查询课程ID-&gt;将课程信息添加到教师授课列表中</strong>，我们可以快速写出相应的实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> createLesson = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, teacher, callback</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> sql_str = <span class="hljs-string">&quot;SELECT name FROM lesson WHERE name=? AND teacher=?&quot;</span>;<br>    <span class="hljs-keyword">var</span> sql_param = [name, teacher];<br>    <span class="hljs-keyword">var</span> promise_check = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_check, reject_check</span>)</span>&#123;<br>        mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>                reject_check(err);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                resolve_check(result);<br>            &#125;<br>        &#125;);<br>    &#125;);<br>    promise_check.then(<span class="hljs-function">(<span class="hljs-params">result_check</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">var</span> status = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 1 - 成功; 2 - 课程重名; 3 - 内部错误 */</span><br>        <span class="hljs-keyword">if</span>(result_check.length &gt; <span class="hljs-number">0</span>)&#123;<br>            status = <span class="hljs-number">2</span>;<br>            callback(status);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            sql_str = <span class="hljs-string">&quot;INSERT INTO lesson(name, teacher) VALUES (?,?)&quot;</span>;<br>            sql_param = [name, teacher];<br>            <span class="hljs-keyword">var</span> promise_create = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_create, reject_create</span>)</span>&#123;<br>                mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>                    <span class="hljs-keyword">if</span>(err)&#123;<br>                        reject_create(err);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        resolve_create(result);<br>                    &#125;<br>                &#125;);<br>            &#125;);<br>            promise_create.then(<span class="hljs-function">(<span class="hljs-params">result_create</span>) =&gt;</span> &#123;<br>                sql_str = <span class="hljs-string">&quot;SELECT id FROM lesson WHERE name=? AND teacher=?&quot;</span>;<br>                sql_param = [name, teacher];<br>                <span class="hljs-keyword">var</span> promise_getid = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_getid, reject_getid</span>)</span>&#123;<br>                    mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>                        <span class="hljs-keyword">if</span>(err)&#123;<br>                            reject_getid(err);<br>                        &#125;<br>                        <span class="hljs-keyword">else</span>&#123;<br>                            resolve_getid(result);<br>                        &#125;<br>                    &#125;);<br>                &#125;);<br>                promise_getid.then(<span class="hljs-function">(<span class="hljs-params">result_getid</span>) =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span>(result_getid == <span class="hljs-literal">undefined</span> || result_getid.length == <span class="hljs-number">0</span>)&#123;<br>                        status = <span class="hljs-number">3</span>;<br>                        callback(status);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        appendLesson(teacher, result_getid[<span class="hljs-number">0</span>].id, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">status_append</span>)</span>&#123;<br>                            <span class="hljs-keyword">if</span>(status_append != <span class="hljs-number">1</span>)&#123;<br>                                status = <span class="hljs-number">3</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">else</span>&#123;<br>                                status = <span class="hljs-number">1</span>;<br>                                callback(status);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;);<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">var</span> appendLesson = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username, lesson_id, callback</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> sql_str = <span class="hljs-string">&quot;SELECT lessons FROM user WHERE username=?&quot;</span>;<br>    <span class="hljs-keyword">var</span> sql_param = [username];<br>    <span class="hljs-keyword">var</span> status = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 1 - 成功; 2 - 用户名不存在 */</span><br>    <span class="hljs-keyword">var</span> promise_showlist = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_showlist, reject_showlist</span>)</span>&#123;<br>        mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>                reject_showlist(err);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                resolve_showlist(result);<br>            &#125;<br>        &#125;);<br>    &#125;);<br>    promise_showlist.then(<span class="hljs-function">(<span class="hljs-params">result_showlist</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(result_showlist == <span class="hljs-literal">undefined</span> || result_showlist.length == <span class="hljs-number">0</span>)&#123;<br>            status = <span class="hljs-number">2</span>;<br>            callback(status);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">var</span> lesson_str = result_showlist[<span class="hljs-number">0</span>].lessons;<br>            <span class="hljs-keyword">if</span>(lesson_str == <span class="hljs-literal">undefined</span> || lesson_str == <span class="hljs-literal">null</span>)&#123;<br>                lesson_str = <span class="hljs-built_in">String</span>(lesson_id);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                lesson_str = lesson_str + <span class="hljs-string">&quot;,&quot;</span> + lesson_id;<br>            &#125;<br>            sql_str = <span class="hljs-string">&quot;UPDATE user SET lessons=? WHERE username=?&quot;</span>;<br>            sql_param = [lesson_str, username];<br>            <span class="hljs-keyword">var</span> promise_update = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_update, reject_update</span>)</span>&#123;<br>                mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>                    <span class="hljs-keyword">if</span>(err)&#123;<br>                        reject_update(err);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        resolve_update(result);<br>                    &#125;<br>                &#125;);<br>            &#125;);<br>            promise_update.then(<span class="hljs-function">(<span class="hljs-params">resule_update</span>) =&gt;</span> &#123;<br>                status = <span class="hljs-number">1</span>;<br>                callback(status);<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，由于MySQL中没有“数组”这一基本数据类型，因此我们使用字符串拼接的方式将课程ID以字符串的形式存储到用户的lessons字段中，当需要查询用户的课程列表时，再通过字符串拆分的方式将其还原为ID列表。</p><p>参与已有的课程与查询用户参与的课程列表的逻辑也基本类似，基本都是对通过课程ID作为唯一的键桥梁分别在user和lesson中进行查询操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> getLessons = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username, callback</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> sql_str = <span class="hljs-string">&quot;SELECT lessons FROM user WHERE username=?&quot;</span>;<br>    <span class="hljs-keyword">var</span> sql_param = [username];<br>    <span class="hljs-keyword">var</span> promise_showlist = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_showlist, reject_showlist</span>)</span>&#123;<br>        mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>                reject_showlist(err);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                resolve_showlist(result);<br>            &#125;<br>        &#125;);<br>    &#125;);<br>    promise_showlist.then(<span class="hljs-function">(<span class="hljs-params">result_showlist</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">var</span> errno = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 - 无错误; 1 - 用户名不存在; 2 - 课程不存在 */</span><br>        <span class="hljs-keyword">if</span>(result_showlist == <span class="hljs-literal">undefined</span> || result_showlist.length == <span class="hljs-number">0</span>)&#123;<br>            errno = <span class="hljs-number">1</span>;<br>            callback(errno, <span class="hljs-literal">undefined</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">var</span> lesson_str = result_showlist[<span class="hljs-number">0</span>].lessons;<br>            <span class="hljs-keyword">if</span>(lesson_str == <span class="hljs-literal">null</span>)&#123;<br>                callback(errno, []);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">var</span> lesson_list = lesson_str.split(<span class="hljs-string">&quot;,&quot;</span>);<br>                <span class="hljs-keyword">var</span> fetch_total = lesson_list.length;<br>                <span class="hljs-keyword">var</span> fetched_num = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">var</span> promise_loop = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_loop, reject_loop</span>)</span>&#123;<br>                    <span class="hljs-keyword">var</span> detail_list = [];<br>                    lesson_list.forEach(<span class="hljs-function">(<span class="hljs-params">lesson</span>) =&gt;</span> &#123;<br>                        sql_str = <span class="hljs-string">&quot;SELECT name,teacher FROM lesson where id=?&quot;</span>;<br>                        sql_param = [lesson];<br>                        <span class="hljs-keyword">var</span> promise_detail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_detail, reject_detail</span>)</span>&#123;<br>                            mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>                                <span class="hljs-keyword">if</span>(err)&#123;<br>                                    reject_detail(err);<br>                                &#125;<br>                                <span class="hljs-keyword">else</span>&#123;<br>                                    resolve_detail(result);<br>                                &#125;<br>                            &#125;);<br>                        &#125;);<br>                        promise_detail.then(<span class="hljs-function">(<span class="hljs-params">result_detail</span>) =&gt;</span> &#123;<br>                            <span class="hljs-keyword">if</span>(result_detail == <span class="hljs-literal">undefined</span> || result_detail.length == <span class="hljs-number">0</span>)&#123;<br>                                errno = <span class="hljs-number">2</span>;<br>                                reject_loop(<span class="hljs-string">&quot;Lesson doesn&#x27;t exist!&quot;</span>);<br>                            &#125;<br>                            <span class="hljs-keyword">else</span>&#123;<br>                                detail_list.push(&#123;<span class="hljs-attr">id</span>: lesson, <span class="hljs-attr">name</span>: result_detail[<span class="hljs-number">0</span>].name, <span class="hljs-attr">teacher</span>: result_detail[<span class="hljs-number">0</span>].teacher&#125;);<br>                                fetched_num += <span class="hljs-number">1</span>;<br>                                <span class="hljs-keyword">if</span>(fetched_num == fetch_total)&#123;<br>                                    resolve_loop(detail_list);<br>                                &#125;<br>                            &#125;<br>                        &#125;);<br>                    &#125;);<br>                &#125;);<br>                promise_loop.then(<span class="hljs-function">(<span class="hljs-params">result_loop</span>) =&gt;</span> &#123;<br>                    callback(errno, result_loop);<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-keyword">var</span> appendLesson = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">username, lesson_id, callback</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> sql_str = <span class="hljs-string">&quot;SELECT lessons FROM user WHERE username=?&quot;</span>;<br>    <span class="hljs-keyword">var</span> sql_param = [username];<br>    <span class="hljs-keyword">var</span> status = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 1 - 成功; 2 - 用户名不存在 */</span><br>    <span class="hljs-keyword">var</span> promise_showlist = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_showlist, reject_showlist</span>)</span>&#123;<br>        mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>                reject_showlist(err);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                resolve_showlist(result);<br>            &#125;<br>        &#125;);<br>    &#125;);<br>    promise_showlist.then(<span class="hljs-function">(<span class="hljs-params">result_showlist</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(result_showlist == <span class="hljs-literal">undefined</span> || result_showlist.length == <span class="hljs-number">0</span>)&#123;<br>            status = <span class="hljs-number">2</span>;<br>            callback(status);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">var</span> lesson_str = result_showlist[<span class="hljs-number">0</span>].lessons;<br>            <span class="hljs-keyword">if</span>(lesson_str == <span class="hljs-literal">undefined</span> || lesson_str == <span class="hljs-literal">null</span>)&#123;<br>                lesson_str = <span class="hljs-built_in">String</span>(lesson_id);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                lesson_str = lesson_str + <span class="hljs-string">&quot;,&quot;</span> + lesson_id;<br>            &#125;<br>            sql_str = <span class="hljs-string">&quot;UPDATE user SET lessons=? WHERE username=?&quot;</span>;<br>            sql_param = [lesson_str, username];<br>            <span class="hljs-keyword">var</span> promise_update = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve_update, reject_update</span>)</span>&#123;<br>                mysql.query(sql_str, sql_param, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>)</span>&#123;<br>                    <span class="hljs-keyword">if</span>(err)&#123;<br>                        reject_update(err);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        resolve_update(result);<br>                    &#125;<br>                &#125;);<br>            &#125;);<br>            promise_update.then(<span class="hljs-function">(<span class="hljs-params">resule_update</span>) =&gt;</span> &#123;<br>                status = <span class="hljs-number">1</span>;<br>                callback(status);<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以在界面中自由创建/加入并随时查看当前参与的课程了：</p><p><img src="lesson_list_page.png" alt="lesson_list_page" style="zoom:50%;" /></p><h2 id="文件管理">文件管理</h2><p>​ 接下来我们来实现文件共享的功能。Quasar Framework提供了一个用于文件上传的UI组件，我们可以直接通过调用它来提示用户选择文件并发送至后端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">q-page</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex flex-center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">q-uploader</span></span><br><span class="hljs-tag">            <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;file_upload&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">:headers</span>=<span class="hljs-string">&quot;[&#123;name: &#x27;lesson_id&#x27;, value: this.lesson_id &#125;]&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">field-name</span>=<span class="hljs-string">&quot;file&quot;</span></span><br><span class="hljs-tag">        /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">q-page</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里为了方便后续的资源隔离，我们在其发送的请求头中加入了课程ID号。</p><p>​ Quasar文件上传器使用了HTTP协议进行文件上传，因此我们需要在后端实现符合这一协议的文件接受通道。这里我们使用了一个名为<strong>multer</strong>的NodeJS插件，它可以以极高的效率处理前端发来的文件数据。我们先在服务端文件系统上新建一个file_upload目录，用于专门管理课堂中的共享资源。随后，我们在后端路由中附上这一组件，并将接收到的文件统一保存至file_upload目录：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> multer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;multer&#x27;</span>);<br><span class="hljs-keyword">var</span> file_upload = multer(&#123;<span class="hljs-attr">dest</span>: <span class="hljs-string">&#x27;file_upload/&#x27;</span>&#125;);<br><br>router.post(<span class="hljs-string">&#x27;/file_upload&#x27;</span>, file_upload.single(<span class="hljs-string">&#x27;file&#x27;</span>), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, response</span>)</span>&#123;<br>  file.file_redirect(request.file.destination, request.file.path, request.headers.lesson_id, request.file.originalname, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    response.writeHead(<span class="hljs-number">200</span>, &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>    &#125;);<br>    response.write(<span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-string">&#x27;status&#x27;</span>: <span class="hljs-number">1</span>&#125;));<br>    response.end();<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>由于需要支持多个课堂同时进行，我们需要将每个课程的资源隔离。为此，我们在创建课程时，为每个课程创建一个相应的子目录，以课程ID作为目录名。随后，我们封装一个文件重定位函数，当multer将前端发来的文件保存到目标位置后，随即将其移动至相应的子文件夹下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> file_redirect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">origin_path, origin_fullname, lesson_id, target_name, callback</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(origin_path, origin_fullname, lesson_id, target_name);<br>    fs.exists(origin_path + lesson_id + <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exists</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!exists)&#123;<br>          fs.mkdir(origin_path + lesson_id + <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>              <span class="hljs-built_in">console</span>.log(err);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>              fs.rename(origin_fullname, origin_path + lesson_id + <span class="hljs-string">&quot;/&quot;</span> + target_name, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;<br>                <span class="hljs-keyword">if</span>(err)&#123;<br>                  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Rename error!&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    callback();<br>                &#125;<br>              &#125;);<br>            &#125;<br>          &#125;);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            fs.rename(origin_fullname, origin_path + lesson_id + <span class="hljs-string">&quot;/&quot;</span> + target_name, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;<br>              <span class="hljs-keyword">if</span>(err)&#123;<br>                  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Rename error!&quot;</span>);<br>              &#125;<br>              <span class="hljs-keyword">else</span>&#123;<br>                  callback();<br>              &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 现在，我们可以正常将文件上传至服务端并共享给其他用户了：</p><p><img src="file_upload.png" alt="file_upload" style="zoom:50%;" /></p><p>​ 对于学生端而言，每当学生用户进入课程时，我们只需要列出对应文件夹下的文件名，并将其发回给前端，就可以让用户随时看到课堂中的所有共享文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> list_files = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">base_path, lesson_id, callback</span>)</span>&#123;<br>    fs.exists(base_path + lesson_id + <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exists</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(!exists)&#123;<br>            callback([]);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            fs.readdir(base_path + lesson_id + <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>                <span class="hljs-keyword">if</span>(err)&#123;<br>                    <span class="hljs-built_in">console</span>.log(err);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    callback(data);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>​ 当一个客户端请求下载某个课堂中的文件时，我们可以使用NodeJS自带的fs插件中的流式传输功能，将其输出管道重定向到请求回应流中即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.get(<span class="hljs-string">&#x27;/file_download&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">request, response</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> lesson_id = request.query.id;<br>  <span class="hljs-keyword">var</span> filename = request.query.filename;<br>  <span class="hljs-keyword">if</span>(lesson_id == <span class="hljs-literal">undefined</span> || filename == <span class="hljs-literal">undefined</span>)&#123;<br>    response.end();<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>    response.writeHead(<span class="hljs-number">200</span>, &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/octet-stream&#x27;</span>,<br>      <span class="hljs-string">&#x27;Content-Disposition&#x27;</span>: <span class="hljs-string">&#x27;attachment; filename=&#x27;</span> + <span class="hljs-built_in">encodeURI</span>(filename)<br>    &#125;);<br>    fs.createReadStream(<span class="hljs-string">&#x27;file_upload/&#x27;</span> + lesson_id + <span class="hljs-string">&#x27;/&#x27;</span> + filename).pipe(response);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>至此，我们已经实现了一个基本的文件共享功能，效果如下：</p><p><img src="file_download.png" alt="file_download" style="zoom:50%;" /></p><h2 id="实时做题">实时做题</h2><p>​ 在在线课堂系统中，有时教师希望能够即时给学生分发一道课堂练习，并实时看到学生的答题状况，这就需要我们实现一套在线做题系统。</p><p>​ 在线做题首先需要教师端上传一道指定的题目。以选择题为例，为了方便结构化解析，我们要求教师上传一个固定格式的json文件作为题目（当然也可使用深度学习技术自动解析非结构化的题目信息，不过这一工程量将大幅度增长，在此我们不做讨论）：</p><p><img src="problem_upload.png" alt="problem_upload" style="zoom:50%;" /></p><p>​ 题目共享功能实现的主体思路与文件共享类似，我们只需要让教师端将题目以文件的形式发送给服务端，再通过服务端将题目分发给学生端即可。不过，为了让用户即时看到可阅读的题目信息，我们还需要在后端将题目文件解析为格式化信息，并通过json字符串的方式将结构化的题目发送给前端：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> get_problem = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">problem_base, lesson_id, callback</span>)</span>&#123;<br>    fs.exists(problem_base + lesson_id + <span class="hljs-string">&#x27;/question.json&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">exists</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> status = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 1 - 读取成功; 2 - 文件不存在; 3 - 读取错误 ;*/</span><br>        <span class="hljs-keyword">if</span>(!exists)&#123;<br>            status = <span class="hljs-number">2</span>;<br>            callback(status, <span class="hljs-literal">undefined</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">var</span> data = fs.readFileSync(problem_base + lesson_id + <span class="hljs-string">&#x27;/question.json&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> data == <span class="hljs-string">&#x27;string&#x27;</span>)&#123;<br>                status = <span class="hljs-number">1</span>;<br>                callback(status, data);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                status = <span class="hljs-number">3</span>;<br>                callback(status, <span class="hljs-literal">undefined</span>);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>前端展示实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">q-page</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex flex-top-left&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: 3%; margin-left: 3%&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">q-btn</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;secondary&quot;</span> <span class="hljs-attr">padding</span>=<span class="hljs-string">&quot;sm xl&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-bottom: 5%&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;上传题目&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onProblemUpload&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">q-form</span> @<span class="hljs-attr">submit</span>=<span class="hljs-string">&quot;onSubmitAnswer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;q-gutter-md&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span> 实时题目 <span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> &#123;&#123;problem_description&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">q-option-group</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;chosen_answer&quot;</span> <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;answer_options&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;primary&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">q-btn</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;提交答案&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;primary&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">q-form</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">q-page</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">        name: <span class="hljs-string">&#x27;lesson&#x27;</span>,</span><br>        data()&#123;<br><span class="javascript">            <span class="hljs-keyword">return</span>&#123;</span><br><span class="javascript">                username: <span class="hljs-string">&quot;&quot;</span>,</span><br>                lesson_id: 0,<br><span class="javascript">                problem_description: <span class="hljs-string">&quot;3466645r15&quot;</span>,</span><br><span class="javascript">                chosen_answer: <span class="hljs-string">&quot;&quot;</span>,</span><br>                answer_options: [<br>                    &#123;<br><span class="javascript">                        label: <span class="hljs-string">&quot;Answer1&quot;</span>,</span><br><span class="javascript">                        value: <span class="hljs-string">&quot;A&quot;</span></span><br>                    &#125;<br>                ]<br>            &#125;<br>        &#125;,<br><span class="javascript">        mounted: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.onInitLesson();</span><br>        &#125;,<br>        methods: &#123;<br>            onInitLesson()&#123;<br><span class="javascript">                <span class="hljs-built_in">this</span>.username = <span class="hljs-built_in">this</span>.$route.query.username;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.lesson_id = <span class="hljs-built_in">this</span>.$route.query.lesson_id;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.getProblem();</span><br>            &#125;,<br>            getProblem()&#123;<br><span class="javascript">                <span class="hljs-keyword">var</span> full_url = <span class="hljs-string">&#x27;problem_get?id=&#x27;</span> + <span class="hljs-built_in">this</span>.lesson_id;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.axios.get(full_url).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;</span><br><span class="javascript">                    <span class="hljs-keyword">var</span> problem_json = response.data;</span><br><span class="javascript">                    <span class="hljs-keyword">if</span>(problem_json != <span class="hljs-literal">undefined</span>)&#123;</span><br><span class="javascript">                        <span class="hljs-built_in">this</span>.problem_description = problem_json.description;</span><br><span class="javascript">                        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> problem_json.options)&#123;</span><br><span class="javascript">                            <span class="hljs-built_in">this</span>.answer_options.push(&#123;</span><br>                                label: problem_json.options[key],<br>                                value: key<br>                            &#125;);<br>                        &#125;<br><span class="javascript">                        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.answer_options);</span><br>                    &#125;<br><span class="javascript">                &#125;).catch(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;</span><br><span class="javascript">                    <span class="hljs-built_in">console</span>.log(response);</span><br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​ 现在，学生用户已经可以随时接受教师下发的课堂练习并做答了。接下来，我们需要让教师端能够实时得到学生的做题反馈。为了实现这一功能，我们需要让前端实时监听后端的数据变化，并在后端产生数据变化时发送消息给前端。在NodeJS中，我们可以使用WebSocket插件来实现。</p><p>​ 首先，我们在服务端创建一个WebSocket服务器，并监听8000端口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;nodejs-websocket&#x27;</span>);<br><br><span class="hljs-keyword">var</span> ws_server = ws.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  <span class="hljs-comment">//Irrelevant codes</span><br>&#125;).listen(<span class="hljs-number">8000</span>);<br></code></pre></td></tr></table></figure><p>当学生前端点击提交答案按钮时，我们通过这一端口将回答信息通知给后端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">q-page</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex flex-top-left&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: 3%; margin-left: 3%&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">q-form</span> @<span class="hljs-attr">submit</span>=<span class="hljs-string">&quot;onSubmitAnswer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;q-gutter-md&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span> 实时题目 <span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> &#123;&#123;problem_description&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">q-option-group</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;chosen_answer&quot;</span> <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;answer_options&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;primary&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">q-btn</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;提交答案&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;primary&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">q-form</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">q-page</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">        name: <span class="hljs-string">&#x27;lesson&#x27;</span>,</span><br>        data()&#123;<br><span class="javascript">            <span class="hljs-keyword">return</span>&#123;</span><br><span class="javascript">                username: <span class="hljs-string">&quot;&quot;</span>,</span><br>                lesson_id: 0,<br><span class="javascript">                chosen_answer: <span class="hljs-string">&quot;&quot;</span></span><br>            &#125;<br>        &#125;,<br><span class="javascript">        mounted: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.onInitLesson();</span><br><span class="javascript">            <span class="hljs-keyword">var</span> full_path = <span class="hljs-built_in">window</span>.document.location.href;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> route_path = <span class="hljs-built_in">this</span>.$route.path;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> base_path = full_path.substring(<span class="hljs-number">7</span>, full_path.indexOf(route_path));</span><br><span class="javascript">            <span class="hljs-keyword">var</span> base_path_stripped = base_path.substring(<span class="hljs-number">0</span>, base_path.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>));</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.web_socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://&quot;</span> + base_path_stripped + <span class="hljs-string">&quot;:8000&quot;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.web_socket.onopen = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Websocket连接成功！&quot;</span>)</span><br>            &#125;<br><span class="javascript">            <span class="hljs-built_in">this</span>.web_socket.onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(event.data);</span><br>            &#125;<br>        &#125;,<br><span class="javascript">        destroyed: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.web_socket.close();</span><br>        &#125;,<br>        methods: &#123;<br>            onSubmitAnswer()&#123;<br><span class="javascript">                <span class="hljs-built_in">this</span>.web_socket.send(<span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;problem_answer&quot;</span>, <span class="hljs-attr">username</span>: <span class="hljs-built_in">this</span>.username, <span class="hljs-attr">lesson_id</span>: <span class="hljs-built_in">this</span>.lesson_id, <span class="hljs-attr">answer</span>: <span class="hljs-built_in">this</span>.chosen_answer&#125;));</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于每一个课程实例，服务端维护着一个当前题目的回答列表，每当后端收到前端发来的回答通知时，便将对应的计数器加一。随后，服务端会通知教师客户端更新实时统计信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ws_server = ws.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> answer_status = &#123;<br>    <span class="hljs-string">&quot;6&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-string">&quot;B&quot;</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-string">&quot;D&quot;</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>  socket.on(<span class="hljs-string">&#x27;text&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>)</span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">var</span> obj=<span class="hljs-built_in">JSON</span>.parse(str);<br>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj == <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; obj )&#123;<br>          <span class="hljs-keyword">if</span>(obj.type == <span class="hljs-string">&quot;problem_answer&quot;</span>)&#123;<br>            <span class="hljs-keyword">var</span> lesson_id = obj.lesson_id;<br>            <span class="hljs-keyword">var</span> answer = obj.answer;<br>            <span class="hljs-keyword">if</span>(lesson_id != <span class="hljs-literal">undefined</span> &amp;&amp; answer != <span class="hljs-literal">undefined</span>)&#123;<br>              answer_status[lesson_id][answer] += <span class="hljs-number">1</span>;<br>              ws_server.connections.forEach(<span class="hljs-function">(<span class="hljs-params">connection</span>) =&gt;</span> &#123;<br>                connection.sendText(<span class="hljs-built_in">JSON</span>.stringify(answer_status));<br>              &#125;);<br>            &#125;<br>          &#125;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Error phasing json!&quot;</span>);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>        <span class="hljs-built_in">console</span>.log(e);<br>    &#125;<br>  &#125;);<br>&#125;).listen(<span class="hljs-number">8000</span>);<br></code></pre></td></tr></table></figure><p>对于前端统计信息，这里我们使用Echarts图表的形式将答题的即时情况展现给教师：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">q-page</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex flex-center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;answer_chart&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123;width: &#x27;300px&#x27;, height: &#x27;300px&#x27;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">q-page</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">        name: <span class="hljs-string">&#x27;problemStatistics&#x27;</span>,</span><br>        data()&#123;<br><span class="javascript">            <span class="hljs-keyword">return</span>&#123;</span><br><span class="javascript">                username: <span class="hljs-string">&quot;&quot;</span>,</span><br>                lesson_id: 0,<br><span class="javascript">                web_socket: <span class="hljs-literal">null</span>,</span><br><span class="javascript">                chart: <span class="hljs-literal">null</span></span><br>            &#125;<br>        &#125;,<br><span class="javascript">        mounted: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.onInitLesson();</span><br><span class="javascript">            <span class="hljs-keyword">var</span> echarts = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;echarts&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.chart = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;answer_chart&#x27;</span>));</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.chart.setOption(&#123;</span><br><span class="javascript">                title: &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学生实时答题情况统计&#x27;</span> &#125;,</span><br>                tooltip: &#123;&#125;,<br>                xAxis: &#123;<br><span class="javascript">                    data: [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>]</span><br>                &#125;,<br>                yAxis: &#123;&#125;,<br>                series: [&#123;<br><span class="javascript">                    name: <span class="hljs-string">&#x27;选择人数&#x27;</span>,</span><br><span class="javascript">                    type: <span class="hljs-string">&#x27;bar&#x27;</span>,</span><br>                    data: [0, 0, 0, 0]<br>                &#125;]<br>            &#125;);<br><span class="javascript">            <span class="hljs-keyword">var</span> full_path = <span class="hljs-built_in">window</span>.document.location.href;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> route_path = <span class="hljs-built_in">this</span>.$route.path;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> base_path = full_path.substring(<span class="hljs-number">7</span>, full_path.indexOf(route_path));</span><br><span class="javascript">            <span class="hljs-keyword">var</span> base_path_stripped = base_path.substring(<span class="hljs-number">0</span>, base_path.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>));</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.web_socket = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://&quot;</span> + base_path_stripped + <span class="hljs-string">&quot;:8000&quot;</span>);</span><br><span class="javascript">            <span class="hljs-built_in">this</span>.web_socket.onopen = <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Websocket连接成功！&quot;</span>)</span><br>            &#125;<br><span class="javascript">            <span class="hljs-built_in">this</span>.web_socket.onmessage = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;</span><br><span class="javascript">                <span class="hljs-keyword">var</span> latest_data = <span class="hljs-built_in">JSON</span>.parse(event.data);</span><br><span class="javascript">                <span class="hljs-keyword">if</span>(latest_data != <span class="hljs-literal">undefined</span>)&#123;</span><br><span class="javascript">                    <span class="hljs-keyword">var</span> stat_dict = latest_data[<span class="hljs-built_in">this</span>.lesson_id];</span><br><span class="javascript">                    <span class="hljs-keyword">var</span> x_tags = [];</span><br><span class="javascript">                    <span class="hljs-keyword">var</span> y_values = [];</span><br><span class="javascript">                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> stat_dict)&#123;</span><br>                        x_tags.push(key);<br>                        y_values.push(stat_dict[key]);<br>                    &#125;<br><span class="javascript">                    <span class="hljs-built_in">this</span>.refreshChart(x_tags, y_values);</span><br>                &#125;<br>            &#125;<br>        &#125;,<br>        methods: &#123;<br>            onInitLesson()&#123;<br><span class="javascript">                <span class="hljs-built_in">this</span>.username = <span class="hljs-built_in">this</span>.$route.query.username;</span><br><span class="javascript">                <span class="hljs-built_in">this</span>.lesson_id = <span class="hljs-built_in">this</span>.$route.query.lesson_id;</span><br>            &#125;,<br>            refreshChart(x, y)&#123;<br><span class="javascript">                <span class="hljs-built_in">this</span>.chart.setOption(&#123;</span><br><span class="javascript">                title: &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学生实时答题情况统计&#x27;</span> &#125;,</span><br>                tooltip: &#123;&#125;,<br>                xAxis: &#123;<br>                    data: x<br>                &#125;,<br>                yAxis: &#123;&#125;,<br>                series: [&#123;<br><span class="javascript">                    name: <span class="hljs-string">&#x27;选择数&#x27;</span>,</span><br><span class="javascript">                    type: <span class="hljs-string">&#x27;bar&#x27;</span>,</span><br>                    data: y<br>                &#125;]<br>            &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>页面效果如下：</p><p><img src="problem_stat.png" alt="problem_stat" style="zoom:50%;" /></p><h2 id="快速签到">快速签到</h2><h2 id="视频推流">视频推流</h2><h2 id="远程访问">远程访问</h2><p>​ 至此，我们已经实现了树莓派在线教学系统的绝大部分基本功能。我们将其通过SFTP上传至树莓派中的目标目录下，并启动服务。通过树莓派提供的热点，我们在另一台设备上远程访问树莓派的网站接口，发现其已经可以正常工作：</p><p><img src="remote_comp.png" alt="remote_comp" style="zoom:50%;" /></p><p>同样的，我们也可以使用移动端访问树莓派上的教学服务：</p><p><img src="remote_phone.PNG" alt="remote_phone" style="zoom:30%;" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Web</tag>
      
      <tag>Frontend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据科学与工程数学基础 作业5</title>
    <link href="/2021/06/12/dase-math/dase-math-assignment-5/"/>
    <url>/2021/06/12/dase-math/dase-math-assignment-5/</url>
    
    <content type="html"><![CDATA[<h2 id="一">一</h2><blockquote><p>求随机变量 <span class="math inline">\(X \sim b(n,p)\)</span> 的期望与方差。</p></blockquote><p>由 <span class="math inline">\(X \sim b(n, p)\)</span> 可知 <span class="math display">\[P(X=k) = \binom{n}{k} p^k (1-p)^{1-k}, k \in \{0,1,2,\cdots,n\}\]</span> 故其期望为 <span class="math display">\[\begin{aligned}E(X) &amp;= \sum_\limits{k = 0}^n k \binom{n}{k} p^k (1-p)^{n-k} \\&amp;= \sum_\limits{k = 1}^n k \binom{n}{k} p^k (1-p)^{n-k} \\&amp;= \sum_\limits{k = 1}^n n \binom{n-1}{k-1} p^k (1-p)^{n-k} \\&amp;=np \sum_\limits{k = 1}^n \binom{n-1}{k-1} p^{k-1} (1-p)^{n-k} \\&amp;=np \sum_\limits{m = 0}^{n-1} \binom{n-1}{m} p^m (1-p)^{n-1-m} \\&amp;=np \cdot (p+1-p)^{n-1} \\&amp;=np\end{aligned}\]</span> 又由 <span class="math display">\[\begin{aligned}E(X^2) &amp;= \sum_\limits{k = 0}^n k^2 \binom{n}{k} p^k (1-p)^{n-k} \\&amp;= n \cdot \sum_\limits{k = 1}^n k \binom{n-1}{k-1} p^k (1-p)^{n-k} \\&amp;= n \cdot \sum_\limits{k = 1}^n (k - 1 + 1) \binom{n-1}{k-1} p^k (1-p)^{n-k} \\&amp;= n \cdot \left[ \sum_\limits{k = 1}^n (k - 1) \binom{n-1}{k-1} p^k (1-p)^{n-k} + \sum_\limits{k = 1}^n  \binom{n-1}{k-1} p^k (1-p)^{n-k} \right] \\&amp;=n \cdot \sum_\limits{k = 2}^n (n - 1) \binom{n-2}{k-2} p^k (1-p)^{n-k} + n \cdot \sum_\limits{k = 1}^n  \binom{n-1}{k-1} p^k (1-p)^{n-k} \\&amp;= n(n-1)p^2 + np\end{aligned}\]</span> 可知其方差为 <span class="math display">\[\begin{aligned}Var(X) &amp;= E(X^2) - E^2(X) \\&amp;=n(n-1)p^2 + np - n^2p^2 \\&amp;=n^2p^2-np^2+ np - n^2p^2 \\&amp;=np(1-p)\end{aligned}\]</span></p><h2 id="二">二</h2><blockquote><p>设连续性随机变量 <span class="math inline">\(X\)</span> 的分布函数为 <span class="math display">\[F_X(x) = \left\{\begin{aligned}&amp;0 ,&amp; x &lt; 1 \\&amp;\ln x ,&amp; 1 \leq x &lt; e \\&amp;1 ,&amp; x \geq e\end{aligned}\right.\]</span></p><ol type="1"><li>求 <span class="math inline">\(P(X &lt; 2), P(0 &lt; X &lt;3)\)</span></li><li>求概率密度函数 <span class="math inline">\(f_X(x)\)</span></li></ol></blockquote><ol type="1"><li></li></ol><p><span class="math display">\[P(X&lt;2) = F_X(2)= \ln 2 \\P(0&lt;X&lt;3) = F_X(3)-F_X(0)=1-0=1\]</span></p><ol start="2" type="1"><li></li></ol><p>由 <span class="math display">\[f_X(x) = \frac{d}{dx}F_X(x)\]</span> 可知</p><p>当 <span class="math inline">\(x&lt;1\)</span> 时，<span class="math inline">\(f_X(x) = 0\)</span></p><p>当 <span class="math inline">\(1&lt;x&lt;e\)</span> 时，<span class="math inline">\(f_X(x)=\frac{1}{x}\)</span></p><p>当 <span class="math inline">\(x&gt;e\)</span> 时，<span class="math inline">\(f_X(x) = 0\)</span></p><p>又 <span class="math display">\[F&#39;_-(1) = \lim_{x \to 1^-} \frac{f(1)-f(x)}{1-x}= 0 \neq 1 = F&#39;_+(1) \\F&#39;_-(e) = \lim_{x \to e^-} \frac{f(e)-f(x)}{e-x}= \frac{1}{e} \neq 0 = F&#39;_+(e)\]</span> 故 <span class="math inline">\(f_X(x)\)</span> 在 <span class="math inline">\(x=1\)</span> 和 <span class="math inline">\(x=e\)</span> 处不存在</p><p>因此 <span class="math display">\[f_X(x) = \left\{\begin{aligned}0 &amp;,&amp; x &lt; 1 \\\frac{1}{x} &amp;,&amp; 1 &lt; x &lt; e \\0 &amp;,&amp; x&gt;e\end{aligned}\right.\]</span></p><h2 id="三">三</h2><blockquote><p>下表为二维离散随机变量 <span class="math inline">\((X,Y)\)</span> 的联合分布列，其中最后一列为随机变量 <span class="math inline">\(Y\)</span> 的边缘分布列，最后一行为随机变量 <span class="math inline">\(X\)</span> 的边缘分布列，且 <span class="math inline">\(X,Y\)</span> 独立。试将下表补充完整，并给出 <span class="math inline">\(X,Y\)</span> 的协方差 <span class="math inline">\(\textrm{Cov}(X,Y)\)</span></p></blockquote><table><thead><tr class="header"><th></th><th><span class="math inline">\(X=1\)</span></th><th><span class="math inline">\(X=2\)</span></th><th><span class="math inline">\(X=3\)</span></th><th><span class="math inline">\(P_Y(Y)\)</span></th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(Y=1\)</span></td><td><span class="math inline">\(0.03\)</span></td><td><span class="math inline">\(0.15\)</span></td><td><span class="math inline">\(0.12\)</span></td><td><span class="math inline">\(0.3\)</span></td></tr><tr class="even"><td><span class="math inline">\(Y=2\)</span></td><td><span class="math inline">\(0.03\)</span></td><td><span class="math inline">\(0.15\)</span></td><td><span class="math inline">\(0.12\)</span></td><td><span class="math inline">\(0.3\)</span></td></tr><tr class="odd"><td><span class="math inline">\(Y=3\)</span></td><td><span class="math inline">\(0.02\)</span></td><td><span class="math inline">\(0.1\)</span></td><td><span class="math inline">\(0.08\)</span></td><td><span class="math inline">\(0.2\)</span></td></tr><tr class="even"><td><span class="math inline">\(Y=4\)</span></td><td><span class="math inline">\(0.02\)</span></td><td><span class="math inline">\(0.1\)</span></td><td><span class="math inline">\(0.08\)</span></td><td><span class="math inline">\(0.2\)</span></td></tr><tr class="odd"><td><span class="math inline">\(P_X(X)\)</span></td><td><span class="math inline">\(0.1\)</span></td><td><span class="math inline">\(0.5\)</span></td><td><span class="math inline">\(0.4\)</span></td><td><span class="math inline">\(/\)</span></td></tr></tbody></table><p>由于 <span class="math inline">\(X,Y\)</span> 独立，故 <span class="math inline">\(Cov(X,Y) = 0\)</span></p><h2 id="四">四</h2><blockquote><p>已知所有的胰腺癌患者都有某症状，若一个人有该症状的概率为万分之一，并且胰腺癌的发病概率也为万分之一。问若一个人有该症状，则他也是胰腺癌患者的概率为多少。</p></blockquote><p>设 <span class="math inline">\(A=\{有该症状\},B=\{有胰腺癌\}\)</span></p><p>由于 <span class="math inline">\(B \subset A\)</span></p><p>故 <span class="math display">\[P(B|A) = \frac{P(A \cap B)}{P(A)} = \frac{P(B)}{P(A)} = 1\]</span></p><h2 id="五">五</h2><blockquote><p>一个不透明的箱子中有一些红球和白球，有放回地在箱子中随机摸出5个球，分别为红、白、白、白、红，试估计箱子中红球与白球的比例。</p></blockquote><p>设箱子中摸出红球的概率为 <span class="math inline">\(p\)</span>， <span class="math display">\[X_i = \left\{\begin{aligned}1, 第i次摸出红球 \\0, 第i次摸出白球\end{aligned}\right.\]</span> 故 <span class="math inline">\(X_i \stackrel{i.i.d}{\sim} b(1,p) \ , i \in \{1,2,3,4,5\}\)</span></p><p>于是 <span class="math display">\[L(p) = p^{\sum_\limits{i = 1}^n x_i} (1-p)^{n-\sum_\limits{i = 1}^n x_i}\]</span> 故 <span class="math display">\[\frac{\partial \ln L(p)}{\partial p} = \frac{\sum_\limits{i = 1}^n x_i}{p} - \frac{n - \sum_\limits{i = 1}^n x_i}{1-p}\]</span> 于是 <span class="math inline">\(p\)</span> 的极大似然估计 <span class="math display">\[\hat{p} = \bar{x} = \frac{1+0+0+0+1}{5} = \frac{2}{5}\]</span> 故 <span class="math display">\[\frac{红球}{白球} = \frac{2}{3}\]</span></p><h2 id="六">六</h2><blockquote><p>随机地取8只活塞环，测得他们的直径为(以mm计)</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">74</span>.<span class="hljs-number">001</span> <span class="hljs-number">74</span>.<span class="hljs-number">005</span> <span class="hljs-number">74</span>.<span class="hljs-number">003</span> <span class="hljs-number">74</span>.<span class="hljs-number">001</span><br><span class="hljs-attribute">74</span>.<span class="hljs-number">000</span> <span class="hljs-number">73</span>.<span class="hljs-number">998</span> <span class="hljs-number">74</span>.<span class="hljs-number">006</span> <span class="hljs-number">74</span>.<span class="hljs-number">002</span><br></code></pre></td></tr></table></figure><p>试求总体均值 <span class="math inline">\(\mu\)</span> 以及方差 <span class="math inline">\(\sigma^2\)</span> 的矩估计值。</p></blockquote><p><span class="math display">\[\begin{aligned}\hat{\mu} &amp;= \bar{x} \\&amp;= \frac{74.001+74.005+74.003+74.001+74.000+73.998+74.006+74.002}{8} \\&amp;=74.002\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}\hat{\sigma^2} &amp;= s^2 \\&amp;=\frac{1}{7} \left[ (74.001 - 74.002)^2 + (74.005 - 74.002)^2 + (74.003 - 74.002)^2 + (74.001 - 74.002)^2 + (74.000 - 74.002)^2 + (73.998 - 74.002)^2 + (74.006 - 74.002)^2 + (74.002 - 74.002)^2 \right] \\&amp; \approx 6.8571 \times 10^{-6}\end{aligned}\]</span></p><h2 id="七">七</h2><blockquote><p>给定 <span class="math inline">\(N\)</span> 个独立同分布样本 <span class="math inline">\(x_t\)</span>，服从多元正态分布 <span class="math display">\[G(x_t) = \frac{1}{(2 \pi)^{\frac{d}{2}} |\Sigma|^{\frac{1}{2}}} \exp \left\{ -\frac{1}{2} (x_t - \mu)^T \Sigma^{-1} (x_t - \mu) \right\}\]</span> ，其中 <span class="math inline">\(\Sigma\)</span> 是可逆对称矩阵，<span class="math inline">\(x_t, \mu \in \mathbb{R}^d\)</span>。 利用极大似然估计(MLE)估计参数 <span class="math inline">\(\mu, \Sigma\)</span>。</p></blockquote><p>似然函数 <span class="math display">\[\begin{aligned}L(\mu, \Sigma) &amp;= \prod_{i = 1}^n \frac{1}{(2 \pi)^{\frac{d}{2}} |\Sigma|^{\frac{1}{2}}} e^{-\frac{1}{2} (x_i - \mu)^T \Sigma^{-1} (x_i - \mu)} \\&amp;=\frac{1}{(2\pi)^{\frac{nd}{2}} |\Sigma|^{\frac{n}{2}}} e^{-\frac{1}{2} \sum_\limits{i = 1}^n (x_i-\mu)^T \Sigma^{-1} (x_i - \mu)}\end{aligned}\]</span> 故其对数似然函数 <span class="math display">\[l(\mu, \Sigma) = -\frac{nd}{2} \ln(2\pi) - \frac{n}{2} \ln |\Sigma| - \frac{1}{2}\sum_{i = 1}^n (x_i - \mu)^T \Sigma^{-1} (x_i - \mu)\]</span> 由于 <span class="math display">\[\begin{aligned}dl &amp;= Tr\left[ d \left( -\frac{nd}{2} \ln(2\pi) - \frac{n}{2} \ln |\Sigma| - \frac{1}{2}\sum_{i = 1}^n (x_i - \mu)^T \Sigma^{-1} (x_i - \mu) \right) \right] \\&amp;=Tr \left[ -\frac{1}{2} \sum_{i = 1}^n \left( d (x_i- \mu)^T \cdot \Sigma^{-1} \cdot (x_i - \mu) + (x_i - \mu)^T \cdot \Sigma^{-1} \cdot d(x_i - \mu) \right)\right] \\&amp;=Tr \left[  \frac{1}{2} \sum_{i = 1}^n \left( d \mu^T \cdot \Sigma^{-1} \cdot (x_i - \mu) + (x_i - \mu)^T \cdot \Sigma^{-1} \cdot d \mu \right) \right] \\&amp;=Tr \left[  \frac{1}{2} \sum_{i = 1}^n \left( (x_i - \mu)^T \cdot \left( \Sigma^{-1} \right)^T \cdot d \mu + (x_i - \mu)^T \cdot \Sigma^{-1} \cdot d \mu \right) \right] \\&amp;=Tr \left[ \sum_{i = 1}^n  \left( (x_i - \mu)^T \cdot \Sigma^{-1}\right) d\mu \right]\end{aligned}\]</span> 故 <span class="math display">\[\frac{\partial l}{\partial \mu} = \Sigma^{-1} \sum_{i = 1}^n (x_i - \mu)\]</span> 因此 <span class="math display">\[\hat{\mu} = \frac{1}{n}\sum_{i = 1}^n x_i = \bar{x}\]</span> 又由于 <span class="math display">\[\begin{aligned}dl &amp;= Tr \left[ -\frac{n}{2} d \ln |\Sigma| -\frac{1}{2} \sum_{i = 1}^n (x_i - \mu)^T \cdot d \Sigma^{-1} \cdot (x_i - \mu) \right] \\&amp;=Tr \left[ -\frac{n}{2 |\Sigma|} |\Sigma|\Sigma^{-1} d \Sigma + \frac{1}{2}\sum_{i = 1}^n \left( (x_i - \mu)^T \cdot \Sigma^{-1} d\Sigma \cdot \Sigma^{-1} \cdot (x_i - \mu) \right)\right] \\&amp;=Tr \left[-\frac{n}{2}\Sigma^{-1} d \Sigma \right] + \frac{1}{2} \sum_{i = 1}^n Tr \left[ \Sigma^{-1} \cdot (x_i - \mu)(x_i - \mu)^T \cdot \Sigma^{-1} d \Sigma \right] \\&amp;=Tr \left[\left( -\frac{n}{2}\Sigma^{-1} + \frac{1}{2}\sum_{i = 1}^n \left( \Sigma^{-1} (x_i - \mu)(x_i - \mu)^T \Sigma^{-1} \right) \right) d \Sigma \right]\end{aligned}\]</span> 故 <span class="math display">\[\frac{\partial l}{\partial \Sigma} = \frac{1}{2} \sum_{i = 1}^n \left(\Sigma^{-1} (x_i - \mu)(x_i - \mu)^T \Sigma^{-1} \right) - \frac{n}{2}\Sigma^{-1}\]</span> 因此 <span class="math display">\[\begin{aligned}\hat{\Sigma} &amp;= \frac{1}{n}\sum_{i = 1}^n (x_i - \mu)(x_i - \mu)^T \\&amp;=\frac{1}{n}\sum_{i = 1}^n (x_i - \bar{x})(x_i - \bar{x})^T\end{aligned}\]</span></p><h2 id="八">八</h2><blockquote><p>证明：在多分类问题中，利用交叉熵函数作为损失函数和用KL散度作为损失函数是等价的。</p></blockquote><p>对于多分类问题，若设 <span class="math inline">\(p_i\)</span> 为第 <span class="math inline">\(i\)</span> 个数据的目标输出，<span class="math inline">\(q_i\)</span> 为第 <span class="math inline">\(i\)</span> 个数据的实际输出，则 <span class="math display">\[L_{CrossEntropy} = -\sum_{i = 1}^n p_i \ln q_i \\L_{KL} = \sum_{i = 1}^n p_i \ln p_i - \sum_{i = 1}^n p_i \ln q_i\]</span> 二者仅相差一个与 <span class="math inline">\(q_i\)</span> 无关的常数，即 <span class="math display">\[\frac{\partial L_{CrossEntropy}}{\partial q_i} = \frac{\partial L_{KL}}{\partial q_i} = -\frac{p_i}{q_i}\]</span> 故二者作为损失函数等价</p><h2 id="九">九</h2><blockquote><p>同时抛2颗骰子，事件 <span class="math inline">\(A,B,C\)</span> 分别表示为 <span class="math display">\[A: 仅有一个骰子是3 \\B: 至少一个骰子是4 \\C: 骰子上点数总和为偶数\]</span> 试计算事件 <span class="math inline">\(A,B,C\)</span> 发生后所提供的信息量</p></blockquote><p><span class="math display">\[\begin{aligned}I_1 &amp;= - \lg \frac{5}{18} \approx 1.8480 \\I_2 &amp;= -\lg \frac{11}{36} \approx 1.7105 \\I_3 &amp;= -\lg \frac{1}{2} = 1\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>数据科学数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>DataScience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验 内存管理</title>
    <link href="/2021/06/08/os/os-exp-memory/"/>
    <url>/2021/06/08/os/os-exp-memory/</url>
    
    <content type="html"><![CDATA[<h2 id="this-page-is-temporarily-forbidden-for-the-course-regulation.">This page is temporarily forbidden for the course regulation.</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Operating-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据科学与工程数学基础 作业4</title>
    <link href="/2021/06/02/dase-math/dase-math-assignment-4/"/>
    <url>/2021/06/02/dase-math/dase-math-assignment-4/</url>
    
    <content type="html"><![CDATA[<h2 id="一">一</h2><blockquote><p>构建模型使得预测值与真实值的误差最小常用向量2-范数度量，求解模型过程中需要计算梯度，求梯度：</p><ul><li><p><span class="math inline">\(f(A) = \frac{1}{2} ||Ax + b - y ||_2^2\)</span>，求 <span class="math inline">\(\frac{\partial f}{\partial A}\)</span></p></li><li><p><span class="math inline">\(f(x) = \frac{1}{2} ||Ax + b - y ||_2^2\)</span>，求 <span class="math inline">\(\frac{\partial f}{\partial x}\)</span></p></li></ul><p>，其中 <span class="math inline">\(A \in \mathbb{R}^{m \times n}, x \in \mathbb{R}^n, b, y \in \mathbb{R}^m\)</span></p></blockquote><p>由 <span class="math display">\[\begin{aligned}f(\textbf{A}, x) &amp;= \frac{1}{2} || \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} ||_2^2 \\&amp;=\frac{1}{2} \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)\end{aligned}\]</span> 可知 <span class="math display">\[\begin{aligned}df &amp;= d \left[\ Tr \left(\frac{1}{2} \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)\right) \right] \\&amp;= \frac{1}{2} Tr \left[ d \left( \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) \right)\right] \\&amp;=\frac{1}{2} Tr \left[ d\left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) + \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot d \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) \right] \\&amp;=\frac{1}{2} Tr \left[ \textbf{x}^T \cdot d \textbf{A}^T \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) + \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot d \textbf{A} \cdot \textbf{x} \right] \\&amp;=\frac{1}{2} \left\{ Tr \left[ \textbf{x}^T \cdot d \textbf{A}^T \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) \right] + Tr \left[ \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot d \textbf{A} \cdot \textbf{x} \right] \right\} \\&amp;= \frac{1}{2} \left\{ Tr \left[ d \textbf{A}^T \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) \cdot \textbf{x}^T \right] + Tr \left[ \textbf{x} \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot d \textbf{A} \right] \right\} \\&amp;= \frac{1}{2} \left\{ Tr \left[ \textbf{x} \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot d \textbf{A} \right] + Tr \left[ \textbf{x} \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot d \textbf{A} \right] \right\} \\&amp;= \frac{1}{2} Tr \left[ 2 \cdot \textbf{x} \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot d \textbf{A} \right] \\&amp;= Tr \left[ \textbf{x} \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot d \textbf{A} \right]\end{aligned}\]</span> 故 <span class="math display">\[\frac{\partial f}{\partial \textbf{A}} = \left(\textbf{x} \cdot (\textbf{A} \textbf{x}+\textbf{b}-\textbf{y})^T\right)^T = (\textbf{A} \textbf{x}+\textbf{b}-\textbf{y}) \cdot \textbf{x}^T\]</span> 又 <span class="math display">\[\begin{aligned}df &amp;=\frac{1}{2} Tr \left[ d\left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) + \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot d \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) \right] \\&amp;=\frac{1}{2} Tr \left[ d\textbf{x}^T \cdot \textbf{A}^T \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) + \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot \textbf{A} \cdot d\textbf{x} \right] \\&amp;=\frac{1}{2} \left\{ Tr \left[ d\textbf{x}^T \cdot \textbf{A}^T \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right) \right] + Tr \left[ \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot \textbf{A} \cdot d\textbf{x} \right] \right\} \\&amp;= \frac{1}{2} \left\{ Tr \left[ \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot \textbf{A} \cdot d\textbf{x} \right] + Tr \left[ \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot \textbf{A} \cdot d\textbf{x} \right] \right\} \\&amp;= \frac{1}{2} Tr \left[ 2 \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot \textbf{A} \cdot d\textbf{x} \right] \\&amp;= Tr \left[ \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot \textbf{A} \cdot d\textbf{x} \right]\end{aligned}\]</span> 故 <span class="math display">\[\frac{\partial f}{\partial \textbf{x}} = \left( \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)^T \cdot \textbf{A} \right)^T = \textbf{A}^T \cdot \left( \textbf{A} \textbf{x} + \textbf{b} - \textbf{y} \right)\]</span></p><h2 id="二">二</h2><blockquote><p>利用迹微分法求解 <span class="math display">\[\frac{\partial \tr (W^{-1})}{\partial W}\]</span> ，其中 <span class="math inline">\(W \in \mathbb{R}^{m \times m}\)</span></p></blockquote><p>由 <span class="math display">\[\begin{aligned}d \ Tr(\textbf{W}^{-1}) &amp;= Tr \left[ d  \left( \textbf{W}^{-1} \right) \right] \\&amp;=Tr \left[ - \textbf{W}^{-1} \cdot d\textbf{W} \cdot \textbf{W}^{-1} \right] \\&amp;=Tr \left[ -\left(\textbf{W}^{-1}\right)^2 \cdot d \textbf{W} \right]\end{aligned}\]</span> 可知 <span class="math display">\[\frac{\partial Tr(\textbf{W}^{-1})}{\partial \textbf{W}} = -\left( \textbf{W}^{-2} \right)^T\]</span></p><h2 id="三">三</h2><blockquote><p>二次型是数据分析中常用函数，求 <span class="math display">\[\frac{\partial x^T A x}{\partial x}, \frac{\partial x^T A x}{\partial A}\]</span> ，其中 <span class="math inline">\(A \in \mathbb{R}^{m \times m}, x \in \mathbb{R}^m\)</span></p></blockquote><p>由 <span class="math display">\[\begin{aligned}d \left(\textbf{x}^T \textbf{A} \textbf{x} \right) &amp;= d \ Tr \left(\textbf{x}^T \textbf{A} \textbf{x} \right) \\&amp;=Tr \left[ d \left(\textbf{x}^T \textbf{A} \textbf{x} \right) \right] \\&amp;=Tr \left[ d \textbf{x}^T \cdot \textbf{A} \textbf{x} + \textbf{x}^T \textbf{A} \cdot d\textbf{x}  \right] \\&amp;=Tr \left[\textbf{x}^T \textbf{A}^T d\textbf{x} \right] + Tr \left[ \textbf{x}^T \textbf{A} d\textbf{x}\right] \\&amp;=Tr \left[ \textbf{x}^T (\textbf{A}^T + \textbf{A}) d\textbf{x}\right]\end{aligned}\]</span> 故 <span class="math display">\[\frac{\partial \textbf{x}^T \textbf{A} \textbf{x}}{\partial \textbf{x}} = \left(\textbf{x}^T (\textbf{A}^T + \textbf{A})\right)^T = (\textbf{A}+\textbf{A}^T)\textbf{x}\]</span> 又 <span class="math display">\[\begin{aligned}d \left(\textbf{x}^T \textbf{A} \textbf{x} \right) &amp;=Tr \left[ d \left(\textbf{x}^T \textbf{A} \textbf{x} \right) \right] \\&amp;=Tr \left[ \textbf{x}^T \cdot d \textbf{A} \cdot \textbf{x} \right] \\&amp;=Tr \left[\textbf{x} \textbf{x}^T d \textbf{A} \right] \\\end{aligned}\]</span> 故 <span class="math display">\[\frac{\partial \textbf{x}^T \textbf{A} \textbf{x}}{\partial \textbf{A}} = \left(\textbf{x}\textbf{x}^T \right)^T = \textbf{x}\textbf{x}^T\]</span></p><h2 id="四">四</h2><blockquote><p>定义 <span class="math inline">\((\exp(z))_i = \exp(z_i), (\ln (z))_i = \ln (z_i)\)</span>，则 <span class="math display">\[f(z) = \frac{\exp(z)}{\boldsymbol{1}^T \exp(z)}\]</span> 成为Softmax函数，如果 <span class="math inline">\(q = f(z), J = -p^T \ln (q)\)</span>，其中 <span class="math inline">\(p,q,z \in \mathbb{R}^n\)</span>，并且 <span class="math inline">\(\boldsymbol{1}^T p = 1\)</span>，则</p><ul><li>证明：<span class="math inline">\(\frac{\partial J}{\partial z} = q - p\)</span></li><li>若 <span class="math inline">\(z = Wx\)</span>，其中 <span class="math inline">\(W \in \mathbb{R}^{n \times m}, x \in \mathbb{R}^m, \frac{\partial J}{\partial W} = (q - p)x^T\)</span> 是否成立。</li></ul></blockquote><p><span class="math inline">\(\forall \textbf{x}, \textbf{y}, \textbf{z} \in \mathbb{R}^2, \lambda \in \mathbb{R}\)</span></p><p><strong>(1)</strong> 任取 <span class="math inline">\(i, j \in \{1,2,...,n\}\)</span></p><p>易得 <span class="math display">\[\frac{\partial J}{\partial q_j} = - \frac{p_j}{q_j}\]</span> 当 <span class="math inline">\(i \neq j\)</span> 时， <span class="math display">\[\frac{\partial q_j}{\partial z_i} = - \frac{e^{z_i + z_j}}{\left( \sum_\limits{k = 1}^n e^{z_k} \right)^2} = -q_i \cdot q_j\]</span> 当 <span class="math inline">\(i = j\)</span> 时， <span class="math display">\[\frac{\partial q_j}{\partial z_i} = \frac{e^{z_i} \cdot \left( \sum_\limits{k = 1}^n e^{z_k} \right) - e^{2z_i}}{\left( \sum_\limits{k = 1}^n e^{z_k} \right)^2} = q_i - q_i^2\]</span> 故 <span class="math display">\[\begin{aligned}\frac{\partial J}{\partial z_i} &amp;= \sum_{j = 1}^n \frac{\partial J}{\partial q_j} \cdot \frac{\partial q_j}{\partial z_i} \\&amp;=\sum_{j \neq i} \left( - \frac{p_j}{q_j} \right) (-q_i q_j) + \left(- \frac{p_i}{q_i} \right) (q_i - q_i^2) \\&amp;=q_i \cdot \sum_{j \neq i} p_j - p_i(1-q_i) \\\end{aligned}\]</span> 于是由 <span class="math inline">\(1^T p = \sum_\limits{i = 1}^n p_i = 1\)</span> 可知 <span class="math display">\[\frac{\partial J}{\partial z_i} = q_i (1 - p_i) - p_i(1-q_i) = q_i - p_i\]</span> 即 <span class="math display">\[\frac{\partial J}{\partial \textbf{z}} = \textbf{q} - \textbf{p}\]</span> <strong>(2)</strong> 由 <span class="math inline">\(d \ Tr (\textbf{W} \textbf{x}) = Tr \left( d \textbf{W} \cdot \textbf{x} \right) = Tr(\textbf{x} \cdot d \textbf{W})\)</span> 可知 <span class="math display">\[\frac{\partial J}{\partial \textbf{W}} = \textbf{x}^T\]</span> 故 <span class="math display">\[\frac{\partial J}{\partial \textbf{W}} = \frac{\partial J}{\partial \textbf{z}} \cdot \frac{\partial \textbf{z}}{\partial \textbf{W}} = (\textbf{q} - \textbf{p}) \textbf{x}^T\]</span> 成立</p><h2 id="五">五</h2><blockquote><p>以下内容是利用极大似然估计求解多元正态分布模型的关键步骤： <span class="math display">\[L = -\frac{Nd}{2} \ln (2 \pi) - \frac{N}{2} \ln |\Sigma| - \frac{1}{2} \sum_t (x_t - \mu)^T \Sigma^{-1} (x_t - \mu)\]</span> ，<span class="math inline">\(L\)</span> 是对数似然，<span class="math inline">\(N\)</span> 为样本数，<span class="math inline">\(d\)</span> 为样本维数，<span class="math inline">\(\Sigma \in \mathbb{R}^{d \times d}\)</span> 为协方差矩阵（对称矩阵），<span class="math inline">\(\mu \in \mathbb{R}^d\)</span> 为期望向量。</p><ul><li><p>求 <span class="math inline">\(\frac{\partial L}{\partial \mu}\)</span></p></li><li><p>当 <span class="math inline">\(\mu = \frac{1}{N} \sum_t x_t\)</span> 使，求 <span class="math inline">\(\frac{\partial L}{\partial \Sigma}\)</span>，并求使 <span class="math inline">\(\frac{\partial L}{\partial \Sigma} = 0\)</span> 成立的 <span class="math inline">\(\Sigma\)</span>。</p></li></ul></blockquote><p><strong>(1)</strong> <span class="math display">\[\begin{aligned}\frac{\partial L}{\partial \boldsymbol{\mu}} &amp;= -\frac{1}{2} \sum_{t = 1}^N \frac{\partial}{\partial \boldsymbol{\mu}} \left[ (\textbf{x}_t - \boldsymbol{\mu})^T \Sigma^{-1} (\textbf{x}_t - \boldsymbol{\mu})\right] \\&amp;= -\frac{1}{2} \sum_{t = 1}^N \frac{\partial \left[(\textbf{x}_t - \boldsymbol{\mu})^T \right]}{\partial \boldsymbol{\mu}} \cdot \frac{\partial \left[ (\textbf{x}_t - \boldsymbol{\mu})^T \Sigma^{-1} (\textbf{x}_t - \boldsymbol{\mu}) \right]}{\partial[\textbf{x}_t - \boldsymbol{\mu}]} \\&amp;=-\frac{1}{2} \sum_{t = 1}^N \left[ -2\Sigma^{-1}(\textbf{x}_t - \boldsymbol{\mu}) \right] \\&amp;=\Sigma^{-1} \cdot \sum_{t = 1}^N (\textbf{x}_t - \boldsymbol{\mu})\end{aligned}\]</span> <strong>(2)</strong></p><p>由 <span class="math display">\[\begin{aligned}dL &amp;= Tr \left[ d \left( - \frac{Nd}{2} \ln (2 \pi) - \frac{N}{2} \ln |\Sigma| - \frac{1}{2} \sum_{t = 1}^N (\textbf{x}_t - \boldsymbol{\mu})^T \Sigma^{-1} (\textbf{x}_t - \boldsymbol{\mu}) \right) \right] \\&amp;= Tr \left[ - \frac{N}{2} d \left(  \ln |\Sigma| \right) - \frac{1}{2} \sum_{t = 1}^N (\textbf{x}_t - \boldsymbol{\mu})^T \cdot d \left(\Sigma^{-1}\right) \cdot (\textbf{x}_t - \boldsymbol{\mu}) \right] \\&amp;= Tr \left[ - \frac{N}{2|\Sigma|}\cdot |\Sigma| \Sigma^{-1} d \Sigma + \frac{1}{2} \sum_{t = 1}^N (\textbf{x}_t - \boldsymbol{\mu}) (\textbf{x}_t - \boldsymbol{\mu})^T \cdot \Sigma^{-1} d \Sigma \cdot \Sigma^{-1} \right] \\&amp;= Tr \left[ \left(- \frac{N}{2}\cdot \Sigma^{-1} + \frac{1}{2} \sum_{t = 1}^N \Sigma^{-1} (\textbf{x}_t - \boldsymbol{\mu}) (\textbf{x}_t - \boldsymbol{\mu})^T \cdot \Sigma^{-1}\right) d \Sigma \right]\end{aligned}\]</span> 及 <span class="math inline">\(\Sigma\)</span> 为对称矩阵可知 <span class="math display">\[\frac{\partial L}{\partial \Sigma} = \frac{1}{2} \sum_{t = 1}^N \Sigma^{-1}(\textbf{x} - \boldsymbol{\mu})(\textbf{x} - \boldsymbol{\mu})^T \Sigma^{-1} - \frac{N}{2} \Sigma^{-1}\]</span> 故当 <span class="math inline">\(\Sigma = \frac{1}{N}(\textbf{x} - \boldsymbol{\mu})(\textbf{x} - \boldsymbol{\mu})^T\)</span> 时，<span class="math inline">\(\frac{\partial L}{\partial \Sigma} = 0\)</span></p><h2 id="六">六</h2><blockquote><p>求 <span class="math display">\[\frac{\partial |X_k|}{\partial X}\]</span> ，其中 <span class="math inline">\(X \in \mathbb{R}^{m \times m}\)</span> 为可逆矩阵。</p></blockquote><p>由 <span class="math inline">\(\textbf{X} \in \mathbb{R}^{m \times m}\)</span> 可逆可知 <span class="math display">\[\begin{aligned}\frac{\partial \left|\textbf{X}^k\right|}{\partial \textbf{X}} &amp;= \frac{\partial \left|\textbf{X}^k\right|}{\partial \textbf{|X|}} \cdot \frac{\partial \left|\textbf{X}\right|}{\partial \textbf{X}} \\&amp;=k |\textbf{X}|^{k - 1} \cdot |\textbf{X}| \cdot (\textbf{X}^{-1})^T \\&amp;= k |\textbf{X}|^k \left( \textbf{X}^{-1} \right)^T\end{aligned}\]</span></p><h2 id="七">七</h2><blockquote><p>求 <span class="math display">\[\frac{\partial \tr (AXBX^T C)}{\partial X}\]</span> ，其中 <span class="math inline">\(A \in \mathbb{R}^{m \times n}, X \in \mathbb{R}^{n \times k}, B \in \mathbb{R}^{k \times k}, C \in \mathbb{R}^{n \times m}\)</span></p></blockquote><p>由 <span class="math display">\[\begin{aligned}d \left( \textbf{A} \textbf{x} \textbf{B} \textbf{x}^T \textbf{C} \right) &amp;=Tr \left[d \left(\textbf{A} \textbf{x} \textbf{B} \textbf{x}^T \textbf{C} \right) \right] \\&amp;=Tr \left[\textbf{A} \cdot d \textbf{x} \cdot \textbf{B} \textbf{x}^T \textbf{C} + \textbf{A} \textbf{x} \textbf{B} \cdot d \textbf{x}^T \cdot \textbf{C} \right] \\&amp;=Tr \left[ \textbf{B}\textbf{x}^T \textbf{C}\textbf{A} d \textbf{x} \right] + Tr \left[ d \textbf{x}^T \cdot \textbf{C}\textbf{A}\textbf{x}\textbf{B} \right] \\&amp;=Tr \left[ \textbf{B}\textbf{x}^T \textbf{C}\textbf{A} d \textbf{x} \right] + Tr \left[ \textbf{B}^T\textbf{x}^T \textbf{A}^T \textbf{C}^T d \textbf{x} \right] \\&amp;=Tr \left[ \left( \textbf{B}\textbf{x}^T \textbf{C}\textbf{A} + \textbf{B}^T\textbf{x}^T \textbf{A}^T \textbf{C}^T \right) d \textbf{x}\right]\end{aligned}\]</span> 可知 <span class="math display">\[\frac{\partial Tr \left(\textbf{A} \textbf{x} \textbf{B} \textbf{x}^T \textbf{C} \right)}{\partial \textbf{X}} = \left( \textbf{B}\textbf{x}^T \textbf{C}\textbf{A} + \textbf{B}^T\textbf{x}^T \textbf{A}^T \textbf{C}^T \right)^T = \textbf{A}^T \textbf{C}^T \textbf{x} \textbf{B}^T + \textbf{C} \textbf{A} \textbf{x} \textbf{B}\]</span></p><h2 id="八">八</h2><blockquote><p>求激活函数 <span class="math display">\[\sigma(x) = \frac{1}{1 + e^{-x}}\]</span> 的导数</p></blockquote><p><span class="math display">\[\frac{d \sigma}{d \textbf{x}} = \frac{d}{d \textbf{x}} \left( \frac{1}{1+e^{- \textbf{x}}} \right) = \frac{e^{- \textbf{x}}}{\left(1+e^{-\textbf{x}}\right)^2} = \sigma(\textbf{x}) \left(1-\sigma(\textbf{x}) \right)\]</span></p><h2 id="九">九</h2><blockquote><p>求 <span class="math display">\[\frac{\partial}{\partial x} \exp \left\{ - \frac{1}{2 ||\sigma||_2^2} ||x - \mu||_2^2 \right\}\]</span> ，其中 <span class="math inline">\(x, \mu, \sigma \in \mathbb{R}^n\)</span></p></blockquote><p>由 <span class="math display">\[\begin{aligned}d\left( e^{-\frac{1}{2||\boldsymbol{\sigma}||^2}||\textbf{x} - \boldsymbol{\mu}||_2^2} \right) &amp;=Tr \left[ d \left( e^{-\frac{2}{2||\boldsymbol{\sigma}||^2}||\textbf{x} - \boldsymbol{\mu}||_2^2} \right)\right] \\&amp;=Tr \left[ -\frac{1}{2||\boldsymbol{\sigma}||^2} e^{-\frac{1}{2||\boldsymbol{\sigma}||^2}||\textbf{x} - \boldsymbol{\mu}||_2^2} \cdot d \left( ||\textbf{x} - \boldsymbol{\mu}||_2^2\right) \right] \\&amp;=Tr \left[ -\frac{1}{2||\boldsymbol{\sigma}||^2} e^{-\frac{1}{2||\boldsymbol{\sigma}||^2}||\textbf{x} - \boldsymbol{\mu}||_2^2} \cdot d \left( (\textbf{x} - \boldsymbol{\mu})^T (\textbf{x} - \boldsymbol{\mu}) \right) \right] \\&amp;=Tr \left[ -\frac{(\textbf{x} - \boldsymbol{\mu})^T}{||\boldsymbol{\sigma}||^2} e^{-\frac{1}{2||\boldsymbol{\sigma}||^2}||\textbf{x} - \boldsymbol{\mu}||_2^2} \cdot d\textbf{x} \right]\end{aligned}\]</span> 可知 <span class="math display">\[\frac{\partial}{\partial \textbf{x}} e^{-\frac{1}{2||\boldsymbol{\sigma}||^2}||\textbf{x} - \boldsymbol{\mu}||_2^2} = \left(-\frac{(\textbf{x} - \boldsymbol{\mu})^T}{||\boldsymbol{\sigma}||^2} e^{-\frac{1}{2||\boldsymbol{\sigma}||^2}||\textbf{x} - \boldsymbol{\mu}||_2^2}\right)^T = -\frac{(\textbf{x} - \boldsymbol{\mu})}{||\boldsymbol{\sigma}||^2} e^{-\frac{1}{2||\boldsymbol{\sigma}||^2}||\textbf{x} - \boldsymbol{\mu}||_2^2}\]</span></p><h2 id="十">十</h2><blockquote><p>阅读以下代码，填写更新梯度部分的代码。（提交时，需要提交补全的代码，以及最后10次输出的截图）</p></blockquote><p><strong>实现代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>N, D_in, H, D_out = <span class="hljs-number">64</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">100</span>, <span class="hljs-number">10</span><br><span class="hljs-comment"># 随机创建一些训练数据</span><br>x = np.random.randn(N, D_in)<br>y = np.random.randn(N, D_out)<br>w1 = np.random.randn(D_in, H)<br>w2 = np.random.randn(H, D_out)<br>learning_rate = <span class="hljs-number">1e-6</span><br><span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> range(<span class="hljs-number">500</span>):<br>    <span class="hljs-comment"># Forward pass</span><br>    h = x.dot(w1)  <span class="hljs-comment"># N * H</span><br>    h_relu = np.maximum(h, <span class="hljs-number">0</span>)  <span class="hljs-comment"># N * H</span><br>    y_pred = h_relu.dot(w2)  <span class="hljs-comment"># N * D_out</span><br>    <span class="hljs-comment"># compute loss</span><br>    loss = np.square(y_pred - y).sum()<br>    print(it, loss)<br>    <span class="hljs-comment"># Backward pass</span><br>    <span class="hljs-comment"># compute the gradient</span><br>    grad_y_pred = y_pred - y<br>    grad_w2 = h_relu.T.dot(grad_y_pred)<br>    grad_h_relu = grad_y_pred.dot(w2.T)<br>    grad_h = grad_h_relu.copy()<br>    grad_h[h &lt; <span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    grad_w1 = x.T.dot(grad_h)<br>    w1 -= learning_rate * grad_w1<br>    w2 -= learning_rate * grad_w2<br></code></pre></td></tr></table></figure><p><strong>输出结果（最后10次循环）：</strong></p><img src="/2021/06/02/dase-math/dase-math-assignment-4/1.png" class="" width="1">]]></content>
    
    
    <categories>
      
      <category>数据科学数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>DataScience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验 I/O子系统</title>
    <link href="/2021/06/01/os/os-exp-io/"/>
    <url>/2021/06/01/os/os-exp-io/</url>
    
    <content type="html"><![CDATA[<h2 id="this-page-is-temporarily-forbidden-for-the-course-regulation.">This page is temporarily forbidden for the course regulation.</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Operating-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验 进程调度EDF</title>
    <link href="/2021/04/27/os/os-exp-chrt/"/>
    <url>/2021/04/27/os/os-exp-chrt/</url>
    
    <content type="html"><![CDATA[<h2 id="this-page-is-temporarily-forbidden-for-the-course-regulation.">This page is temporarily forbidden for the course regulation.</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Operating-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散型随机变量整理</title>
    <link href="/2021/04/21/math-prob-stat/prob-drv/"/>
    <url>/2021/04/21/math-prob-stat/prob-drv/</url>
    
    <content type="html"><![CDATA[<h2 id="二项分布">二项分布</h2><h3 id="定义">定义</h3><blockquote><p><strong>Definition:</strong> 若一个离散型随机变量 <span class="math inline">\(X\)</span> 的分布列满足 <span class="math display">\[P(X=k) = \binom{n}{k} p^k (1-p)^{1-k}\]</span> 其中 <span class="math inline">\(n \in \mathbb{N}^+, k \in \{0,1,2,...,n\}, p \in [0,1]\)</span>，则称随机变量 <span class="math inline">\(X\)</span> 满足二项分布，记为 <span class="math inline">\(X \sim B(n, p)\)</span></p></blockquote><a id="more"></a><p><strong>适用场景：</strong>在 <span class="math inline">\(n\)</span> 次伯努利试验中，若每次成功的概率均为 <span class="math inline">\(p\)</span>，求成功 <span class="math inline">\(k\)</span> 次的概率</p><p>二项分布的<strong>累积分布函数</strong>为 <span class="math display">\[F(k) = P(X \leq k)=\left\{\begin{aligned}\sum_\limits{i=0}^{\lfloor k \rfloor} \binom{n}{k}p^k(1-p)^{1-k}&amp;,&amp;k \geq 0  \\0&amp;,&amp; k &lt; 0\end{aligned}\right.\]</span> 若引入<strong>不完全Beta函数</strong>，则其累积分布函数的非负部分还可表示为 <span class="math display">\[\begin{aligned}F(k) &amp;= I_{1-p} (n-k, k+1) \\&amp;= \frac{\textrm{B} (1-p;n-k,k+1)}{\textrm{B} (n-k,k+1)} \\&amp;=\frac{\int_0^{1-p} t^{n-k-1}(1-t)^k dt}{\int_0^1 t^{n-k-1}(1-t)^k dt} \ , k \geq 0\end{aligned}\]</span></p><h3 id="期望和方差">期望和方差</h3><p>由于每一次伯努利试验均为独立的，因此我们可以将 <span class="math inline">\(n\)</span> 次试验分解为 <span class="math inline">\(n\)</span> 个单次试验，即若定义 <span class="math display">\[Y_i = \left\{\begin{aligned}1,&amp; Succeed \ \ in \ \ i^{th} \ \ exp \\0,&amp; Fail \ \ in \ \ i^{th} \ \ exp\end{aligned}\right.\]</span> 则 <span class="math inline">\(X=\sum\limits_{i = 1}^n Y_i\)</span> （此时 <span class="math inline">\(Y_i\)</span> 服从的分布即 <span class="math inline">\(B(1,p)\)</span> 也被称为<strong>二点分布</strong>或<strong>0-1分布</strong>）</p><p>于是我们可以快速求出二项分布的期望 <span class="math display">\[\begin{aligned}E(X) &amp;= E \left( \sum_{i = 1}^n Y_i \right) \\&amp;= \sum_{i = 1}^n E(Y_i) \\&amp;= \sum_{i = 1}^n p \\&amp;=np\end{aligned}\]</span></p><p>同理，由 <span class="math display">\[Var(Y_i) = (1-p)^2 p + (0-p)^2(1-p)=p(1-p)\]</span> 可知二项分布的方差为 <span class="math display">\[\begin{aligned}Var(X) &amp;= Var(\sum_\limits{i=1}^n Y_i) \\&amp;= \sum_\limits{i=1}^n Var(Y_i) \\&amp;= \sum_\limits{i=1}^n p(1-p) \\&amp;= np(1-p)\end{aligned}\]</span></p><blockquote><p><strong>另解（纯分析法求二项分布期望及方差）：</strong> <span class="math display">\[\begin{aligned}E(X) &amp;= \sum_\limits{k = 0}^n k \binom{n}{k} p^k (1-p)^{n-k} \\&amp;= \sum_\limits{k = 1}^n k \binom{n}{k} p^k (1-p)^{n-k} \\\end{aligned}\]</span> 由于 <span class="math display">\[\begin{aligned}k\binom{n}{k} &amp;= k \cdot \frac{n!}{k!(n-k)!} \\&amp;=\frac{n!}{(k-1)!(n-k)!} \\&amp;=n \cdot \frac{(n-1)!}{(k-1)!(n-k)!} \\&amp;=n \binom{n-1}{k-1}\end{aligned}\]</span> 因此 <span class="math display">\[\begin{aligned}E(X) &amp;= \sum_\limits{k = 1}^n n \binom{n-1}{k-1} p^k (1-p)^{n-k} \\&amp;=np \sum_\limits{k = 1}^n \binom{n-1}{k-1} p^{k-1} (1-p)^{n-k} \\&amp;=np \sum_\limits{m = 0}^{n-1} \binom{n-1}{m} p^m (1-p)^{n-1-m} \\&amp;=np \cdot (p+1-p)^{n-1} \\&amp;=np\end{aligned}\]</span> 又由 <span class="math display">\[\begin{aligned}E(X^2) &amp;= \sum_\limits{k = 0}^n k^2 \binom{n}{k} p^k (1-p)^{n-k} \\&amp;= n \cdot \sum_\limits{k = 1}^n k \binom{n-1}{k-1} p^k (1-p)^{n-k} \\&amp;= n \cdot \sum_\limits{k = 1}^n (k - 1 + 1) \binom{n-1}{k-1} p^k (1-p)^{n-k} \\&amp;= n \cdot \left[ \sum_\limits{k = 1}^n (k - 1) \binom{n-1}{k-1} p^k (1-p)^{n-k} + \sum_\limits{k = 1}^n  \binom{n-1}{k-1} p^k (1-p)^{n-k} \right] \\&amp;=n \cdot \sum_\limits{k = 2}^n (n - 1) \binom{n-2}{k-2} p^k (1-p)^{n-k} + n \cdot \sum_\limits{k = 1}^n  \binom{n-1}{k-1} p^k (1-p)^{n-k} \\&amp;= n(n-1)p^2 + np\end{aligned}\]</span> 可知 <span class="math display">\[\begin{aligned}Var(X) &amp;= E(X^2) - E^2(X) \\&amp;=n(n-1)p^2 + np - n^2p^2 \\&amp;=n^2p^2-np^2+ np - n^2p^2 \\&amp;=np(1-p)\end{aligned}\]</span></p></blockquote><h2 id="泊松分布">泊松分布</h2><h3 id="定义-1">定义</h3><blockquote><p><strong>Definition:</strong> 若一个离散型随机变量 <span class="math display">\[X\]</span> 的分布列满足 <span class="math display">\[P(X=k) = \frac{\lambda^k}{k!} e^{-\lambda}\]</span> 其中 <span class="math display">\[k \in \{0,1,2,3,...\}, \lambda&gt;0\]</span>，则称随机变量 <span class="math display">\[X\]</span> 满足泊松分布，记为 <span class="math display">\[X \sim P(\lambda)\]</span></p></blockquote><p><strong>适用场景：</strong>求一段固定长度的时间中事件发生了 <span class="math display">\[k\]</span> 次的概率</p><p>泊松分布的<strong>累积分布函数</strong>为 <span class="math display">\[F(k) = P(X \leq k) = \left\{\begin{aligned}\sum_{i = 0}^{\lfloor k \rfloor} \frac{\lambda^i}{i!}e^{-\lambda}&amp;,&amp; k \geq 0 \\0&amp;,&amp; k &lt; 0\end{aligned}\right.\]</span> 若引入<strong>不完全伽马函数</strong>，则其累积分布函数的非负部分还可表示为 <span class="math display">\[\begin{aligned}F(k) &amp;= \frac{\Gamma(\lfloor k + 1\rfloor, \lambda)}{\Gamma(\lfloor k +1 \rfloor)} \\&amp;=Q(\lfloor k + 1\rfloor, \lambda)\end{aligned}\]</span></p><h3 id="期望和方差-1">期望和方差</h3><p>利用 <span class="math display">\[e^x = \sum_\limits{k = 0}^\infty \frac{x^k}{k!}\]</span> 可快速求出泊松分布的期望 <span class="math display">\[\begin{aligned}E(X) &amp;= \sum_{k = 0}^\infty k \cdot \frac{\lambda^k}{k!} e^{-\lambda} \\&amp;=e^{-\lambda} \cdot \sum_{k = 1}^\infty k \cdot \frac{\lambda^k}{k!} \\&amp;=\lambda e^{-\lambda} \cdot \sum_{k = 1}^\infty \frac{\lambda^{k-1}}{(k-1)!} \\&amp;=\lambda e^{-\lambda} e^\lambda \\&amp;=\lambda\end{aligned}\]</span> 又由 <span class="math display">\[\begin{aligned}E(X^2) &amp;= \sum_{k = 0}^\infty k^2 \cdot \frac{\lambda^k}{k!} e^{-\lambda} \\&amp;=e^{-\lambda} \sum_{k = 1}^\infty k^2 \cdot \frac{\lambda^k}{k!} \\&amp;=\lambda e^{-\lambda} \sum_{k = 1}^\infty k \cdot \frac{\lambda^{k-1}}{(k-1)!} \\&amp;=\lambda e^{-\lambda} \sum_{k = 1}^\infty (k-1+1) \cdot \frac{\lambda^{k-1}}{(k-1)!} \\&amp;=\lambda e^{-\lambda} \left( \sum_{k = 2}^\infty (k-1) \cdot \frac{\lambda^{k-1}}{(k-1)!} + \sum_{k = 1}^\infty \frac{\lambda^{k-1}}{(k-1)!} \right) \\&amp;=\lambda e^{-\lambda} \left( \lambda \sum_{k = 2}^\infty \frac{\lambda^{k-2}}{(k-2)!} + \sum_{k = 1}^\infty \frac{\lambda^{k-1}}{(k-1)!} \right) \\&amp;=\lambda e^{-\lambda} \left( \lambda e^\lambda + e^\lambda \right) \\&amp;=\lambda^2 + \lambda\end{aligned}\]</span> 可知其方差为 <span class="math display">\[\begin{aligned}Var(X) &amp;= E(X^2) - E^2(X) \\&amp;= \lambda^2 + \lambda - \lambda^2 \\&amp;=\lambda\end{aligned}\]</span></p><h3 id="泊松分布与二项分布">泊松分布与二项分布</h3><p>泊松分布与二项分布有如下定理成立：</p><blockquote><p><strong>Theorem(Poisson):</strong> 设 <span class="math display">\[k \leq n \in N, \lambda &gt; 0\]</span>，<span class="math display">\[\{p_n\}\]</span> 是一个与 <span class="math display">\[n\]</span> 有关的序列且 <span class="math display">\[0 \leq p_n \leq 1\]</span>，<span class="math display">\[np_n \to \lambda (n \to \infty)\]</span>，则 <span class="math display">\[\lim_{n \to \infty} \binom{n}{k} p_n^k(1-p_n)^{n-k} = \frac{\lambda^k}{k!} e^{-\lambda}\]</span> <strong>Proof:</strong> 令 <span class="math display">\[np_n = \lambda_n\]</span></p><p>故由 <span class="math display">\[np_n \to \lambda(n \to \infty)\]</span> 可知 <span class="math display">\[\lambda_n \to \lambda(n \to \infty)\]</span></p><p>故 <span class="math display">\[\begin{aligned}\binom{n}{k} p_n^k(1-p_n)^{n-k} &amp;= \binom{n}{k} (\frac{\lambda_n}{n})^k \left( 1-\frac{\lambda_n}{n} \right)^{n-k} \\&amp;= \frac{n(n-1) \cdots (n-k-1)}{k!} \cdot \frac{\lambda_n^k}{n^k} \cdot \left( 1-\frac{\lambda_n}{n} \right)^{n-k} \\&amp;=\frac{\lambda_n^k}{k!} \cdot \frac{n-1}{n} \cdot \frac{n-2}{n} \cdots \frac{n-k-1}{n} \cdot \left( 1-\frac{\lambda_n}{n} \right)^{n-k}\end{aligned}\]</span> 又 <span class="math display">\[\lim_{n \to \infty} \frac{n-1}{n} \cdot \frac{n-2}{n} \cdots \frac{n-k-1}{n} = 1^k = 1 \\\lim_{n \to \infty} \left( 1-\frac{\lambda_n}{n} \right)^{n-k} = e^{-\lambda}\]</span> 因此 <span class="math display">\[\begin{aligned}\lim_{n \to \infty} \binom{n}{k} p_n^k(1-p_n)^{n-k} &amp;= \lim_{n \to \infty} \frac{\lambda_n^k}{k!} \cdot \frac{n-1}{n} \cdot \frac{n-2}{n} \cdots \frac{n-k-1}{n} \cdot \left( 1-\frac{\lambda_n}{n} \right)^{n-k} \\&amp;=\frac{\lambda^k}{k!} e^{-\lambda}\end{aligned}\]</span></p></blockquote><p>由上面的定理可以看出，泊松分布可以看作是一个二项分布当 <span class="math display">\[n\]</span> 趋于无穷时的极限情况（此时泊松分布中的参数 <span class="math display">\[\lambda\]</span> 即为二项分布的期望 <span class="math display">\[np\]</span>），因此对于一个二项分布 <span class="math display">\[B(n,p)\]</span> 来说，当 <strong><span class="math display">\[n\]</span> 充分大且 <span class="math display">\[p\]</span> 充分小</strong>时，其对应点的值可使用泊松分布的值来近似。即若随机变量 <span class="math display">\[X \sim B(n,p)\]</span>，则 <span class="math display">\[P(X=k) \approx \frac{n^kp^k}{k!} e^{-np}\]</span> 一般来说，当 <span class="math display">\[n \geq 20, p \leq 0.05\]</span> 时，泊松分布就可作为二项分布的一个可用的近似；当 <span class="math display">\[n \geq 100, np \leq 10\]</span> 时，泊松分布就是二项分布的一个较为精准的近似了。</p><h2 id="几何分布">几何分布</h2><h3 id="定义-2">定义</h3><blockquote><p><strong>Definition:</strong> 若一个离散型随机变量 <span class="math display">\[X\]</span> 的分布列满足 <span class="math display">\[P(X=k) = (1-p)^{k-1} p\]</span> 其中 <span class="math display">\[k \in \{1,2,3,...\}, p \in [0,1]\]</span>，则称随机变量 <span class="math display">\[X\]</span> 满足几何分布，记为 <span class="math display">\[X \sim Ge(p)\]</span></p></blockquote><p><strong>适用场景：</strong>在一组伯努利实验中，若每次成功的概率为 <span class="math display">\[p\]</span>，求当进行到第 <span class="math display">\[k\]</span> 次试验时才第一次成功的概率</p><p>几何分布的<strong>累积分布函数</strong>为 <span class="math display">\[\begin{aligned}F(k) &amp;= P(X \leq k) \\&amp;= \sum_{i =1}^{\lfloor k \rfloor} (1-p)^{i-1}p \\&amp;=p \cdot \frac{1-(1-p)^{\lfloor k \rfloor}}{p} \\&amp;=1-(1-p)^{\lfloor k \rfloor}, k \geq 1\end{aligned}\]</span></p><h3 id="无记忆性">无记忆性</h3><p>几何分布有如下的性质成立：</p><blockquote><p><strong>Theorem:</strong> 若 <span class="math display">\[X \sim Ge(p)\]</span>，则对任意 <span class="math display">\[m,n \geq 1\]</span>，有 <span class="math display">\[P(X &gt; m+n | X &gt; m) = P(X &gt; n)\]</span> <strong>Proof:</strong> 由于 <span class="math display">\[\begin{aligned}P(X &gt; m) &amp;= \sum_{k = m+1}^\infty (1-p)^{k-1} p \\&amp;= p \cdot \frac{(1-p)^m}{p} \\&amp;=(1-p)^m\end{aligned}\]</span> 故 <span class="math display">\[\begin{aligned}P(X &gt; m+n | X &gt; m) &amp;= \frac{P(X&gt;m+n,X&gt;m)}{P(X&gt;m)} \\&amp;=\frac{P(X&gt;(m+n))}{P(X&gt;m)} \\&amp;=\frac{(1-p)^{m+n}}{(1-p)^m} \\&amp;=(1-p)^{n} \\&amp;=P(X&gt;n)\end{aligned}\]</span></p></blockquote><p>该定理表明，在一串伯努利试验中若前 <span class="math display">\[m\]</span> 次试验均不成功，则后续试验每一次成功的概率与重新从第一次开始计数试验成功的概率相同，即前 <span class="math display">\[m\]</span> 次试验并不对接下来的结果造成任何影响。</p><p>事实上，几何分布是离散型分布中<strong>唯一</strong>具有无记忆性的分布：</p><blockquote><p><strong>Theorem:</strong> 设 <span class="math display">\[X\]</span> 为一个离散随机变量，其取值范围为 <span class="math display">\[\{1,2,3,...\}\]</span>，若对任意 <span class="math display">\[m,n \geq 1 \in \mathbb{N}\]</span>，有 <span class="math display">\[P(X&gt;m+n | X&gt;m) = P(X&gt;n)\]</span>，则存在 <span class="math display">\[0 \leq p \leq 1\]</span>，使得 <span class="math display">\[X \sim Ge(p)\]</span></p><p><strong>Proof:</strong> 令 <span class="math display">\[F(x) = P(X&gt;x)\]</span></p><p>则原条件可写为对任意 <span class="math display">\[m,n \geq 1 \in \mathbb{N}\]</span>，有 <span class="math display">\[\frac{F(m+n)}{F(m)} = F(n)\]</span> 即 <span class="math display">\[F(m+n) = F(m)F(n)\]</span></p><p>令 <span class="math display">\[m = n = 1\]</span>，则 <span class="math display">\[F(2) = F^2(1)\]</span></p><p>再令 <span class="math display">\[m=2, n =1\]</span>，则 <span class="math display">\[F(3) = F^3(1)\]</span></p><p>如此递推，可得 <span class="math display">\[F(m) = F^m(1)\]</span></p><p>令 <span class="math display">\[P(X=1) = p\]</span></p><p>则 <span class="math display">\[\begin{aligned}F(1) &amp;= P(X&gt;1) \\&amp;=1-P(X=1) \\&amp;=1-p\end{aligned}\]</span> 由此可知对任意 <span class="math display">\[m \geq 1 \in \mathbb{N}\]</span>，有 <span class="math display">\[\begin{aligned}P(X=m) &amp;= P(X&gt;m-1) - P(X&gt;m) \\&amp;=F(m-1) - F(m) \\&amp;=F^{m-1}(1) - F^m(1) \\&amp;=(1-p)^{m-1} - (1-p)^m \\&amp;=(1-p)^{m-1}p\end{aligned}\]</span> 即 <span class="math display">\[X \sim Ge(p)\]</span></p></blockquote><h3 id="期望和方差-2">期望和方差</h3><p>利用几何分布的无记忆性，我们可以快速求出几何分布的期望和方差。</p><p>易见 <span class="math display">\[E(X|X=1) = 1\]</span></p><p>而 <span class="math display">\[\begin{aligned}E(X|X&gt;1) &amp;= \sum_{k = 2}^\infty k \cdot P(X=k|X&gt;1) \\&amp;= \sum_{k = 2}^\infty k \cdot P(X=k-1) \\&amp;= \sum_{k = 2}^\infty (k-1) \cdot P(X=k-1) + \sum_{k = 2}^\infty P(X=k-1) \\&amp;=E(X) + 1\end{aligned}\]</span> 故由<strong>全期望公式</strong>可知 <span class="math display">\[\begin{aligned}E(X) &amp;= P(X=1)E(X|X=1) + P(X&gt;1)E(X|X&gt;1) \\&amp;=p + (1-p) (E(X) + 1) \\&amp;=(1-p) \cdot E(X) + 1\end{aligned}\]</span> 即几何分布的期望 <span class="math display">\[E(X) = \frac{1}{p}\]</span></p><p>同理，<span class="math display">\[E(X^2|X = 1) = 1\]</span> <span class="math display">\[\begin{aligned}E(X^2|X&gt;1) &amp;= \sum_{k = 2}^\infty k^2 \cdot P(X=k|X&gt;1) \\&amp;= \sum_{k = 2}^\infty k^2 \cdot P(X=k-1) \\&amp;= \sum_{k = 2}^\infty (k-1)^2 \cdot P(X=k-1) + 2 \cdot \sum_{k = 2}^\infty (k-1) \cdot P(X=k-1) + \sum_{k = 2}^\infty P(X=k-1) \\&amp;=E(X^2) + 2E(X) + 1\end{aligned}\]</span> 故 <span class="math display">\[\begin{aligned}E(X^2) &amp;= P(X = 1)E(X^2|X=1) + P(X&gt;1)E(X^2|X&gt;1) \\&amp;= p + (1-p)(E(X^2) + 2E(X) + 1) \\&amp;= (1-p)E(X^2) + 2(1-p)E(X) + 1 \\&amp;=(1-p)E(X^2) + \frac{2}{p} - 1\end{aligned}\]</span> 于是 <span class="math display">\[E(X^2) = \frac{2-p}{p^2}\]</span></p><p>因此几何分布的方差 <span class="math display">\[\begin{aligned}Var(X) &amp;= E(X^2) - E^2(X) \\&amp;=\frac{2-p}{p^2} - \frac{1}{p^2} \\&amp;=\frac{1-p}{p^2}\end{aligned}\]</span></p><blockquote><p><strong>另解（纯分析法求几何分布期望和方差）：</strong></p><p>首先我们对其表达式进行化简： <span class="math display">\[\begin{aligned}E(X) &amp;= \sum_{k = 1}^\infty k(1-p)^{k-1} p \\&amp;=p \cdot \sum_{k = 1}^\infty k(1-p)^{k-1} \\&amp;=p \cdot \sum_{k = 1}^\infty \left( -\frac{d}{dp} (1-p)^k \right)\end{aligned}\]</span> 由于几何级数<strong>一致收敛</strong>于其极限值，故 <span class="math display">\[\sum_{k = 1}^\infty \frac{d}{dp} \left( (1-p)^k \right)  = \frac{d}{dp} \sum_{k = 1}^\infty \left( (1-p)^k \right)\]</span> 因此几何分布的期望为 <span class="math display">\[\begin{aligned}E(X) &amp;=-p \cdot \frac{d}{dp} \left( \sum_{k = 1}^\infty (1-p)^k \right) \\&amp;= -p \cdot \left( - \frac{1}{p^2}\right) \\&amp;=\frac{1}{p}\end{aligned}\]</span> 同理可知 <span class="math display">\[\begin{aligned}E(X^2) &amp;= \sum_{k = 1}^\infty k^2 (1-p)^{k-1} p \\&amp;=p \sum_{k = 1}^\infty k(k+1-1) (1-p)^{k-1} \\&amp;=p \left( \sum_{k = 1}^\infty \left(\frac{d^2}{dp^2} \left( (1-p)^{k+1} \right) \right) - \sum_{k = 1}^\infty \left( \frac{d}{dp} \left( (1-p)^k \right) \right) \right) \\&amp;=p \left( \frac{d^2}{dp^2} \left( \sum_{k = 1}^\infty \left( (1-p)^{k+1} \right) \right) - \frac{d}{dp} \left( \sum_{k = 1}^\infty \left( (1-p)^k \right) \right) \right) \\&amp;=p \left(\frac{d^2}{dp^2} \left( \frac{1}{p}-2+p \right) - \frac{d}{dp} \left( \frac{1}{p} - 1 \right) \right) \\&amp;=\frac{2}{p^2} - \frac{1}{p}\end{aligned}\]</span> 因此其方差为 <span class="math display">\[\begin{aligned}Var(X) &amp;= E(X^2) - E^2(X) \\&amp;=\frac{2}{p^2} - \frac{1}{p} - \frac{1}{p^2} \\&amp;=\frac{1-p}{p^2}\end{aligned}\]</span></p></blockquote><h2 id="负二项分布">负二项分布</h2><h3 id="定义-3">定义</h3><blockquote><p><strong>Definition:</strong> 若一个离散型随机变量 <span class="math display">\[X\]</span> 的分布列满足 <span class="math display">\[P(X=k) = \binom{k-1}{r-1} p^r (1-p)^{k-r}\]</span> 其中 <span class="math display">\[r \leq k \in \{1,2,3,...\}, p \in [0,1]\]</span>，则称随机变量 <span class="math display">\[X\]</span> 满足负二项分布，记为 <span class="math display">\[X \sim Nb(r, p)\]</span></p></blockquote><p><strong>适用场景：</strong>在一组伯努利实验中，若每次成功的概率为 <span class="math display">\[p\]</span>，求第 <span class="math display">\[r\]</span> 次成功时总共进行的试验次数 <span class="math display">\[k\]</span></p><p>负二项分布的累积分布函数 <span class="math display">\[F(k) = P(X \leq k) = \left\{\begin{aligned}\sum_{i = 1}^k \binom{i-1}{r-1} p^r (1-p)^{i-r}&amp;,&amp; k \geq r \\0&amp;,&amp; k &lt; r\end{aligned}\right.\]</span> 若引入<strong>不完全Beta函数</strong>，则其累积分布函数的非负部分还可表示为 <span class="math display">\[\begin{aligned}F(k) &amp;= I_{1-p}(r, k-r+1) \\&amp;=\frac{B(1-p;r,k-r+1)}{B(r,k-r+1)}\end{aligned}\]</span></p><h3 id="负二项分布与几何分布">负二项分布与几何分布</h3><p>从直观上来看，几何分布描述的是一组伯努利实验中<strong>第一次</strong>成功的实验次数，而负二项分布描述的是一组伯努利实验中<strong>第 <span class="math display">\[r\]</span> 次</strong>成功的实验次数，自然的，几何分布可以被负二项分布所包含。事实上，对于一个负二项分布，当 <span class="math display">\[r = 1\]</span> 时，其分布列退化为 <span class="math display">\[P(X=k)=(1-p)^{k - 1}p\]</span> 此即为几何分布的分布列。由此可知 <span class="math display">\[Ge(p) = Nb(1,p)\]</span></p><h3 id="期望和方差-3">期望和方差</h3><p>与二项分布类似，我们可将负二项分布拆分成一系列相互独立的事件以简化期望和方差的计算。注意到负二项分布与几何分布的关系，我们可将一个负二项分布中的实验拆分为 <span class="math display">\[r\]</span> 个独立成功的实验，而每次实验服从一个几何分布。</p><p>令 <span class="math display">\[X_i\]</span> 为第 <span class="math display">\[i\]</span> 次实验成功所用次数的随机变量 <span class="math display">\[(1 \leq i \leq r)\]</span>，<span class="math display">\[X\]</span> 为前 <span class="math display">\[r\]</span> 次实验成功所用次数的随机变量</p><p>此时 <span class="math display">\[1 \leq \forall i \neq j \leq r\]</span>，<span class="math display">\[X_i\]</span> 与 <span class="math display">\[X_j\]</span> 独立，且 <span class="math display">\[X_i \sim Ge(p), X \sim Nb(r, p), X = \sum_\limits{i = 1}^r X_i\]</span></p><p>于是由几何分布的期望可知 <span class="math display">\[\begin{aligned}E(X) &amp;= E(\sum_{i = 1}^r X_i) \\&amp;=\sum_{i = 1}^r E(X_i) \\&amp;=\sum_{i = 1}^r \frac{1}{p} \\&amp;=\frac{r}{p}\end{aligned}\]</span></p><p>同理 <span class="math display">\[\begin{aligned}Var(X) &amp;= Var(\sum_{i = 1}^r X_i) \\&amp;=\sum_{i = 1}^r Var(X_i) \\&amp;=\sum_{i = 1}^r \frac{1-p}{p^2} \\&amp;=\frac{r(1-p)}{p^2}\end{aligned}\]</span></p><blockquote><p><strong>另解（纯分析法求负二项分布的期望和方差）：</strong> <span class="math display">\[\begin{aligned}E(X) &amp;= \sum_{k = r}^{\infty} k \binom{k-1}{r-1} p^r (1-p)^{k-r} \\&amp;= \sum_{k = r}^{\infty} \frac{k!}{(r-1)!(k-r)!} p^r(1-p)^{k-r} \\&amp;=\frac{r}{p} \sum_{k = r}^{\infty} \frac{k!}{r!(k-r)!} p^{r+1}(1-p)^{k-r} \\&amp;=\frac{r}{p} \sum_{k = r}^{\infty} \binom{k}{r} p^{r+1}(1-p)^{k-r} \\&amp;=\frac{r}{p}\end{aligned}\]</span> 又 <span class="math display">\[\begin{aligned}E(X^2) &amp;= \sum_{k = r}^{\infty} k^2 \binom{k-1}{r-1} p^r (1-p)^{k-r} \\&amp;= \sum_{k = r}^{\infty} (k+1-1) \cdot \frac{k!}{(r-1)!(k-r)!} p^r(1-p)^{k-r} \\&amp;= \sum_{k = r}^{\infty} \frac{(k+1)!}{(r-1)!(k-r)!} p^r(1-p)^{k-r} - \sum_{k = r}^{\infty} \frac{k!}{(r-1)!(k-r)!} p^r(1-p)^{k-r} \\&amp;= \frac{r(r+1)}{p^2} \sum_{k = r}^{\infty} \frac{(k+1)!}{(r+1)!(k-r)!} p^{r+2} (1-p)^{k-r} - \frac{r}{p} \sum_{k = r}^{\infty} \frac{k!}{r!(k-r)!} p^{r+1}(1-p)^{k-r} \\&amp;= \frac{r(r+1)}{p^2} \sum_{k = r}^{\infty} \binom{k+1}{r+1} p^{r+2} (1-p)^{k-r} - \frac{r}{p} \sum_{k = r}^{\infty} \binom{k}{r} p^{r+1}(1-p)^{k-r} \\&amp;=\frac{r^2+r}{p^2} - \frac{r}{p} \\\end{aligned}\]</span> 故 <span class="math display">\[\begin{aligned}Var(X) &amp;= E(X^2) - E^2(X) \\&amp;= \frac{r^2+r}{p^2} - \frac{r}{p} - \frac{r^2}{p^2} \\&amp;=\frac{r(1-p)}{p^2}\end{aligned}\]</span></p></blockquote><h3 id="广义负二项分布与泊松分布">广义负二项分布与泊松分布</h3><p>在负二项分布中，参数 <span class="math display">\[r\]</span> 的取值范围要求为正整数，而在某些情况下，我们需要将负二项分布中的 <span class="math display">\[r\]</span> 的取值范围拓展到一切正实数。为了做到这一点，我们需要借助<strong>Gamma函数</strong>对其中的组合式进行拓展。</p><p>由于有 <span class="math display">\[\Gamma(n) = (n-1)!\]</span>，故 <span class="math display">\[\binom{k-1}{r-1} = \frac{(k-1)!}{(r-1)!(k-r)!} = \frac{(k-1)!}{\Gamma(r)\Gamma(k-r+1)}\]</span> 因此我们可以将广义负二项分布的分布列定义为： <span class="math display">\[P(X=k)=\frac{(k-1)!}{\Gamma(r)\Gamma(k-r+1)}p^r(1-p)^{k-r}, k \in \{1,2,...\},r \in \mathbb{R}\]</span> 事实上，在实际使用中，一个更常用的负二项分布的分布列定义为 <span class="math display">\[P(X=k) = \binom{k+r-1}{r-1}p^r(1-p)^k, k \in \{0,1,2,...\}\]</span> 这里的 <span class="math display">\[k\]</span> 代表第 <span class="math display">\[r\]</span> 次实验成功前实验失败的次数。</p><p>基于该定义进行拓展，我们就能得到广义负二项分布的标准定义：（该分布也被称为<strong>Polya分布</strong>）</p><blockquote><p><strong>Definition:</strong> 若一个离散型随机变量 <span class="math display">\[X\]</span> 的分布列满足 <span class="math display">\[P(X=k) = \frac{\Gamma(k+r)}{k!\Gamma(r)}p^r (1-p)^k\]</span> 其中 <span class="math display">\[k \in \{0,1,2,...\}, r \in \mathbb{R}, p \in [0,1]\]</span>，则称随机变量 <span class="math display">\[X\]</span> 服从广义负二项分布</p></blockquote><p>广义负二项分布与泊松分布有如下定理成立：</p><blockquote><p><strong>Theorem:</strong> 设 <span class="math display">\[k \in \mathbb{N}, \lambda &gt; 0, r \in \mathbb{R}\]</span>，则有 <span class="math display">\[\lim_{r \to \infty} \frac{\Gamma(k+r)}{k!\Gamma(r)} \left( \frac{\lambda}{r+\lambda} \right)^r \left(\frac{r}{r+\lambda} \right)^{k} = \frac{\lambda^k}{k!} e^{-\lambda}\]</span> <strong>Proof:</strong> //待补全</p></blockquote><p>由上述定理可知，当 <span class="math display">\[r\]</span> 很大时，广义负二项分布可以作为泊松分布的一个很好的近似。</p><h3 id="ab-分布类"><span class="math display">\[(a,b)\]</span> 分布类</h3><p>事实上，<strong>二项分布、负二项分布、泊松分布</strong>的概率密度函数均满足以下的递推关系： <span class="math display">\[p_n = p_{n-1} \left(a + \frac{b}{n} \right), n \geq 1\]</span> 其中，<span class="math display">\[a,b \in \mathbb{R}\]</span> 为常数（该递推式被称为<strong>Panjer递推式</strong>）</p><p>我们称概率密度函数满足上述递推关系的离散分布为 <strong><span class="math display">\[(a,b)\]</span> 分布</strong>，所有<span class="math display">\[(a,b)\]</span> 分布构成的集合被称为 <strong><span class="math display">\[(a,b)\]</span> 分布类</strong> 。</p><p><span class="math display">\[(a,b)\]</span> 分布类在精算领域的损失模型中有着十分重要的应用。</p><p>事实上，二项分布、负二项分布、泊松分布是 <strong><span class="math display">\[(a,b)\]</span> 分布类</strong>中的所有分布，这是因为有如下定理：</p><blockquote><p><strong>Theorem:</strong> 若一个 <span class="math display">\[(a,b)\]</span> 分布为非退化分布，则其必为二项分布、负二项分布、泊松分布中的一种</p><p><strong>Proof:</strong> //待补全</p></blockquote><h2 id="超几何分布">超几何分布</h2><h3 id="定义-4">定义</h3><blockquote><p><strong>Definition:</strong> 若一个离散型随机变量 <span class="math display">\[X\]</span> 的分布列满足 <span class="math display">\[P(X=k) = \frac{\binom{N_1}{k} \binom{N-N_1}{n-k}}{\binom{N}{n}}\]</span> 其中 <span class="math display">\[k \leq n,N_1 \leq N \in \{0,1,2,...\}\]</span>，则称随机变量 <span class="math display">\[X\]</span> 满足超几何分布，记为 <span class="math display">\[X \sim H(N, N_1, n)\]</span></p></blockquote><p><strong>适用场景：</strong>在一个袋子中有两种共 <span class="math display">\[N\]</span> 个物品，其中物品 <span class="math display">\[A\]</span> 有 <span class="math display">\[N_1\]</span> 个，物品 <span class="math display">\[B\]</span> 有 <span class="math display">\[N-N_1\]</span> 个，现从袋子中抽出 <span class="math display">\[n\]</span> 个物品，求抽出的物品中 <span class="math display">\[A\]</span> 的个数 <span class="math display">\[k\]</span></p><p>超几何分布的<strong>累积分布函数</strong>为 <span class="math display">\[F(k) = P(X=k) = \left\{\begin{aligned}\sum_{i = 0}^k \frac{\binom{N_1}{i} \binom{N-N_1}{n-i}}{\binom{N}{n}}&amp;,&amp; k \geq 0 \\0&amp;,&amp; k &lt; 0\end{aligned}\right.\]</span> 若引入<strong>广义超几何函数</strong>，则其非负部分还可表示为 <span class="math display">\[F(k) = 1 - \frac{\binom{n}{k+1}\binom{N-n}{N_1-k-1}}{\binom{N}{N_1}} \cdot _3F_2 \left(\begin{aligned}1, k+1-N_1, k+1-n \\k+2, N+k+2-N_1-n\end{aligned};1\right), k \geq 0\]</span></p><h3 id="期望和方差-4">期望和方差</h3><p>我们可以用与负二项分布类似的分析技巧导出超几何分布的期望和方差 <span class="math display">\[\begin{aligned}E(X) &amp;= \sum_{k = 0}^{N_1} k \cdot \frac{\binom{N_1}{k} \binom{N-N_1}{n-k}}{\binom{N}{n}} \\&amp;= \frac{n}{N} \sum_{k = 1}^{N_1} \frac{k \binom{N_1}{k} \binom{N-N_1}{n-k}}{\binom{N-1}{n-1}} \\&amp;= \frac{n \cdot N_1}{N} \sum_{k = 1}^{N_1} \frac{\binom{N_1 - 1}{k - 1} \binom{N-N_1}{n-k}}{\binom{N-1}{n-1}} \\&amp;=\frac{n \cdot N_1}{N}\end{aligned}\]</span></p><p>又 <span class="math display">\[\begin{aligned}E(X^2) &amp;= \sum_{k = 0}^{N_1} k^2 \cdot \frac{\binom{N_1}{k} \binom{N-N_1}{n-k}}{\binom{N}{n}} \\&amp;= \sum_{k = 1}^{N_1} k(k-1) \cdot \frac{\binom{N_1}{k} \binom{N-N_1}{n-k}}{\binom{N}{n}} + \sum_{k = 1}^{N_1} k \cdot \frac{\binom{N_1}{k} \binom{N-N_1}{n-k}}{\binom{N}{n}} \\&amp;= \frac{n(n-1)N_1(N_1-1)}{N(N-1)} \cdot \sum_{k = 2}^{N_1} \frac{\binom{N_1-2}{k-2} \binom{N-N_1}{n-k}}{\binom{N-2}{n-2}} + \frac{n \cdot N_1}{N} \\&amp;= \frac{n(n-1)N_1(N_1-1)}{N(N-1)} + \frac{n \cdot N_1}{N}\end{aligned}\]</span> 故 <span class="math display">\[\begin{aligned}Var(X) &amp;= E(X^2) - E^2(X) \\&amp;= \frac{n(n-1)N_1(N_1-1)}{N(N-1)} + \frac{n \cdot N_1}{N} - \frac{n^2N_1^2}{N^2} \\&amp;= \frac{n(N-n)(N-N_1)}{N^2(N-1)}\end{aligned}\]</span></p>]]></content>
    
    
    <categories>
      
      <category>概率论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>Probability</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新闻搜索网站构建记录</title>
    <link href="/2021/04/18/web/search-site/"/>
    <url>/2021/04/18/web/search-site/</url>
    
    <content type="html"><![CDATA[<h2 id="服务部署">服务部署</h2><p>请按照如下流程部署本项目：</p><ol type="1"><li>在<strong>news_search</strong>目录下安装所需的依赖插件：<strong>（国内请使用淘宝源安装nodejieba）</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> npm install request iconv-lite cheerio mysql jschardet moment</span><br><span class="hljs-meta">&gt;</span><span class="bash"> npm install nodejieba --registry=https://registry.npm.taobao.org --nodejieba_binary_host_mirror=https://npm.taobao.org/mirrors/nodejieba</span><br></code></pre></td></tr></table></figure><a id="more"></a><ol start="2" type="1"><li>启动本地MySQL服务，修改<strong>news_search/mysql.js</strong>中的相关信息为数据库登录信息：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> pool = mysql.createPool(&#123;<br>    host: <span class="hljs-string">&#x27;#数据库地址&#x27;</span>,<br>    user: <span class="hljs-string">&#x27;#本地数据库连接用户名&#x27;</span>, <br>    password: <span class="hljs-string">&#x27;#本地数据库连接密码&#x27;</span>,<br>    database: <span class="hljs-string">&#x27;#目标数据库名&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>登陆数据库管理系统，在控制台中设置相关变量以防止后续连接池堵塞：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&gt; set global wait_timeout&#x3D;10;<br>&gt; set global max_connections&#x3D;5000;<br>&gt; set session wait_timeout&#x3D;10;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>在数据库管理系统中创建所需的表结构：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&gt; CREATE TABLE &#96;news&#96; (<br>    &#96;id&#96; INT NOT NULL AUTO_INCREMENT,<br>    &#96;origin&#96; TEXT NOT NULL,<br>    &#96;category&#96; TEXT NOT NULL,<br>    &#96;title&#96; TEXT NOT NULL,<br>    &#96;time&#96; TEXT,<br>    &#96;source&#96; TEXT,<br>    &#96;abstract&#96; TEXT,<br>    &#96;content&#96; TEXT,<br>    PRIMARY KEY (&#96;id&#96;)<br>);<br>&gt; CREATE TABLE &#96;indices&#96; (<br>    &#96;id&#96; INT NOT NULL AUTO_INCREMENT,<br>    &#96;word&#96; TEXT,<br>    &#96;docs&#96; TEXT,<br>    PRIMARY KEY (&#96;id&#96;)<br>);<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>执行爬虫脚本爬取新闻内容：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> node crawler.js</span><br><span class="hljs-meta">&gt;</span><span class="bash"> node create_indices.js</span><br></code></pre></td></tr></table></figure><p><strong>P.S:</strong> 在测试环境下，若希望快速得到效果，可打开news_research/crawler.js文件，并将如下行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> total_pages = <span class="hljs-number">8</span>; <span class="hljs-comment">//Modify to a smaller number to speed up in demo environment</span><br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> total_pages = <span class="hljs-number">1</span>; <span class="hljs-comment">//Modify to a smaller number to speed up in demo environment</span><br></code></pre></td></tr></table></figure><p>保存后再执行上述代码。</p><ol start="6" type="1"><li>在<strong>news_site</strong>目录下安装所需的依赖：<strong>（国内请使用淘宝源安装nodejieba）</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> npm install express moment</span><br><span class="hljs-meta">&gt;</span><span class="bash"> npm install nodejieba --registry=https://registry.npm.taobao.org --nodejieba_binary_host_mirror=https://npm.taobao.org/mirrors/nodejieba</span><br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>启动网站后端服务：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> node bin/www</span><br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>使用浏览器访问网站前端：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs web-idl">http:&#x2F;&#x2F;localhost:3000<br></code></pre></td></tr></table></figure><h2 id="源内容抓取">源内容抓取</h2><h3 id="新闻网站解析">新闻网站解析</h3><h4 id="网易新闻">网易新闻</h4><p>网易新闻的主体分为国内和国际两个模块，其网站结构大体相同，因此我们集中针对这两个板块进行内容爬取。</p><p>分析新闻索引页面的HTML结构我们可以发现，新闻条目被放在了类名为<strong>newsdata_wrap</strong>的<strong>div</strong>标签下。然而由于网易新闻使用了动态加载新闻条目的方式，若我们使用GET请求直接获取页面的HTML时，该标签下的内容为空，因此我们无法直接通过解析网站的HTML数据获得具体的新闻信息。</p><p>继续分析访问网站时的文件传输流我们会发现网站的新闻条目是由一个叫<strong>cm_guonei.js</strong>（<strong>cm_guoji.js</strong>）的文件动态装载的，其原始路径为<code>https://temp.163.com/special/00804KVA/cm_guonei.js</code>。跟踪页面我们发现同级目录下还有<strong>cm_guonei_02.js<sub>cm_guonei_08.js<strong>（</strong>cm_guoji_02.js</sub>cm_guoji_08.js</strong>）共8个文件用于流式加载所有需要加载的新闻条目。打开文件发现其为一个类JSON结构，其中按条目存储了新闻页面的标题、网址、关键字、时间等基本信息。由此我们可以通过直接解析这些文件来获得所有需要爬取的新闻页面。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>    &#123;<br>        <span class="hljs-attr">&quot;title&quot;</span>:<span class="hljs-string">&quot;“港独”周竖峰出逃加拿大，曾辱骂内地生为“支那人”&quot;</span>,<br>        <span class="hljs-attr">&quot;digest&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">&quot;docurl&quot;</span>:<span class="hljs-string">&quot;https://www.163.com/news/article/G8GJUT8700019B3E.html&quot;</span>,<br>        <span class="hljs-attr">&quot;commenturl&quot;</span>:<span class="hljs-string">&quot;https://comment.tie.163.com/G8GJUT8700019B3E.html&quot;</span>,<br>        <span class="hljs-attr">&quot;tienum&quot;</span>:<span class="hljs-number">5276</span>,<br>        <span class="hljs-attr">&quot;tlastid&quot;</span>:<span class="hljs-string">&quot;&lt;a href=&#x27;http://news.163.com/&#x27;&gt;新闻&lt;/a&gt;&quot;</span>,<br>        <span class="hljs-attr">&quot;tlink&quot;</span>:<span class="hljs-string">&quot;https://www.163.com/news/article/G8GJUT8700019B3E.html&quot;</span>,<br>        <span class="hljs-attr">&quot;label&quot;</span>:<span class="hljs-string">&quot;其它&quot;</span>,<br>        <span class="hljs-attr">&quot;keywords&quot;</span>:[<br>            &#123;<span class="hljs-attr">&quot;akey_link&quot;</span>:<span class="hljs-string">&quot;https://news.163.com/keywords/5/6/54687ad65cf0/1.html&quot;</span>,<span class="hljs-attr">&quot;keyname&quot;</span>:<span class="hljs-string">&quot;周竖峰&quot;</span>&#125;,<br>            &#123;<span class="hljs-attr">&quot;akey_link&quot;</span>:<span class="hljs-string">&quot;https://news.163.com/keywords/6/2/6e2f72ec/1.html&quot;</span>,<span class="hljs-attr">&quot;keyname&quot;</span>:<span class="hljs-string">&quot;港独&quot;</span>&#125;,<br>            &#123;<span class="hljs-attr">&quot;akey_link&quot;</span>:<span class="hljs-string">&quot;https://news.163.com/keywords/5/a/52a062ff5927/1.html&quot;</span>,<span class="hljs-attr">&quot;keyname&quot;</span>:<span class="hljs-string">&quot;加拿大&quot;</span>&#125;],<br>        <span class="hljs-attr">&quot;time&quot;</span>:<span class="hljs-string">&quot;04/26/2021 10:19:15&quot;</span>,<br>        <span class="hljs-attr">&quot;newstype&quot;</span>:<span class="hljs-string">&quot;article&quot;</span>,<br>        <span class="hljs-attr">&quot;pics3&quot;</span>:[],<br>        <span class="hljs-attr">&quot;channelname&quot;</span>:<span class="hljs-string">&quot;guonei&quot;</span>,<br>        <span class="hljs-attr">&quot;source&quot;</span>:<span class="hljs-string">&quot;观察者网&quot;</span>,<br>        <span class="hljs-attr">&quot;point&quot;</span>:<span class="hljs-string">&quot;60&quot;</span>,<br>        <span class="hljs-attr">&quot;imgurl&quot;</span>:<span class="hljs-string">&quot;http://cms-bucket.ws.126.net/2021/0426/bc6435dep00qs5fri00kkc000s600e3c.png&quot;</span>,<br>        <span class="hljs-attr">&quot;add1&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">&quot;add2&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-attr">&quot;add3&quot;</span>:<span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>接下来我们分析新闻内容页面。该页面的具体内容是静态加载的，因此我们可以直接对其HTML内容进行抽取。然而随着进一步的分析我们会发现新闻页面的编码并不统一，分为UTF-8和GBK两种。为了得到网站的编码方式，我们使用了一个名为<strong>jschardet</strong>的插件。该插件可以通过分析文本的二进制编码给出其最可能的编码方法。由于目标网站只有两种编码方式，因此我们可以保证使用该插件检测得到的结果是可靠的。</p><img src="/2021/04/18/web/search-site/coding.png" class="" title="coding"><p>分析页面的HTML结构我们可以发现新闻内容被封装在了类名为<strong>post_main</strong>的<strong>div</strong>标签下，其中新闻标题类名为<strong>post_title</strong>，时间、来源的类名为<strong>post_info</strong>，正文的类名为<strong>post_body</strong>。我们首先使用<strong>iconv-lite</strong>插件对页面进行解码，随后利用<strong>Cheerio</strong>模块即可快速从网站的DOM结构中抽取出所需的内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> coding = chardet.detect(body)[<span class="hljs-string">&#x27;encoding&#x27;</span>]<br><span class="hljs-keyword">var</span> $ = cheerio.load(iconv.decode(body, coding).toString());<br><span class="hljs-keyword">var</span> title = $(<span class="hljs-string">&#x27;.post_title&#x27;</span>).text();<br><span class="hljs-keyword">if</span>(title != <span class="hljs-string">&#x27;&#x27;</span>)&#123;<br>    <span class="hljs-keyword">var</span> body_text = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span>($(<span class="hljs-string">&quot;.content.all-txt&quot;</span>).length &gt; <span class="hljs-number">0</span>)&#123;<br>        body_text = $(<span class="hljs-string">&#x27;.content.all-txt &gt; p&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>($(<span class="hljs-string">&#x27;.newscontents&#x27;</span>).length &gt; <span class="hljs-number">0</span>)&#123;<br>        body_text = $(<span class="hljs-string">&#x27;.newscontents &gt; p&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        body_text = $(<span class="hljs-string">&#x27;.post_body &gt; p&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">var</span> content = <span class="hljs-string">&quot;&quot;</span>;<br>    body_text.each(<span class="hljs-function">(<span class="hljs-params">index, item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>($(item).text() != <span class="hljs-string">&quot;&quot;</span>)&#123;<br>            content = content + $(item).text() + <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="环球网">环球网</h4><p>与网易新闻类似，环球网同样分为国内和国际两个模块，且采用了动态装载新闻条目的方式。通过追踪其文件传输流，我们发现其新闻源数据地址分别为<code>https://china.huanqiu.com/api/list?offset=0&amp;limit=20</code>和<code>https://world.huanqiu.com/api/list?offset=0&amp;limit=20</code>，其基本结构为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;list&quot;</span>:[<br>        &#123;<br>            <span class="hljs-attr">&quot;aid&quot;</span>:<span class="hljs-string">&quot;42vOMMYVUm3&quot;</span>,<br>            <span class="hljs-attr">&quot;title&quot;</span>:<span class="hljs-string">&quot;前国脚张恩华去世，享年48周岁&quot;</span>,<br>            <span class="hljs-attr">&quot;summary&quot;</span>:<span class="hljs-string">&quot;张恩华的职业生涯大部分时间是在大连实德以及前身大连万达队度过的，是大连实德队主力后卫，也是大连夺得联赛“七冠王”和多次杯赛冠军的主要功臣之一&quot;</span>,<br>            <span class="hljs-attr">&quot;addltype&quot;</span>:<span class="hljs-string">&quot;normal&quot;</span>,<br>            <span class="hljs-attr">&quot;typedata&quot;</span>:&#123;<br>                <span class="hljs-attr">&quot;audio&quot;</span>:&#123;<br>                    <span class="hljs-attr">&quot;members&quot;</span>:[]<br>                &#125;,<br>                <span class="hljs-attr">&quot;video&quot;</span>:&#123;<br>                    <span class="hljs-attr">&quot;members&quot;</span>:[]<br>                &#125;,<br>                <span class="hljs-attr">&quot;gallery&quot;</span>:&#123;<br>                    <span class="hljs-attr">&quot;members&quot;</span>:[]<br>                &#125;<br>            &#125;,<br>            <span class="hljs-attr">&quot;source&quot;</span>:&#123;<br>                <span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-literal">null</span>,<br>                <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;环球时报&quot;</span><br>            &#125;,<br>            <span class="hljs-attr">&quot;ext_displaytime&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-attr">&quot;ext_defertime&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-attr">&quot;ctime&quot;</span>:<span class="hljs-string">&quot;1619721799662&quot;</span>,<br>            <span class="hljs-attr">&quot;xtime&quot;</span>:<span class="hljs-string">&quot;1619721799662&quot;</span>,<br>            <span class="hljs-attr">&quot;cover&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-attr">&quot;host&quot;</span>:<span class="hljs-string">&quot;china.huanqiu.com&quot;</span>,<br>            <span class="hljs-attr">&quot;ext-serious&quot;</span>:<span class="hljs-string">&quot;1&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>环球网的新闻内容页根路径分别为<code>https://china.huanqiu.com/article/</code>和<code>https://world.huanqiu.com/article/</code>，因此我们只需使用该路径加上索引数据中的<strong>aid</strong>号，即可得到新闻页的完整网址。</p><p>分析其新闻内容页的HTML结构我们可以发现其正文的外层包裹分别有一个类名为<strong>l-con clear</strong>的<strong>div</strong>标签，一个<strong>article</strong>标签以及一个<strong>section</strong>标签，于是我们同样可以使用Cheerio插件快速将其内容从结构中抽取出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> coding = chardet.detect(body)[<span class="hljs-string">&#x27;encoding&#x27;</span>]<br><span class="hljs-keyword">var</span> $ = cheerio.load(iconv.decode(body, coding).toString());<br><span class="hljs-keyword">var</span> title = $(<span class="hljs-string">&#x27;.t-container-title&#x27;</span>).text();<br><span class="hljs-keyword">if</span>(title != <span class="hljs-string">&#x27;&#x27;</span>)&#123;<br>    <span class="hljs-keyword">var</span> body_text = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">if</span>($(<span class="hljs-string">&quot;.l-con.clear&quot;</span>).length &gt; <span class="hljs-number">0</span>)&#123;<br>        body_text = $(<span class="hljs-string">&#x27;.l-con.clear &gt; article &gt; section &gt; p&#x27;</span>);<br>        <span class="hljs-keyword">var</span> content = <span class="hljs-string">&quot;&quot;</span>;<br>        body_text.each(<span class="hljs-function">(<span class="hljs-params">index, item</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span>($(item).text() != <span class="hljs-string">&quot;&quot;</span>)&#123;<br>                <span class="hljs-keyword">var</span> para = $(item).text();<br>                content = content + para + <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据库构建">数据库构建</h3><p>提取出网站的内容后，我们需要将其以一定结构存放在一个可外部访问的空间内。为此，我们首先创建一个名为<strong>netease_news</strong>的数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE netease_news;<br></code></pre></td></tr></table></figure><p>并在其中构建一张名为<strong>news</strong>的表用于结构化存储新闻的各种信息。对于本项目，我们设计了8个表项，分别为：<strong>id（新闻的唯一标识符）、origin（新闻源网址）、category（分类：国内/国外）、title（标题）、time（创建时间）、source（来源）、abstract（内容摘要）、content（新闻内容）</strong>。我们将<strong>id</strong>设为主键，并设置其在每次插入时自增，这样在实际插入时我们只需插入其他7项即可，并能自动分配到一个唯一的id。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE &#96;news&#96; (<br>    &#96;id&#96; INT NOT NULL AUTO_INCREMENT,<br>    &#96;origin&#96; TEXT NOT NULL,<br>    &#96;category&#96; TEXT NOT NULL,<br>    &#96;title&#96; TEXT NOT NULL,<br>    &#96;time&#96; TEXT,<br>    &#96;source&#96; TEXT,<br>    &#96;keyword&#96; TEXT,<br>    &#96;heat&#96; INT,<br>    &#96;content&#96; TEXT,<br>    PRIMARY KEY (&#96;id&#96;)<br>);<br></code></pre></td></tr></table></figure><h3 id="基本爬虫逻辑">基本爬虫逻辑</h3><p>根据上面的分析，我们可以快速设计出爬虫的基本逻辑，其基本流程如下：</p><img src="/2021/04/18/web/search-site/crawl.png" class="" title="crawl"><p>在实际实现中，我们首先封装了一套mysql的读写工具：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;mysql&quot;</span>);<br><span class="hljs-keyword">var</span> pool = mysql.createPool(&#123;<br>    host: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    user: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    password: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    database: <span class="hljs-string">&#x27;netease_news&#x27;</span><br>&#125;);<br><span class="hljs-keyword">var</span> query = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sql, sqlparam, callback</span>) </span>&#123;<br>    pool.getConnection(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, conn</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            callback(err, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            conn.query(sql, sqlparam, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">qerr, vals, fields</span>) </span>&#123;<br>                conn.release();<br>                callback(qerr, vals, fields); <br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;;<br><span class="hljs-keyword">var</span> query_noparam = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sql, callback</span>) </span>&#123;<br>    pool.getConnection(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, conn</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            callback(err, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            conn.query(sql, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">qerr, vals, fields</span>) </span>&#123;<br>                conn.release();<br>                callback(qerr, vals, fields); <br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;;<br><span class="hljs-built_in">exports</span>.query = query;<br><span class="hljs-built_in">exports</span>.query_noparam = query_noparam;<br></code></pre></td></tr></table></figure><p>对于爬虫任务，我们将其封装为了六个函数，其中<strong>traverseNeteaseIndices</strong>用于遍历网易新闻的索引文件，<strong>phaseNeteaseLinkList</strong>用于解析网易新闻列表，<strong>phaseNeteaseNews</strong>用于解析网易新闻页的具体内容，另外三个函数<strong>traverseHQWIndices</strong>、<strong>phaseHQWLinkList</strong>和<strong>phaseHQWNews</strong>用于获取环球网新闻数据时的对应行为<strong>（具体实现见crawler.js）</strong>。</p><p>这里需要注意的是，由于<strong>request请求</strong>和<strong>mysql操作</strong>均为<strong>异步操作</strong>，程序执行的顺序无法确定，在同一时刻内，mysql服务器中可能同时有上千个连接，且当连接释放后，<strong>连接池不会立即关闭相应连接</strong>，这样就会造成<strong>连接池堵塞</strong>。为解决这一问题，我们首先在数据库控制台中缩小闲置连接回收间隔，并增大连接限制数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">&gt; set global wait_timeout&#x3D;10;<br>&gt; set global max_connections&#x3D;5000;<br>&gt; set session wait_timeout&#x3D;10;<br></code></pre></td></tr></table></figure><p>随后我们通过在爬虫逻辑中使用<strong>setTimeout</strong>函数延迟发送数据库请求，将数据库操作任务平摊到多个时间戳上，这样就有效避免了连接池堵死的情况发生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= pages; i++)&#123;<br>        <span class="hljs-comment">//Irrelevant code omitted</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            phaseNeteaseLinkList(url, category, i, pages);<br>        &#125;, <span class="hljs-number">3000</span> * (i - <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= pages; i++)&#123;<br>        <span class="hljs-comment">//Irrelevant code omitted</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            phaseHQWLinkList(url, pred, category, i, pages, last_flag);<br>        &#125;, <span class="hljs-number">5000</span> * i);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="布隆过滤器与去重">布隆过滤器与去重</h3><p>当我们需要多次执行爬虫任务时，就可能会遇到重复爬取同一网站的情况。为此，我们需要一套快速判断是否已经爬取过一个网址的方法。通常情况下，我们可以使用以下两种办法做到这一点：</p><ul><li>每次爬取一个页面前，在数据库中使用<strong>SELECT</strong>命令查询该网址是否已经存在</li><li>对新闻网址建立<strong>哈希表</strong>，每次爬取前查询该表以判断网址是否已经存在</li></ul><p>若使用第一种方法，根据不同数据库的存储及查询方法，其单次查询的时间复杂度在 <span class="math display">\[\mathcal{O}(\lg n)\]</span> 和 <span class="math display">\[\mathcal{O(n)}\]</span> 之间，<span class="math display">\[k\]</span> 次查询的时间复杂度最坏可能退化到 <span class="math display">\[O(kn)\]</span>；若使用第二种方法，尽管其单次查询的时间复杂度可以保证为 <span class="math display">\[\mathcal{O}(1)\]</span>，但对于一个含有 <span class="math display">\[n\]</span> 个网址的数据库，其空间复杂度为 <span class="math display">\[O(n)\]</span>。由此可见，随着爬虫规模的扩大，两种去重方法均有着一定的弊端，不利于任务的扩展。</p><p>为解决此问题，我们引入一种名为<strong>布隆过滤器（Bloom Filter）</strong>的数据结构<strong>（见filter.js）</strong>。布隆过滤器的核心思想为通过一串哈希函数将关键字映射到一个比特位串。查询时，先将目标关键字通过同样的哈希函数找到对应的索引位，若索引位存在映射，则表明目标关键字<strong>可能存在</strong>；若所有索引位均不存在映射，则表明目标关键字<strong>一定不存在</strong>。</p><img src="/2021/04/18/web/search-site/filter.png" class="" title="filter"><p>布隆过滤器是一种概率型数据结构，其误判率约为 <span class="math display">\[\left(1 - e^{-\frac{kn}{m}}\right)^k\]</span>。在实际使用场景下，只要当我们选择合适的 <span class="math display">\[k\]</span> 和 <span class="math display">\[m\]</span> 值，就可以让误判率几乎不影响业务逻辑。这可以由如下公式给出： <span class="math display">\[k = \frac{m}{n} \ln 2 , m = - \frac{n \ln p}{\ln^2 2}\]</span> 其中 <span class="math display">\[k\]</span> 为哈希函数的个数，<span class="math display">\[m\]</span> 为位串长度，<span class="math display">\[p\]</span> 为预期的误报率。</p><p>布隆过滤器增加和查询时间复杂度均为 <span class="math display">\[\mathcal{O}(k)\]</span>（ <span class="math display">\[k\]</span> 为哈希函数的个数），空间复杂度为 <span class="math display">\[\mathcal{O}(m)\]</span>（<span class="math display">\[m\]</span> 为比特位长度），相比前两种方法可以很好的平衡存储空间和查询效率。</p><h3 id="分词与倒排索引">分词与倒排索引</h3><p>当用户发起搜索请求时，我们需要从数据库中<strong>快速找出所有内容含有用户所请求关键字的新闻条目</strong>。若使用全文搜索的方法，随着数据规模增大，会造成极大的延迟。为解决此问题，我们在爬取文章的时候，对文章内容进行<strong>分词</strong>，并使用词关键字对文章建立<strong>倒排索引</strong>，在搜索时，只需要将关键字使用同样的方法进行分词，并在倒排索引表中查询对应的文档编号即可。</p><img src="/2021/04/18/web/search-site/inverted_index.jpg" class="" title="inverted_index"><p>为此，我们首先在数据库中再建立一张索引表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE &#96;indices&#96; (<br>    &#96;id&#96; INT NOT NULL AUTO_INCREMENT,<br>    &#96;word&#96; TEXT,<br>    &#96;docs&#96; TEXT,<br>    PRIMARY KEY (&#96;id&#96;)<br>);<br></code></pre></td></tr></table></figure><p>随后我们读取news表中的新闻内容，并使用<strong>nodejieba</strong>插件对其进行分词。由于文章中还有部分特殊符号及无意义词，我们通过一个<strong>停用词表</strong>来将其去除。为保证词关键字的唯一性，我们维护一个<strong>集合</strong>，将每个文档分词后的结果依次插入该集合，并将结果插入数据库中：<strong>（见create_indices.js）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> word_set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><span class="hljs-keyword">var</span> para = item.content;<br><span class="hljs-comment">//Cut word</span><br><span class="hljs-keyword">var</span> para_filtered = para.replace(<span class="hljs-string">&quot;　&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>para_filtered = para_filtered.replace(<span class="hljs-string">&quot;，&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;。&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">var</span> word_list = jieba.cut(para_filtered);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; word_list.length; i++)&#123;<br>    word_set.add(word_list[i]);<br>&#125;<br>word_set.forEach(<span class="hljs-function">(<span class="hljs-params">word</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(!stop_list.includes(word))&#123;<br>        <span class="hljs-comment">//Insert the result to the database</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网站构建">网站构建</h2><h3 id="基本构架">基本构架</h3><p>接下来我们来构建新闻搜索网站。新闻搜索网站的主要行为是提供一个可供用户输入的界面，当用户输入关键字后，系统从数据库中检索出带有用户所指定关键字的新闻条目，并将结果以一定的顺序生成相应的内容页面返回给用户。我们使用<strong>Express脚手架</strong>来构建网站的后端。对于网站路由，我们共设计了4个入口，其中根目录为浏览器访问入口，用于呈现相应的HTML页面，其他三个入口<strong>/query</strong>、<strong>/qcontent</strong>和<strong>/qheat</strong>分别用于前端请求<strong>关键字结果</strong>、<strong>完整正文内容</strong>及<strong>关键字热度分析结果</strong>。</p><p>对于网站前端，我们使用了<strong>Bootstrap框架</strong>来生成所需的样式。搜索引擎页面设计的一个核心宗旨即为简洁，因此在搜索界面，我们参考了百度和Google的设计样式，通过卡片的方式将目标条目呈现给用户。在一张卡片中，我们呈现了新闻条目的<strong>标题、事件、来源、摘要及类别</strong>，以方便用户初步预览新闻的大致内容。</p><img src="/2021/04/18/web/search-site/search_page.png" class="" title="search_page"><p>由于卡片的内容是由后端返回的结果动态决定的，因此我们不能直接将其写死在HTML中，而需要通过Javascript脚本动态生成并将其添加至HTML的DOM结构中：<strong>（见public/index.html）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendCard</span>(<span class="hljs-params">father, title, id, time, source, abstract, cat</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> card = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    card.class = <span class="hljs-string">&#x27;card&#x27;</span>;<br>    <span class="hljs-keyword">var</span> card_body = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    card_body.class = <span class="hljs-string">&#x27;card-body&#x27;</span>;<br>    <span class="hljs-keyword">var</span> card_link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>);<br>    card_link.class = <span class="hljs-string">&#x27;card-link&#x27;</span>;<br>    <span class="hljs-comment">//Irrelevant code omitted</span><br>    card_link.innerText = title;<br>    card_link.style.fontSize = <span class="hljs-string">&quot;large&quot;</span>;<br>    card_body.appendChild(card_link);<br>    <span class="hljs-keyword">var</span> card_info = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;p&quot;</span>);<br>    <span class="hljs-keyword">if</span>(source != <span class="hljs-literal">null</span>)&#123;<br>        card_info.innerText = time + <span class="hljs-string">&quot; &quot;</span> + source;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        card_info.innerText = time;<br>    &#125;<br>    card_body.appendChild(card_info);<br>    <span class="hljs-keyword">var</span> card_abstract = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;p&quot;</span>);<br>    card_abstract.innerText = abstract;<br>    card_abstract.style.fontSize = <span class="hljs-string">&quot;small&quot;</span>;<br>    card_body.appendChild(card_abstract);<br>    <span class="hljs-keyword">var</span> card_cat = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;p&quot;</span>);<br>    <span class="hljs-keyword">if</span>(cat == <span class="hljs-string">&quot;domestic&quot;</span>)&#123;<br>        card_cat.innerText = <span class="hljs-string">&quot;类别：国内&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cat == <span class="hljs-string">&quot;world&quot;</span>)&#123;<br>        card_cat.innerText = <span class="hljs-string">&quot;类别：国外&quot;</span>;<br>    &#125;<br>    card_body.appendChild(card_cat);<br>    card.appendChild(card_body);<br>    <span class="hljs-keyword">var</span> page_elem = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;page-list&#x27;</span>);<br>    page_elem.appendChild(card);<br>&#125;<br></code></pre></td></tr></table></figure><p>当用户点击一个条目后，将跳转到一个新的页面，页面将向后端请求该新闻条目的完整内容。我们可以通过URL含参跳转的方法来实现这一跳转请求操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//index.html</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">appendCard</span>(<span class="hljs-params">father, title, id, time, source, abstract, cat</span>)</span>&#123;<br>    <span class="hljs-comment">//Irrelevant code omitted</span><br>    card_link.href = <span class="hljs-string">&#x27;/content.html?id=&#x27;</span> + id;<br>    <span class="hljs-comment">//Irrelevant code omitted</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//content.html</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetUrlParam</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;(^|&amp;)&quot;</span>+ name +<span class="hljs-string">&quot;=([^&amp;]*)(&amp;|$)&quot;</span>);<br>    <span class="hljs-keyword">var</span> r = <span class="hljs-built_in">window</span>.location.search.substr(<span class="hljs-number">1</span>).match(reg);<br>    <span class="hljs-keyword">if</span>(r!=<span class="hljs-literal">null</span>)<span class="hljs-keyword">return</span> r[<span class="hljs-number">2</span>]; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> id = GetUrlParam(<span class="hljs-string">&quot;id&quot;</span>);<br>$.get(<span class="hljs-string">&quot;/qcontent?id=&quot;</span> + id, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>    <span class="hljs-comment">//Irrelevant code omitted</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>对于内容的呈现，我们同样使用了动态方法将正文添加至页面上：<strong>（见public/content.html）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> title = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;h1&#x27;</span>);<br>title.align = <span class="hljs-string">&quot;center&quot;</span>;<br>title.innerText = data.title;<br><span class="hljs-keyword">var</span> info = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;h5&#x27;</span>);<br>info.style.color = <span class="hljs-string">&quot;#808080&quot;</span>;<br>info.innerText = data.time + <span class="hljs-string">&quot; 来源：&quot;</span> + data.source;<br><span class="hljs-keyword">var</span> para = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;p&#x27;</span>); <br>para.innerText = data.content;<br><span class="hljs-keyword">var</span> page_elem = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;news-content&#x27;</span>);<br>page_elem.appendChild(title);<br>page_elem.appendChild(info);<br>page_elem.appendChild(para);<br></code></pre></td></tr></table></figure><h3 id="搜索提示">搜索提示</h3><p>在现代搜索引擎中，我们希望系统能够即时根据当前的输入智能推测用户想要搜索的完整内容。为实现这一功能，我们需要监听输入框的内容变化事件，并在每次这一事件发生时向后端发送搜索请求：<strong>（见public/index.html）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span>(<span class="hljs-params">callback, mode</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> keywords = $(<span class="hljs-string">&quot;:input[name=&#x27;keywords&#x27;]&quot;</span>).val();<br>    $.get(<span class="hljs-string">&quot;/query?keywords=&quot;</span> + keywords + <span class="hljs-string">&quot;&amp;mode=&quot;</span> + mode, callback);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">middleSearch</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//Irrelevant code omitted</span><br>    search(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> recList = [];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">10</span>, data.length); i++)&#123;<br>            recList.push(data[i].title);<br>        &#125;<br>        <span class="hljs-comment">//Irrelevant code omitted</span><br>    &#125;, <span class="hljs-string">&quot;middle&quot;</span>);<br>&#125;<br><br>$(<span class="hljs-string">&quot;:input[name=&#x27;keywords&#x27;]&quot;</span>).on(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    middleSearch();<br>&#125;);<br></code></pre></td></tr></table></figure><p>由于搜索提示要求即时响应，因此我们通过向后端传入一个<strong>mode</strong>参数来决定搜索的响应精度和速度。对于<strong>提示用搜索请求（mode=middle）</strong>，后端将只扫描数据库<strong>新闻标题（title）</strong>列中含有目标关键字的条目，并只返回前10条结果。<strong>（事实上，若使用预训练的关键词关联库，我们可以引入更为智能的搜索提示，不过由于本项目为新闻搜索网站，这一功能并不实用）</strong></p><img src="/2021/04/18/web/search-site/auto_complete.png" class="" title="auto-complete"><p>对于前端，我们使用了<strong>JQuery-UI框架</strong>实现了补全列表的界面。通过JQuery语句在搜索框后附加<strong>autocomplete</strong>属性，即可使得列表中的内容随着用户的输入自动改变：<strong>（见public/index.html）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;:input[name=&#x27;keywords&#x27;]&quot;</span>).autocomplete(&#123;<br>    source: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">query, response</span>)</span>&#123;<br>        search(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>            <span class="hljs-keyword">var</span> recList = [];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">10</span>, data.length); i++)&#123;<br>                recList.push(data[i].title);<br>            &#125;<br>            <span class="hljs-keyword">return</span> response(recList);<br>        &#125;, <span class="hljs-string">&quot;middle&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="关键词热度分析">关键词热度分析</h3><p>最后，我们来实现对用户的搜索关键词进行时间热度分析的逻辑。由于在爬虫过程中我们抓取了文章的创建时间，并对正文内容进行了倒排索引，我们可以快速实现这一功能。</p><p>与显示新闻正文时的逻辑类似，当用户选择热度分析后，页面将含参跳转到一个新的页面，并向后端的<strong>/qheat</strong>入口请求热度分析结果。后端首先从<strong>news</strong>和<strong>indices</strong>表中分别找出包含目标关键词的新闻条目，并抽取出它们的时间信息。随后，我们按月份对其进行统计，并将其按时间排序，最终将结果封装为JSON字符串传回给前端：<strong>（见routes/index.js）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Irrelevant code omitted</span><br><span class="hljs-keyword">var</span> seq = &#123;&#125;;<br>result.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(seq.hasOwnProperty(item.time.slice(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>)))&#123;<br>        seq[item.time.slice(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>)] += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        seq[item.time.slice(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>)] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;);<br><span class="hljs-keyword">var</span> sortedKeys = <span class="hljs-built_in">Object</span>.keys(seq).sort();<br><span class="hljs-keyword">var</span> seq_sort = &#123;&#125;;<br>sortedKeys.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    seq_sort[item] = seq[item];<br>&#125;);<br><span class="hljs-comment">//Irrelevant code omitted</span><br></code></pre></td></tr></table></figure><p>对于分析类功能，图表是一个较为直观的呈现形式。在这里我们使用了<strong>HighCharts</strong>图表框架来根据后端返回的数据快速生成这一样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Highcharts.chart(<span class="hljs-string">&#x27;chart&#x27;</span>, &#123;<br>    title: &#123;<br>        text: <span class="hljs-string">&quot;关键词时间热度分布&quot;</span><br>    &#125;,<br>    xAxis: &#123;<br>        categories: <span class="hljs-built_in">Object</span>.keys(data)<br>    &#125;,<br>    series: [&#123;<br>        data: value_list,<br>        type: <span class="hljs-string">&quot;line&quot;</span>,<br>        name: <span class="hljs-string">&quot;关键词：&quot;</span> + sdecodeURI(keyword)<br>    &#125;]<br>&#125;);<br></code></pre></td></tr></table></figure><p>最终的显示效果如下：</p><img src="/2021/04/18/web/search-site/heat_analysis.png" class="" title="heat_analysis">]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Web</tag>
      
      <tag>Frontend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据科学与工程数学基础 作业3</title>
    <link href="/2021/04/12/dase-math/dase-math-assignment-3/"/>
    <url>/2021/04/12/dase-math/dase-math-assignment-3/</url>
    
    <content type="html"><![CDATA[<h2 id="一">一</h2><blockquote><p>分别求下面向量的1-范数、2-范数和无穷范数 <span class="math display">\[a_1 = \begin{pmatrix}1 \\2 \\1\end{pmatrix},a_2 = \begin{pmatrix}-1 \\0 \\1\end{pmatrix},a_3 = \begin{pmatrix}-2 \\1 \\1\end{pmatrix}\]</span></p></blockquote><p><span class="math display">\[\begin{aligned}||a_1||_1 &amp;= |1| + |2| + |1| = 4 \\||a_1||_2 &amp;= \sqrt{1^2+2^2+1^2} = \sqrt{6} \\||a_1||_\infty &amp;= \max\{|1|,|2|,|1|\} = 2 \\\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}||a_2||_1 &amp;= |-1| + |0| + |1| = 2 \\||a_2||_2 &amp;= \sqrt{(-1)^2+0^2+1^2} = \sqrt{2} \\||a_2||_\infty &amp;= \max\{|-1|,|0|,|1|\} = 1 \\\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}||a_2||_1 &amp;= |-2| + |1| + |1| = 4 \\||a_2||_2 &amp;= \sqrt{(-2)^2+1^2+1^2} = \sqrt{6} \\||a_2||_\infty &amp;= \max\{|-2|,|1|,|1|\} = 2 \\\end{aligned}\]</span></p><h2 id="二">二</h2><blockquote><p>证明函数 <span class="math inline">\(F: \mathbb{R}^n \to \mathbb{R}, F(x) = \sqrt{\langle x, x \rangle }\)</span> 是向量范数</p></blockquote><p><strong>非负性：</strong>易见任取 <span class="math inline">\(\textbf{x} \in \mathbb{R}^n\)</span> <span class="math display">\[F(\mathbf{x}) = \sqrt{\langle \mathbf{x}, \mathbf{x}\rangle} = \sqrt{\sum_\limits{i = 1}^n x_i^2} \geq 0\]</span> 且 <span class="math inline">\(F(\mathbf{x}) = 0 \leftrightarrow \forall i \in \{1,2,...,n\}, x_i = 0\)</span>，即 <span class="math inline">\(F(\textbf{x}) = 0\)</span> 当且仅当 <span class="math inline">\(\textbf{x} = \textbf{0}\)</span></p><p><strong>齐次性：</strong>任取 <span class="math inline">\(\textbf{x} \in \mathbb{R}^n, \lambda \in \mathbb{R}\)</span> <span class="math display">\[\begin{aligned}F(\lambda \textbf{x}) &amp;= \sqrt{\langle \lambda \textbf{x}, \lambda \textbf{x}\rangle} \\&amp;=\sqrt{(\lambda \textbf{x})^T\lambda \textbf{x}} \\&amp;=\sqrt{\lambda^2 \textbf{x}^T \textbf{x}} \\&amp;=|\lambda| \sqrt{\textbf{x}^T \textbf{x}} \\&amp;=|\lambda| F(\textbf{x})\end{aligned}\]</span> <strong>三角不等式：</strong>任取 <span class="math inline">\(\textbf{x}, \textbf{y} \in \mathbb{R}^n\)</span> <span class="math display">\[\begin{aligned}F^2(\textbf{x} + \textbf{y}) &amp;= (\textbf{x} + \textbf{y})^T(\textbf{x} + \textbf{y}) \\&amp;=(\textbf{x}^T + \textbf{y}^T)(\textbf{x} + \textbf{y}) \\&amp;= \textbf{x}^T \textbf{x} + \textbf{y}^T \textbf{x} + \textbf{x}^T \textbf{y} + \textbf{y}^T \textbf{y} \\ \end{aligned}\]</span> 由<strong>Cauchy-Schwarz不等式</strong>可知 <span class="math inline">\(\forall \textbf{x}, \textbf{y} \in \mathbb{R}^n, | \langle \textbf{x}, \textbf{y} \rangle | \leq ||\textbf{x}||_2 \cdot \||\textbf{y}||_2\)</span></p><p>故 <span class="math display">\[\begin{aligned}F^2(\textbf{x} + \textbf{y}) &amp;\leq \textbf{x}^T \textbf{x} + |\textbf{y}^T \textbf{x}| + |\textbf{x}^T \textbf{y}| + \textbf{y}^T \textbf{y} \\&amp;\leq \textbf{x}^T \textbf{x} + 2 \sqrt{\textbf{x}^T \textbf{x} \textbf{y}^T \textbf{y}} + \textbf{y}^T \textbf{y} \\&amp;=\left( \sqrt{\textbf{x}^T \textbf{x}} + \sqrt{\textbf{y}^T \textbf{y}} \right)^2 \\&amp;=\left(F(\textbf{x}) + F(\textbf{y})\right)^2\end{aligned}\]</span> 于是由非负性可知 <span class="math display">\[F(\textbf{x} + \textbf{y}) \leq F(\textbf{x}) + F(\textbf{y})\]</span></p><p>因此 <span class="math inline">\(F(\mathbf{x}) = \sqrt{\langle \mathbf{x}, \mathbf{x}\rangle}\)</span> 是向量范数</p><h2 id="三">三</h2><blockquote><p>对任给的 <span class="math inline">\(x = (x_1, x_2, x_3)^T \in \mathbb{C}^3\)</span>，试问如下实值函数是否构成向量范数？ <span class="math display">\[f_1(x) = |x_1|^4 + |x_2|^4 + |x_3|^4 \\f_2(x) = |x_1| + 3 |x_2| + 2 |x_3|\]</span></p></blockquote><p><strong>(1)</strong> 任取 <span class="math inline">\(\textbf{x} = (x_1, x_2, x_3)^T \in \mathbb{C}^3, \lambda \in \mathbb{R}\)</span> <span class="math display">\[\begin{aligned}f_1(\lambda \textbf{x}) &amp;=|\lambda x_1|^4 + |\lambda x_2|^4 + |\lambda x_3|^4 \\&amp;= |\lambda|^4 |x_1|^4 + |\lambda|^4 |x_2|^4 + |\lambda|^4 |x_3|^4 \\\end{aligned}\]</span> 故 <span class="math inline">\(f_1\)</span> 不满足齐次性，因此 <strong><span class="math inline">\(f_1\)</span> 不构成向量范数</strong></p><p><strong>(2)</strong> 任取 <span class="math inline">\(\textbf{x}, \textbf{y} \in \mathbb{C}^3, \lambda \in \mathbb{R}\)</span></p><p>易见 <span class="math display">\[f_2(\textbf{x}) = |x_1| + 3 |x_2| + 2|x_3| \geq 0\]</span> 且 <span class="math inline">\(f_2(\textbf{x}) = 0 \leftrightarrow x_1=x_2=x_3 = 0\)</span> <span class="math display">\[\begin{aligned}f_2(\lambda \textbf{x}) &amp;= |\lambda x_1| + 3 |\lambda x_2| + 2 |\lambda x_3| \\&amp;=|\lambda| (|x_1| + 3 |x_2| + 2 |x_3|) \\&amp;=|\lambda| f_2 (\textbf{x})\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}f_2(\textbf{x} + \textbf{y}) &amp;= |x_1+y_1| + 3 |x_2+y_2| + 2|x_3 + y_3| \\&amp;\leq |x_1| + |y_1| + 3|x_2| + 3|y_2| + 2|x_3| + 2|y_3| \\&amp;=f_2(\textbf{x}) + f_2(\textbf{y})\end{aligned}\]</span></p><p>因此 <strong><span class="math inline">\(f_2\)</span> 构成向量范数</strong></p><h2 id="四">四</h2><blockquote><p>证明如下定义的函数 <span class="math inline">\(\langle \cdot, \cdot \rangle: \mathbb{R}^2 \times \mathbb{R}^2 \to \mathbb{R}\)</span> 是内积： <span class="math display">\[\langle x, y \rangle := x_1 y_1 - (x_1 y_2 + x_2 y_1) + 2 x_2 y_2\]</span></p></blockquote><p><span class="math inline">\(\forall \textbf{x}, \textbf{y}, \textbf{z} \in \mathbb{R}^2, \lambda \in \mathbb{R}\)</span></p><p><strong>非负性：</strong> <span class="math display">\[\begin{aligned}\langle \textbf{x}, \textbf{x} \rangle &amp;= x_1^2+2x_2^2-2x_1x_2 \\&amp;=(x_1-x_2)^2+x_2^2 \geq 0\end{aligned}\]</span> <span class="math inline">\(\langle \textbf{x}, \textbf{x} \rangle = 0 \leftrightarrow x_1=x_2 = 0 \leftrightarrow \textbf{x} = 0\)</span></p><p><strong>对称性：</strong><span class="math inline">\(\langle \textbf{x}, \textbf{y} \rangle = x_1y_1 - x_2y_1 - x_1y_2 + 2x_2y_2 = y_1x_1-y_2x_1-y_1x_2+2y_2x_2= \langle \textbf{y}, \textbf{x}\rangle\)</span></p><p><strong>齐次性：</strong> <span class="math display">\[\begin{aligned}\langle \lambda\textbf{x}, \textbf{y} \rangle &amp;=\lambda x_1y_1 - (\lambda x_1y_2 + \lambda x_2y_1) + 2 \lambda x_2y_2 \\&amp;=\lambda (x_1y_1 - x_1y_2 - x_2y_1 + 2x_2y_2) \\&amp;=\lambda \langle \textbf{x}, \textbf{y} \rangle\end{aligned}\]</span> <strong>线性性：</strong> <span class="math display">\[\begin{aligned}\langle \textbf{x} + \textbf{y}, \textbf{z} \rangle &amp;= (x_1 + y_1) z_1 - [(x_1 + y_1)z_2 + (x_2 + y_2) z_1] + 2 (x_2 + y_2) z_2 \\&amp;=x_1z_1 + y_1z_1 - x_1z_2 - y_1z_2 + x_2z_1 + y_2z_1 + 2x_2z_2 + 2y_2z_2 \\&amp;= \langle \textbf{x}, \textbf{z} \rangle + \langle \textbf{y}, \textbf{z} \rangle\end{aligned}\]</span> 因此 <span class="math inline">\(\langle \textbf{x}, \textbf{y} \rangle = x_1y_1 - (x_1y_2 + x_2y_1) + 2x_2y_2\)</span> 是一个内积</p><h2 id="五">五</h2><blockquote><p>分别求下面矩阵1-范数、2-范数和无穷范数 <span class="math display">\[A_1 = \begin{pmatrix}1 &amp; 2 \\1 &amp; 0\end{pmatrix},A_2 = \begin{pmatrix}-1 &amp; 0 \\1 &amp; 2\end{pmatrix}\]</span></p></blockquote><p><span class="math display">\[\begin{aligned}||A_1||_1 &amp;= \max \{|1| + |1|, |2| + |0|\} = 2 \\||A_1||_2 &amp;= \sqrt{\max\{3 + \sqrt{5}, 3 - \sqrt{5}\}} = \frac{1+\sqrt{5}}{\sqrt{2}} \\||A_1||_\infty &amp;= \max\{|1| + |2|, |1| + |0| \} = 3 \\\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}||A_2||_1 &amp;= \max \{|-1| + |1|, |0| + |2|\} = 2 \\||A_2||_2 &amp;= \sqrt{\max\{3 + \sqrt{5}, 3 - \sqrt{5}\}} = \frac{1+\sqrt{5}}{\sqrt{2}} \\||A_2||_\infty &amp;= \max\{|-1| + |0|, |1| + |2| \} = 3\end{aligned}\]</span></p><h2 id="六">六</h2><blockquote><p>求矩阵 <span class="math inline">\(\begin{pmatrix} 1 &amp; -1 &amp; 0 \\ 2 &amp; 4 &amp; 1 \\ 4 &amp; 2 &amp; 1 \end{pmatrix}\)</span> 的行空间、列空间、零空间和左零空间。</p></blockquote><p>设 <span class="math inline">\(A = \begin{pmatrix} 1 &amp; -1 &amp; 0 \\ 2 &amp; 4 &amp; 1 \\ 4 &amp; 2 &amp; 1\end{pmatrix}\)</span></p><p>设 <span class="math inline">\(\alpha_1 = (1, 2, 4)^T, \alpha_2 = (-1, 4, 2)^T, \alpha_3 = (0, 1, 1)^T\)</span></p><p>故 <span class="math display">\[\textbf{Col}(A) = \textbf{span} \{\alpha_1, \alpha_2, \alpha_3\} = \{ k_1 \alpha_1 + k_2 \alpha_2 + k_3 \alpha_3 : k_1, k_2, k_3 \in \mathbb{R} \}\]</span> 设 <span class="math inline">\(r_1 = (1, -1, 0)^T, r_2 = (2, 4, 1)^T, r_3 = (4, 2, 1)^T\)</span></p><p>故 <span class="math display">\[\textbf{Row}(A) = \textbf{span} \{r_1, r_2, r_3 \} = \{k_1 r_1 + k_2 r_2 + k_3 r_3: k_1, k_2, k_3 \in \mathbb{R} \}\]</span> 对 <span class="math inline">\(A\)</span> 作行初等变换 <span class="math display">\[A \xrightarrow[r_3-4_1]{r_2-2r_1}\begin{pmatrix}1 &amp; -1 &amp; 0 \\0 &amp; 6 &amp; 1 \\0 &amp; 6 &amp; 1\end{pmatrix}\xrightarrow{r_3-r_2}\begin{pmatrix}1 &amp; -1 &amp; 0 \\0 &amp; 6 &amp; 1 \\0 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow{\frac{1}{6}r_2}\begin{pmatrix}1 &amp; -1 &amp; 0 \\0 &amp; 1 &amp; \frac{1}{6} \\0 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow{r_1+r_2}\begin{pmatrix}1 &amp; 0 &amp; \frac{1}{6} \\0 &amp; 1 &amp; \frac{1}{6} \\0 &amp; 0 &amp; 0\end{pmatrix}\]</span> 故令 <span class="math inline">\(\alpha = (-1, -1, 6)^T\)</span>，则 <span class="math display">\[\textbf{Null}(A) = \textbf{span}(\alpha) = \{k\alpha: k \in \mathbb{R} \}\]</span> 对 <span class="math inline">\(A^T\)</span> 作行初等变换</p><p><span class="math display">\[\begin{aligned}A^T \xrightarrow{r_2+r_1}\begin{pmatrix}1 &amp; 2 &amp; 4 \\0 &amp; 6 &amp; 6 \\0 &amp; 1 &amp; 1\end{pmatrix}\xrightarrow{\frac{1}{6}r_2}\begin{pmatrix}1 &amp; 2 &amp; 4 \\0 &amp; 1 &amp; 1 \\0 &amp; 1 &amp; 1\end{pmatrix}\xrightarrow{r_3-r_2}\begin{pmatrix}1 &amp; 2 &amp; 4 \\0 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow{r_1-2r_2}\begin{pmatrix}1 &amp; 0 &amp; 2 \\0 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 0\end{pmatrix}\end{aligned}\]</span> 故令 <span class="math inline">\(\beta = (-2, -1, 1)^T\)</span>，则 <span class="math display">\[\textbf{Null}(A^T) = \textbf{span}(\beta) = \{k \beta: k \in \mathbb{R} \}\]</span></p><h2 id="七">七</h2><blockquote><p>求由向量 <span class="math inline">\(\begin{pmatrix} 1 \\ 2 \\ 1 \end{pmatrix}, \begin{pmatrix} 0 \\ 1 \\ 2 \end{pmatrix}\)</span> 张成的子空间的正交补空间。</p></blockquote><p>由 <span class="math display">\[\begin{pmatrix}1 &amp; 2 &amp; 0 \\0 &amp; 1 &amp; 2\end{pmatrix}\xrightarrow{r_1-2r_2}\begin{pmatrix}1 &amp; 0 &amp; -4 \\0 &amp; 1 &amp; 2\end{pmatrix}\]</span> 可知 <span class="math display">\[\textbf{span}^{\bot} \left\{\begin{pmatrix}1 \\ 2 \\ 0\end{pmatrix},\begin{pmatrix}0 \\ 1 \\ 2\end{pmatrix}\right\}=\textbf{span} \left\{\begin{pmatrix}4 \\ -2 \\ 1\end{pmatrix}\right\}\]</span></p><h2 id="八">八</h2><blockquote><p>写出一个与子空间 <span class="math inline">\(\textrm{span} \left\{(1,2,1)^T \right\}\)</span> 正交的子空间。</p></blockquote><p>由于 <span class="math display">\[(-1,0,1) \cdot (1,2,1)^T = 0\]</span> 故 <span class="math display">\[\textbf{span} \left\{ (-1,0,1)^T \right\} \bot \ \textbf{span} \left\{ (1,2,1)^T \right\}\]</span></p><h2 id="九">九</h2><blockquote><p>求向量 <span class="math inline">\((1,1,1)^T\)</span> 投影到一维子空间 <span class="math inline">\(\textrm{span} \left\{(1,-1,1)^T \right\}\)</span> 的正交投影。</p></blockquote><p>设 <span class="math inline">\(\alpha = (1,-1,1)^T, x = (1,1,1)^T\)</span></p><p>则 <span class="math inline">\(\textbf{span}\left\{(1,-1,1)^T\right\}\)</span> 的投影矩阵为 <span class="math display">\[P_\pi = \frac{\alpha \alpha^T}{\alpha^T \alpha} = \frac{1}{3}\begin{pmatrix}1 &amp; -1 &amp; 1 \\-1 &amp; 1 &amp; -1 \\1 &amp; -1 &amp; 1\end{pmatrix}\]</span> 于是 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(\textbf{span}\left\{(1,-1,1)^T\right\}\)</span> 中的正交投影为 <span class="math display">\[\pi(x) = P_\pi \cdot x = \left( \frac{1}{3},-\frac{1}{3},\frac{1}{3} \right)^T\]</span></p><h2 id="十">十</h2><blockquote><p>求向量 <span class="math inline">\((1,1,1)^T\)</span> 投影到仿射空间 <span class="math inline">\(\textrm{span} \left\{(1,-1,1)^T , (1,1,0)^T \right\} + (1,2,1)^T\)</span> 的正交投影。</p></blockquote><p>设 <span class="math inline">\(\alpha_1 = (1, -1, 1)^T, \alpha_2 = (1,1,0)^T, \beta = (1,2,1)^T, x = (1,1,1)^T, x_0 = x - \beta = (0,-1,0)^T\)</span></p><p>于是令 <span class="math inline">\(B = (\alpha_1, \alpha_2) = \begin{pmatrix} 1 &amp; 1 \\ -1 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\)</span></p><p>因此 <span class="math display">\[B^TB = \begin{pmatrix}3 &amp; 0 \\0 &amp; 2\end{pmatrix},B^Tx_0 = (1,-1)^T\]</span> 故由 <span class="math inline">\(B^TB\lambda = B^Tx_0\)</span> 可知，<span class="math inline">\(\lambda = (\frac{1}{3}, -\frac{1}{2})^T\)</span></p><p>故 <span class="math display">\[\pi(x_0) = B \lambda = (-\frac{1}{6}, -\frac{5}{6}, \frac{1}{3})^T\]</span> 于是 <span class="math display">\[\pi(x) = \pi(x_0) + \beta = (\frac{5}{6}, \frac{7}{6}, \frac{4}{3})^T\]</span></p><h2 id="十一">十一</h2><blockquote><p>设 <span class="math display">\[a_1 = \begin{pmatrix} 1 \\2 \\-1\end{pmatrix},a_2 = \begin{pmatrix} -1 \\3 \\1\end{pmatrix},a_3 = \begin{pmatrix} 4 \\-1 \\0\end{pmatrix}\]</span> ，试将向量组 <span class="math inline">\((a_1, a_2, a_3)\)</span> 标准正交化。</p></blockquote><p>令 <span class="math display">\[\begin{aligned}b_1 &amp;= a_1 = (1,2,-1)^T \\b_2 &amp;= a_2 - \frac{\langle b_1, a_2 \rangle}{\langle b_1,b_1 \rangle} b_1 = \frac{5}{3}(-1,1,1)^T \\b_3 &amp;= a_3 - \frac{\langle b_1, a_3 \rangle}{\langle b_1,b_1 \rangle} b_1 - \frac{\langle b_2, a_3 \rangle}{\langle b_2,b_2 \rangle} b_2 = 2(1, 0, 1)^T\end{aligned}\]</span> 故 <span class="math display">\[\begin{aligned}e_1 &amp;= \textbf{e}_{b_1} = \frac{1}{\sqrt{6}} (1,2,-1)^T \\e_2 &amp;= \textbf{e}_{b_2} = \frac{1}{\sqrt{3}}(-1,1,1)^T \\e_3 &amp;= \textbf{e}_{b_3} = \frac{1}{\sqrt{2}}(1,0,1)^T\end{aligned}\]</span> 因此 <span class="math inline">\((a_1, a_2, a_3)\)</span> 标准正交化后的向量组为 <span class="math inline">\((e_1, e_2, e_3)\)</span></p><h2 id="十二">十二</h2><blockquote><p>复现Lec6例13的结果。其中负例为 <span class="math inline">\((1.5,2), (1.7, 1.5), (2,2), (1.5,2.5)\)</span>，正例为 <span class="math inline">\((1,2),(0.3,0.3), (2,1), (1,1)\)</span>，分别采用了欧式距离和曼哈顿距离两种距离度量方式。</p></blockquote><p><strong>实现代码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 数据集</span><br>p=[[<span class="hljs-number">1</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]]<br>n=[[<span class="hljs-number">1.5</span>,<span class="hljs-number">1.7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1.5</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">1.5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2.5</span>]]<br>p=np.array(p)<br>n=np.array(n)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide</span>(<span class="hljs-params">dist,k,X,Y</span>):</span>  <span class="hljs-comment"># dist为一距离函数，k为KNN的参数，(X,Y)为数据的坐标</span><br>    ans_p=[np.sort(dist(p[<span class="hljs-number">0</span>]-X[i],p[<span class="hljs-number">1</span>]-Y[i]))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(X))]<br>    ans_n=[np.sort(dist(n[<span class="hljs-number">0</span>]-X[i],n[<span class="hljs-number">1</span>]-Y[i]))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(X))]<br>    t=[ans_p[i][int((k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)]&gt;ans_n[i][int((k<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(ans_p))]<br>    <span class="hljs-keyword">return</span> np.array(t) <span class="hljs-comment"># 返回分类结果</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dist1</span>(<span class="hljs-params">x,y</span>):</span>  <span class="hljs-comment"># Euclid distance</span><br>    result = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(x)):<br>        result.append(math.sqrt(x[i] * x[i] + y[i] * y[i]))<br>    <span class="hljs-keyword">return</span> np.array(result)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dist2</span>(<span class="hljs-params">x,y</span>):</span>  <span class="hljs-comment"># Manhattan distance</span><br>    <span class="hljs-keyword">return</span> np.abs(x) + np.abs(y)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example_dist</span>(<span class="hljs-params">x,y</span>):</span>  <span class="hljs-comment"># Minkovski distance</span><br>    <span class="hljs-keyword">return</span> np.max([np.abs(x),np.abs(y)],axis=<span class="hljs-number">0</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span>(<span class="hljs-params">dist,k,ax</span>):</span>  <span class="hljs-comment"># 画图</span><br>    N=<span class="hljs-number">200</span>  <span class="hljs-comment"># 在平面上生成 N x N个点</span><br>    X=np.linspace(<span class="hljs-number">-0</span>,<span class="hljs-number">3</span>,N)  <span class="hljs-comment"># 生成横坐标</span><br>    Y=X <span class="hljs-comment"># 生成纵坐标</span><br>    X,Y=np.meshgrid(X,Y)  <span class="hljs-comment"># 生成 N x N个点</span><br>    X=X.reshape(<span class="hljs-number">1</span>,N*N)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 将横坐标化为向量形式</span><br>    Y=Y.reshape(<span class="hljs-number">1</span>,N*N)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 将纵坐标化为向量形式</span><br>    predict=divide(dist, k, X, Y)<br>    ax.contourf(X.reshape(N,N), Y.reshape(N,N), predict.reshape(N,N),<br>                cmap=plt.cm.Spectral,alpha=<span class="hljs-number">0.3</span>)  <span class="hljs-comment"># 此函数将根据预测值和对应坐标生成图像</span><br>    ax.plot(p[<span class="hljs-number">0</span>],p[<span class="hljs-number">1</span>],<span class="hljs-string">&#x27;rx&#x27;</span>)<br>    ax.plot(n[<span class="hljs-number">0</span>],n[<span class="hljs-number">1</span>],<span class="hljs-string">&#x27;bo&#x27;</span>)<br>    plt.text(<span class="hljs-number">0.5</span>,<span class="hljs-number">2.5</span>,<span class="hljs-string">&quot;k=&quot;</span>+str(k))<br>    plt.show()<br><br><br>fig, ax = plt.subplots()<br>plot(dist2, <span class="hljs-number">3</span>, ax)<br></code></pre></td></tr></table></figure><p><strong>输出结果：（欧几里得距离）</strong></p><img src="/2021/04/12/dase-math/dase-math-assignment-3/euclid.png" class="" title="euclid"><p><strong>输出结果：（曼哈顿距离）</strong></p><img src="/2021/04/12/dase-math/dase-math-assignment-3/manhattan.png" class="" title="manhattan">]]></content>
    
    
    <categories>
      
      <category>数据科学数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>DataScience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据科学与工程数学基础 作业2</title>
    <link href="/2021/03/16/dase-math/dase-math-assignment-2/"/>
    <url>/2021/03/16/dase-math/dase-math-assignment-2/</url>
    
    <content type="html"><![CDATA[<h2 id="一">一</h2><blockquote><ol type="1"><li>设 <span class="math inline">\(A, B\)</span> 为两可逆矩阵，令 <span class="math inline">\(X=\begin{pmatrix} O &amp; A \\ B &amp; O \end{pmatrix}\)</span> 求 <span class="math inline">\(X^{-1}\)</span>。</li></ol></blockquote><p>由 <span class="math inline">\(A,B\)</span> 为两可逆矩阵可知 <span class="math inline">\(A, B\)</span> 均为方阵</p><p>设 <span class="math inline">\(A \in M^{m \times m}, B \in M_{n \times n}\)</span></p><p>故由 <span class="math display">\[\begin{pmatrix}O &amp; A \\B &amp; O\end{pmatrix}\begin{pmatrix}O &amp; B^{-1} \\A^{-1} &amp; O\end{pmatrix}= I_{(m+n) \times (m+n)}\]</span></p><p>可知 <span class="math display">\[X^{-1} = \begin{pmatrix}O &amp; B^{-1} \\A^{-1} &amp; O\end{pmatrix}\]</span></p><h2 id="二">二</h2><blockquote><p>求解线性方程组 <span class="math display">\[\begin{pmatrix}1 &amp; 2 &amp; 3 \\2 &amp; -2 &amp; 1 \\3 &amp; -1 &amp; -1\end{pmatrix}\begin{pmatrix}x_1 \\x_2 \\x_3\end{pmatrix}=\begin{pmatrix}6 \\1 \\1\end{pmatrix}\]</span></p></blockquote><p>对原方程组的增广矩阵做行初等变换 <span class="math display">\[\begin{aligned}&amp;\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 6 \\2 &amp; -2 &amp; 1 &amp; 1 \\3 &amp; -1 &amp; -1 &amp; 1\end{pmatrix}\xrightarrow[r_3-3r_1]{r_2-2r_1}\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 6 \\0 &amp; -6 &amp; -5 &amp; -11 \\0 &amp; -7 &amp; -10 &amp; -17\end{pmatrix}\xrightarrow{r_3-2r_2}\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 6 \\0 &amp; -6 &amp; -5 &amp; -11 \\0 &amp; 5 &amp; 0 &amp; 5\end{pmatrix}\xrightarrow{\frac{1}{5}r_3}\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 6 \\0 &amp; -6 &amp; -5 &amp; -11 \\0 &amp; 1 &amp; 0 &amp; 1\end{pmatrix} \\\xrightarrow{r_2 \leftrightarrow r_3}&amp;\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 6 \\0 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; -6 &amp; -5 &amp; -11\end{pmatrix}\xrightarrow[r_3+6r_2]{r_1-2r_2}\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 6 \\0 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; -5 &amp; -5\end{pmatrix}\xrightarrow{-\frac{1}{5}r_3}\begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 6 \\0 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 1\end{pmatrix}\xrightarrow{r_1-3r_3}\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 1\end{pmatrix}\end{aligned}\]</span></p><p>故原方程组的解为 <span class="math inline">\(\begin{pmatrix}x_1 \\ x_2 \\ x_3 \end{pmatrix} = \begin{pmatrix} 1 \\ 1 \\ 1 \end{pmatrix}\)</span></p><h2 id="三">三</h2><blockquote><p>证明：<span class="math inline">\(\mathbb{R}^{m \times m}\)</span> 中的对称矩阵按照矩阵的加法与数乘在数域 <span class="math inline">\(\mathbb{R}\)</span> 上构成一个线性空间。(如果矩阵 <span class="math inline">\(A\)</span> 是对称矩阵，则有 <span class="math inline">\(A^T = A\)</span>。)</p></blockquote><p>记 <span class="math inline">\(R^{m \times m}\)</span> 上对称矩阵的全体为 <span class="math inline">\(S^{m \times m}\)</span></p><p>由 <span class="math inline">\((R^{m \times m}, +, \cdot)\)</span> 为一个 <span class="math inline">\(\mathbb{R}\)</span> 上的线性空间可知</p><p>任取 <span class="math inline">\(M, N, P \in R^{m \times m}, k_1, k_2 \in \mathbb{R}\)</span>，有</p><ul><li><span class="math inline">\(M + N = N + M\)</span></li><li><span class="math inline">\((M + N) + P = M + (N + P)\)</span></li><li>存在 <span class="math inline">\(\textbf{0} \in R^{m \times m}\)</span> 使得 <span class="math inline">\(M + \textbf{0} = M\)</span></li><li>对于任一个 <span class="math inline">\(M\)</span>，存在 <span class="math inline">\(Q \in R^{m \times m}\)</span> 使得 <span class="math inline">\(M + Q = \textbf{0}\)</span></li><li>存在 <span class="math inline">\(1 \in \mathbb{R}\)</span>，使得 <span class="math inline">\(1 \cdot M = M\)</span></li><li><span class="math inline">\((k_1 \cdot k_2) \cdot M = k_1 \cdot (k_2 \cdot M)\)</span></li><li><span class="math inline">\((k_1 + k_2) \cdot M = k_1 \cdot M + k_2 \cdot M\)</span></li><li><span class="math inline">\(k_1 \cdot (M + N) = k_1 \cdot M + k_1 \cdot N\)</span></li></ul><p>由于 <span class="math inline">\(S^{m \times m} \subset R^{m \times m}\)</span>，故 <span class="math inline">\(S^{m \times m}\)</span> 对于矩阵加法及 <span class="math inline">\(\mathbb{R}\)</span> 上的数乘运算同样满足以上性质</p><p>又 <span class="math inline">\(\textbf{0} \in S^{m \times m}\)</span>，且任取 <span class="math inline">\(A = (a_{ij})_{m \times m} \in S^{m \times m}\)</span>，显然 <span class="math inline">\(-A = (-a_{ij})_{m \times m}\in S^{m \times m}\)</span></p><p>因此我们仅需证明 <span class="math inline">\(S^{m \times m}\)</span> 对矩阵加法和数乘封闭即可</p><p>任取 <span class="math inline">\(A, B \in S^{m \times m}, k \in \mathbb{R}\)</span>，其中 <span class="math display">\[A = \begin{pmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\a_{12} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_{1n} &amp; a_{2n} &amp; \cdots &amp; a_{nn}\end{pmatrix},B = \begin{pmatrix}b_{11} &amp; b_{12} &amp; \cdots &amp; b_{1n} \\b_{12} &amp; b_{22} &amp; \cdots &amp; b_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\b_{1n} &amp; b_{2n} &amp; \cdots &amp; b_{nn}\end{pmatrix}\]</span> 则 <span class="math display">\[A+B = \begin{pmatrix}a_{11} + b_{11} &amp; a_{12} + b_{12} &amp; \cdots &amp; a_{1n} + b_{1n} \\a_{12} + b_{12} &amp; b_{22} + b_{22} &amp; \cdots &amp; a_{2n} + b_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_{1n} + b_{1n} &amp; a_{1n} + b_{2n} &amp; \cdots &amp; a_{nn} + b_{nn}\end{pmatrix} \\kA = \begin{pmatrix}ka_{11} &amp; ka_{12} &amp; \cdots &amp; ka_{1n} \\ka_{12} &amp; ka_{22} &amp; \cdots &amp; ka_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ka_{1n} &amp; ka_{2n} &amp; \cdots &amp; ka_{nn}\end{pmatrix}\]</span> 易见 <span class="math inline">\(A+B, kA \in S^{m \times m}\)</span></p><p>故 <span class="math inline">\(R^{m \times m}\)</span> 中的对称矩阵按照矩阵的加法和数乘在数域 <span class="math inline">\(\mathbb{R}\)</span> 上构成一个线性空间</p><h2 id="四">四</h2><blockquote><p>令 <span class="math inline">\(\beta = (1,2,1,1)^T, \alpha_1 = (1,1,1,1)^T, \alpha_2 = (1,1,-1,-1)^T, \alpha_3 = (1,-1,1,-1)^T, \alpha_4 = (1,-1,-1,1)^T\)</span>，试将向量 <span class="math inline">\(\beta\)</span> 表示成 <span class="math inline">\(\alpha_1, \alpha_2, \alpha_3, \alpha_4\)</span> 的线性组合。</p></blockquote><p><span class="math display">\[\begin{aligned}&amp;\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; -1 &amp; -1 &amp; 2 \\1 &amp; -1 &amp; 1 &amp; -1 &amp; 1 \\1 &amp; -1 &amp; -1 &amp; 1 &amp; 1\end{pmatrix}\xrightarrow[\begin{array} .r_3 - r_1 \\ r_4 -r_1 \end{array}]{r_2 - r_1}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; -2 &amp; -2 &amp; 1 \\0 &amp; -2 &amp; 0 &amp; -2 &amp; 0 \\0 &amp; -2 &amp; -2 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow{r_2 \leftrightarrow r_3}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; -2 &amp; 0 &amp; -2 &amp; 0 \\0 &amp; 0 &amp; -2 &amp; -2 &amp; 1 \\0 &amp; -2 &amp; -2 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow[r_4 - r_3]{r_4 - r_2}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; -2 &amp; 0 &amp; -2 &amp; 0 \\0 &amp; 0 &amp; -2 &amp; -2 &amp; 1 \\0 &amp; 0 &amp; 0 &amp; 4 &amp; -1\end{pmatrix} \\&amp;\xrightarrow{\frac{1}{4} \cdot r_4}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; -2 &amp; 0 &amp; -2 &amp; 0 \\0 &amp; 0 &amp; -2 &amp; -2 &amp; 1 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; -\frac{1}{4}\end{pmatrix}\xrightarrow[\begin{array} .r_3 + 2 \cdot r_4 \\ r_2 + 2 \cdot r_4 \end{array}]{r_1 - r_4}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 0 &amp; \frac{5}{4} \\0 &amp; -2 &amp; 0 &amp; 0 &amp; -\frac{1}{2} \\0 &amp; 0 &amp; -2 &amp; 0 &amp; \frac{1}{2} \\0 &amp; 0 &amp; 0 &amp; 1 &amp; -\frac{1}{4}\end{pmatrix}\xrightarrow{-\frac{1}{2} \cdot r_3}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 0 &amp; \frac{5}{4} \\0 &amp; -2 &amp; 0 &amp; 0 &amp; -\frac{1}{2} \\0 &amp; 0 &amp; 1 &amp; 0 &amp; -\frac{1}{4} \\0 &amp; 0 &amp; 0 &amp; 1 &amp; -\frac{1}{4}\end{pmatrix}\xrightarrow{r_1 - r_3} \\&amp;\begin{pmatrix}1 &amp; 1 &amp; 0 &amp; 0 &amp; \frac{3}{2} \\0 &amp; -2 &amp; 0 &amp; 0 &amp; -\frac{1}{2} \\0 &amp; 0 &amp; 1 &amp; 0 &amp; -\frac{1}{4} \\0 &amp; 0 &amp; 0 &amp; 1 &amp; -\frac{1}{4}\end{pmatrix}\xrightarrow{-\frac{1}{2} \cdot r_2}\begin{pmatrix}1 &amp; 1 &amp; 0 &amp; 0 &amp; \frac{3}{2} \\0 &amp; 1 &amp; 0 &amp; 0 &amp; \frac{1}{4} \\0 &amp; 0 &amp; 1 &amp; 0 &amp; -\frac{1}{4} \\0 &amp; 0 &amp; 0 &amp; 1 &amp; -\frac{1}{4}\end{pmatrix}\xrightarrow{r_1 - r_2}\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{5}{4} \\0 &amp; 1 &amp; 0 &amp; 0 &amp; \frac{1}{4} \\0 &amp; 0 &amp; 1 &amp; 0 &amp; -\frac{1}{4} \\0 &amp; 0 &amp; 0 &amp; 1 &amp; -\frac{1}{4}\end{pmatrix}\end{aligned}\]</span></p><p>故 <span class="math display">\[\beta = \frac{5}{4} \alpha_1 + \frac{1}{4} \alpha_2 - \frac{1}{4} \alpha_3 - \frac{1}{4} \alpha_4\]</span></p><h2 id="五">五</h2><blockquote><p>设 <span class="math inline">\(\epsilon_{1}=\left(\begin{array}{l} 1 \\ 1 \\ 1 \\ 1 \end{array}\right), \epsilon_{2}=\left(\begin{array}{c} 1 \\ 1 \\ -1 \\ -1 \end{array}\right), \epsilon_{3}=\left(\begin{array}{c} 1 \\ -1 \\ 1 \\ -1 \end{array}\right), \epsilon_{1}=\left(\begin{array}{c} 1 \\ -1 \\ -1 \\ -1 \end{array}\right), a=\left(\begin{array}{c} 1 \\ 2 \\ -1 \\ 1 \end{array}\right)\)</span>，试求 <span class="math inline">\(a\)</span> 在基 <span class="math inline">\(\epsilon_1, \epsilon_2, \epsilon_3, \epsilon_4\)</span> 下的坐标。</p></blockquote><p><span class="math display">\[\begin{aligned}&amp;\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; -1 &amp; -1 &amp; 2 \\1 &amp; -1 &amp; 1 &amp; -1 &amp; -1 \\1 &amp; -1 &amp; -1 &amp; -1 &amp; 1\end{pmatrix}\xrightarrow[\begin{array} .r_3 - r_1 \\ r_4 -r_1 \end{array}]{r_2 - r_1}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; -2 &amp; -2 &amp; 1 \\0 &amp; -2 &amp; 0 &amp; -2 &amp; -2 \\0 &amp; -2 &amp; -2 &amp; -2 &amp; 0\end{pmatrix}\xrightarrow{r_2 \leftrightarrow r_3}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; -2 &amp; 0 &amp; -2 &amp; -2 \\0 &amp; 0 &amp; -2 &amp; -2 &amp; 1 \\0 &amp; -2 &amp; -2 &amp; -2 &amp; 0\end{pmatrix}\xrightarrow[r_4 - r_3]{r_4 - r_2} \\&amp;\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; -2 &amp; 0 &amp; -2 &amp; -2 \\0 &amp; 0 &amp; -2 &amp; -2 &amp; 1 \\0 &amp; 0 &amp; 0 &amp; 2 &amp; 1\end{pmatrix}\xrightarrow{\frac{1}{2} \cdot r_4}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; -2 &amp; 0 &amp; -2 &amp; -2 \\0 &amp; 0 &amp; -2 &amp; -2 &amp; 1 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; \frac{1}{2}\end{pmatrix}\xrightarrow[\begin{array} .r_2 + 2 \cdot r_4 \\ r_3 + 2 \cdot r_4 \end{array}]{r_1 - r_4}\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 0 &amp; \frac{1}{2} \\0 &amp; -2 &amp; 0 &amp; 0 &amp; -1 \\0 &amp; 0 &amp; -2 &amp; 0 &amp; 2 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; \frac{1}{2}\end{pmatrix}\xrightarrow{-\frac{1}{2} \cdot r_3} \\&amp;\begin{pmatrix}1 &amp; 1 &amp; 1 &amp; 0 &amp; \frac{1}{2} \\0 &amp; -2 &amp; 0 &amp; 0 &amp; -1 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; \frac{1}{2}\end{pmatrix}\xrightarrow{r_1 - r_3}\begin{pmatrix}1 &amp; 1 &amp; 0 &amp; 0 &amp; \frac{3}{2} \\0 &amp; -2 &amp; 0 &amp; 0 &amp; -1 \\0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; \frac{1}{2}\end{pmatrix}\xrightarrow{-\frac{1}{2} \cdot r_2}\begin{pmatrix}1 &amp; 1 &amp; 0 &amp; 0 &amp; \frac{3}{2} \\0 &amp; 1 &amp; 0 &amp; 0 &amp; \frac{1}{2} \\0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; \frac{1}{2}\end{pmatrix}\xrightarrow{r_1 - r_2}\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 0 &amp; 0 &amp; \frac{1}{2} \\0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 \\0 &amp; 0 &amp; 0 &amp; 1 &amp; \frac{1}{2}\end{pmatrix}\end{aligned}\]</span></p><p>故 <span class="math display">\[a = \epsilon_1 + \frac{1}{2} \epsilon_2 - \epsilon_3 + \frac{1}{2} \epsilon_4\]</span> 即 <span class="math inline">\(a\)</span> 在基 <span class="math inline">\(\epsilon_1, \epsilon_2, \epsilon_3, \epsilon_4\)</span> 下的坐标为 <span class="math display">\[(1, \frac{1}{2}, -1, \frac{1}{2})\]</span></p><h2 id="六">六</h2><blockquote><p>记数域 <span class="math inline">\(\mathbb{R}\)</span> 上的对称矩阵按照矩阵的加法与数乘构成的线性空间为 <span class="math inline">\(V\)</span>。证明：映射 <span class="math inline">\(\sigma_{Q}: V \rightarrow V, \sigma_{Q}(A)=Q^{T} A Q\)</span> 为线性映射。其中 <span class="math inline">\(Q\)</span> 为正交矩阵，即 <span class="math inline">\(Q^T Q = I\)</span>。</p></blockquote><p>任取 <span class="math inline">\(A,B \in V, k_1, k_2 \in \mathbb{R}\)</span> <span class="math display">\[\begin{aligned}\sigma_Q(k_1 \cdot A + k_2 \cdot B) &amp;= Q^T (k_1 \cdot A + K_2 \cdot B) Q \\&amp;=k_1 \cdot Q^TAQ + k_2 \cdot Q^TBQ \\&amp;=k_1 \cdot \sigma_Q(A) + k_2 \cdot \sigma_Q(B)\end{aligned}\]</span> 故映射 <span class="math inline">\(\sigma_Q\)</span> 对 <span class="math inline">\(V\)</span> 中的两种运算保持不变</p><p>由此可知，<span class="math inline">\(\sigma_Q: V \to V, \sigma_Q(A)=Q^TAQ\)</span> 为线性映射</p><h2 id="七">七</h2><blockquote><p>求矩阵 <span class="math inline">\(A=\left(\begin{array}{ccc} 1 &amp; 1 &amp; -1 \\ 1 &amp; 0 &amp; 1 \\ -1 &amp; 1 &amp; 0 \end{array}\right)\)</span> 对应二次型的标准型。</p></blockquote><p>矩阵 <span class="math inline">\(A\)</span> 对应的二次型为 <span class="math inline">\(f = x_1^2 + 2x_1x_2 -2x_1x_3+2x_2x_3\)</span></p><p>下用配方法将其化为标准型 <span class="math display">\[\begin{aligned}f(x_1,x_2,x_3) &amp;= x_1^2 + 2x_1x_2 -2x_1x_3+2x_2x_3 \\&amp;=(x_1+x_2-x_3)^2 - 4x_2x_3-x_2^2-x_3^2 \\&amp;=(x_1+x_2-x_3)^2-(x_2+2x_3)^2+3x_3^2\end{aligned}\]</span> 令 <span class="math display">\[\left\{\begin{aligned}&amp;y_1 = x_1+x_2-x_3 \\&amp;y_2 = x_2+2x_3 \\&amp;y_3 = x_3\end{aligned}\right.\]</span> 解得 <span class="math display">\[\left\{\begin{aligned}&amp;x_1 = y_1-y_2+3y_3 \\&amp;x_2 = y_2-2y_3 \\&amp;x_3 = y_3\end{aligned}\right.\]</span> 由此可得标准型为 <span class="math inline">\(f = y_1^2-y_2^2+3y_3^2\)</span>，所用变换矩阵为 <span class="math display">\[C=\begin{pmatrix}1 &amp; -1 &amp; 3 \\0 &amp; 1 &amp; -2 \\0 &amp; 0 &amp; 1\end{pmatrix}\]</span></p><h2 id="八">八</h2><blockquote><p>试判断下列哪些矩阵是正定矩阵。 <span class="math display">\[A_{1}=\left(\begin{array}{ll}2 &amp; 1 \\1 &amp; 1\end{array}\right) \quad A_{2}=\left(\begin{array}{llll}5 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 4 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 7 &amp; 2 \\0 &amp; 0 &amp; 2 &amp; 4\end{array}\right) \quad A_{3}=\left(\begin{array}{ll}2 &amp; 3 \\3 &amp; 1\end{array}\right) \quad A_{4}=\left(\begin{array}{lll}2 &amp; 3 &amp; 1 \\3 &amp; 1 &amp; 2 \\1 &amp; 2 &amp; 1\end{array}\right)\]</span></p></blockquote><p>由 <span class="math display">\[D_{11} = 2 &gt;0,D_{12} = \begin{vmatrix}2 &amp; 1 \\1 &amp; 1\end{vmatrix}=1 &gt; 0\]</span> 可知 <span class="math inline">\(A_1 = \begin{pmatrix} 2 &amp; 1 \\ 1 &amp; 1\end{pmatrix}\)</span> 的顺序主子式均大于0，因此 <span class="math inline">\(A_1\)</span> 是正定矩阵</p><p>由 <span class="math display">\[D_{21} = 5 &gt; 0,D_{22} = \begin{vmatrix}5 &amp; 1 \\1 &amp; 4\end{vmatrix} = 19 &gt; 0,D_{23} = \begin{vmatrix}5 &amp; 1 &amp; 0 \\1 &amp; 4 &amp; 0 \\0 &amp; 0 &amp; 7\end{vmatrix} = 133 &gt; 0,D_{24} = \begin{vmatrix}5 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 4 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 7 &amp; 2 \\0 &amp; 0 &amp; 2 &amp; 4\end{vmatrix} = 456 &gt; 0\]</span> 可知 <span class="math inline">\(A_2 = \begin{pmatrix} 5 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 4 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 7 &amp; 2 \\ 0 &amp; 0 &amp; 2 &amp; 4 \end{pmatrix}\)</span> 的顺序主子式均大于0，因此 <span class="math inline">\(A_2\)</span> 是正定矩阵</p><p>由 <span class="math display">\[D_{32} = \begin{vmatrix}2 &amp; 3 \\3 &amp; 1\end{vmatrix}=-7 &lt; 0\]</span> 可知 <span class="math inline">\(A_3 = \begin{pmatrix} 2 &amp; 3 \\ 3 &amp; 1 \end{pmatrix}\)</span> 的顺序主子式不全大于0，因此 <span class="math inline">\(A_3\)</span> 不是正定矩阵</p><p>由 <span class="math display">\[D_{42} = \begin{vmatrix}2 &amp; 3 \\3 &amp; 1\end{vmatrix}=-7 &lt; 0\]</span> 可知 <span class="math inline">\(A_4 = \begin{pmatrix} 2 &amp; 3 &amp; 1\\ 3 &amp; 1 &amp; 2 \\ 1 &amp; 2 &amp; 1\end{pmatrix}\)</span> 的顺序主子式不全不大于0，因此 <span class="math inline">\(A_4\)</span> 不是正定矩阵</p><h2 id="九">九</h2><blockquote><p>求矩阵 <span class="math inline">\(A = \begin{pmatrix} 1 &amp; 4 &amp; 2 \\ 0 &amp; -3 &amp; 4 \\ 0 &amp; 4 &amp; 3 \end{pmatrix}\)</span> 的特征值与对应的特征向量。</p></blockquote><p>由 <span class="math display">\[\begin{aligned}|\lambda I - A | &amp;= \begin{vmatrix}\lambda -1  &amp; -4 &amp; -2 \\0 &amp; \lambda + 3 &amp; -4 \\0 &amp; -4 &amp; \lambda - 3\end{vmatrix} \\&amp;= (\lambda - 1)(\lambda + 3)(\lambda - 3) - 16(\lambda - 1) \\&amp;=(\lambda-1)(\lambda-5)(\lambda+5) = 0\end{aligned}\]</span> 解得 <span class="math inline">\(\lambda_1 = 1, \lambda_2 = 5, \lambda_3 = -5\)</span></p><p>对于 <span class="math inline">\(\lambda_1 = 1\)</span> <span class="math display">\[\begin{aligned}\begin{pmatrix}0 &amp; -4 &amp; -2 \\0 &amp; 4 &amp; -4 \\0 &amp; -4 &amp; -2\end{pmatrix}\xrightarrow[r_3-r_1]{r_2+r_1}\begin{pmatrix}0 &amp; -4 &amp; -2 \\0 &amp; 0 &amp; -6 \\0 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow{-\frac{1}{6} \cdot r_2}\begin{pmatrix}0 &amp; -4 &amp; -2 \\0 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow{r_1+2 \cdot r_2}\begin{pmatrix}0 &amp; -4 &amp; 0 \\0 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow{-\frac{1}{4} \cdot r_1}\begin{pmatrix}0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 0\end{pmatrix}\end{aligned}\]</span> 因此 <span class="math inline">\(\alpha_1 = (1,0,0)^T\)</span>，<span class="math inline">\(A\)</span> 的属于 <span class="math inline">\(\lambda_1\)</span> 的特征向量全体为 <span class="math inline">\(k_1 \alpha_1 (k_1 \neq 0\in \mathbb{R})\)</span></p><p>对于 <span class="math inline">\(\lambda_2 = 5\)</span> <span class="math display">\[\begin{aligned}\begin{pmatrix}4 &amp; -4 &amp; -2 \\0 &amp; 8 &amp; -4 \\0 &amp; -4 &amp; 2\end{pmatrix}\xrightarrow{\frac{1}{4} \cdot r_2}\begin{pmatrix}4 &amp; -4 &amp; -2 \\0 &amp; 2 &amp; -1 \\0 &amp; -4 &amp; 2\end{pmatrix}\xrightarrow[r_3+2 \cdot r_2]{r_1 + 2 \cdot r_2}\begin{pmatrix}4 &amp; 0 &amp; -4 \\0 &amp; 2 &amp; -1 \\0 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow[\frac{1}{2} \cdot r_2]{\frac{1}{4} \cdot r_1}\begin{pmatrix}1 &amp; 0 &amp; -1 \\0 &amp; 1 &amp; -\frac{1}{2} \\0 &amp; 0 &amp; 0\end{pmatrix}\end{aligned}\]</span> 因此 <span class="math inline">\(\alpha_2 = (2,1,2)^T\)</span>，<span class="math inline">\(A\)</span> 的属于 <span class="math inline">\(\lambda_2\)</span> 的特征向量全体为 <span class="math inline">\(k_2\alpha_2(k_2 \neq 0 \in \mathbb{R})\)</span></p><p>对于 <span class="math inline">\(\lambda_3 = -5\)</span> <span class="math display">\[\begin{aligned}\begin{pmatrix}-6 &amp; -4 &amp; -2 \\0 &amp; -2 &amp; -4 \\0 &amp; -4 &amp; -8\end{pmatrix}\xrightarrow[r_3 - 2 \cdot r_2]{r_1 - 2 \cdot r_2}\begin{pmatrix}-6 &amp; 0 &amp; 6 \\0 &amp; -2 &amp; -4 \\0 &amp; 0 &amp; 0\end{pmatrix}\xrightarrow[-\frac{1}{2} \cdot r_2]{-\frac{1}{6} r_1}\begin{pmatrix}1 &amp; 0 &amp; -1 \\0 &amp; 1 &amp; 2 \\0 &amp; 0 &amp; 0\end{pmatrix}\end{aligned}\]</span> 因此 <span class="math inline">\(\alpha_3 = (1,-2,1)^T\)</span>，<span class="math inline">\(A\)</span> 的属于 <span class="math inline">\(\lambda_3\)</span> 的特征向量全体为 <span class="math inline">\(k_3\alpha_3 (k_3 \neq 0 \in \mathbb{R})\)</span></p><h2 id="十">十</h2><blockquote><p>设已知 <span class="math inline">\(A = \begin{pmatrix} 2 &amp; 1 &amp; 1 \\ 1 &amp; 2 &amp; 1 \\ 1 &amp; 1 &amp; 2 \end{pmatrix}\)</span>，且 <span class="math inline">\(x = \begin{pmatrix} 1 \\ k \\ 1 \end{pmatrix}\)</span>是矩阵 <span class="math inline">\(A^{-1}\)</span> 的一个特征向量，求 <span class="math inline">\(k\)</span>。</p></blockquote><p>设 <span class="math inline">\(x = (1,k,1)^T\)</span> 为 <span class="math inline">\(A^{-1}\)</span> 属于 <span class="math inline">\(\lambda_0\)</span> 的一个特征向量</p><p>则 <span class="math inline">\(x\)</span> 为 <span class="math inline">\(A\)</span> 属于 <span class="math inline">\(\frac{1}{\lambda_0}\)</span> 的一个特征向量</p><p>由 <span class="math display">\[\begin{aligned}|\lambda I - A | &amp;= \begin{vmatrix}\lambda -2  &amp; -1 &amp; -1 \\-1 &amp; \lambda -2 &amp; -1 \\-1 &amp; -1 &amp; \lambda - 2\end{vmatrix} =(\lambda-4)(\lambda-1)^2\end{aligned}\]</span> 可知 <span class="math inline">\(\lambda_1 = 4\)</span>，<span class="math inline">\(\lambda_2 = 1\)</span>（二重根）</p><p>对于 <span class="math inline">\(\lambda_1 = 4\)</span> <span class="math display">\[\begin{pmatrix}2 &amp; -1 &amp; -1 \\-1 &amp; 2 &amp; -1 \\-1 &amp; -1 &amp; 2\end{pmatrix}\rightarrow\begin{pmatrix}1 &amp; 0 &amp; -1 \\0 &amp; 1 &amp; -1 \\0 &amp; 0 &amp; 0\end{pmatrix}\]</span> 解得 <span class="math inline">\(\alpha_1 = (1, 1, 1)^T\)</span>，<span class="math inline">\(A\)</span> 的属于 <span class="math inline">\(\lambda_1\)</span> 的特征向量的全体构成的集合为 <span class="math inline">\(E_1 = \{k_1 \alpha_1 : k_1 \neq 0 \in \mathbb{R} \}\)</span></p><p>若 <span class="math inline">\(x \in E_1\)</span>，则 <span class="math inline">\(k=1\)</span></p><p>对于 <span class="math inline">\(\lambda_2 = 1\)</span> <span class="math display">\[\begin{pmatrix}-1 &amp; -1 &amp; -1 \\-1 &amp; -1 &amp; -1 \\-1 &amp; -1 &amp; -1\end{pmatrix}\rightarrow\begin{pmatrix}1 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 0\end{pmatrix}\]</span> 解得 <span class="math inline">\(\alpha_2 = (-1,0,1)^T, \alpha_3 = (-1,1,0)^T\)</span>，<span class="math inline">\(A\)</span> 的属于 <span class="math inline">\(\lambda_2\)</span> 的特征向量的全体构成的集合为 <span class="math inline">\(E_2 = \{k_2\alpha_2 + k_3 \alpha_3 : k_2,k_3 \in \mathbb{R} \land (k_2\neq 0 \lor k_3 \neq 0)\}\)</span></p><p>若 <span class="math inline">\(x \in E_2\)</span>，则 <span class="math inline">\(k=-2\)</span></p><h2 id="十一">十一</h2><blockquote><p>使用Python将一张图片旋转一定⻆度。 提交时需要提交原来的图片和旋转后的图片以及补全的代码。</p></blockquote><p>原图片：</p><img src="/2021/03/16/dase-math/dase-math-assignment-2/origin.jpg" class="" title="origin"><p>逆时针旋转：</p><img src="/2021/03/16/dase-math/dase-math-assignment-2/fig1.jpg" class="" title="fig1"><p>顺时针旋转：</p><img src="/2021/03/16/dase-math/dase-math-assignment-2/fig2.jpg" class="" title="fig2"><p>实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>matplotlib.use(<span class="hljs-string">&quot;TkAgg&quot;</span>)<br>img_origin = Image.open(<span class="hljs-string">&#x27;origin.jpg&#x27;</span>)<br>img_origin = img_origin.convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)<br>img = np.array(img_origin)<br>theta = <span class="hljs-number">30</span>/<span class="hljs-number">180</span>*np.pi<br>cos_theta = np.cos(theta)<br>sin_theta = np.sin(theta)<br>center_i = len(img)/<span class="hljs-number">2</span><br>center_j = len(img[<span class="hljs-number">0</span>])/<span class="hljs-number">2</span><br>imgr = np.zeros_like(img)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(img)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(img[<span class="hljs-number">0</span>])):<br>        yi = int(cos_theta * (i - center_i) - sin_theta * (j - center_j) + center_i)<br>        yj = int(sin_theta * (i - center_i) + cos_theta * (j - center_j) + center_j)<br>        <span class="hljs-keyword">if</span> yi &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> yj &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> yi &gt;= len(img) <span class="hljs-keyword">or</span> yj &gt;= len(img[<span class="hljs-number">0</span>]):<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>            imgr[yi][yj][k] = img[i][j][k]<br>plt.imshow(imgr)<br>plt.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>plt.savefig(<span class="hljs-string">&#x27;fig1.jpg&#x27;</span>)<br>plt.clf()<br>imgR = np.zeros_like(img)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(img)):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(img[<span class="hljs-number">0</span>])):<br>        xi = int(cos_theta * (i - center_i) + sin_theta * (j - center_j) + center_i)<br>        xj = int(-sin_theta * (i - center_i) + cos_theta * (j - center_j) + center_j)<br>        <span class="hljs-keyword">if</span> xi &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> xj &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> xi &gt;= len(img) <span class="hljs-keyword">or</span> xj &gt;= len(img[<span class="hljs-number">0</span>]):<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>            imgR[xi][xj][k] = img[i][j][k]<br>plt.imshow(imgR)<br>plt.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>plt.savefig(<span class="hljs-string">&#x27;fig2.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据科学数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>DataScience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据科学与工程数学基础 作业1</title>
    <link href="/2021/03/12/dase-math/dase-math-assignment-1/"/>
    <url>/2021/03/12/dase-math/dase-math-assignment-1/</url>
    
    <content type="html"><![CDATA[<h2 id="一">一</h2><blockquote><p>卷积神经网络是一类典型的处理图像的模型，其中卷积是其中一种非常重要的函数操作。试计算下列输入和卷积核做卷积的结果。（注意：此处卷积操作无需旋转180度） <span class="math display">\[\textrm{Input} =\begin{pmatrix}1 &amp; 3 &amp; 0 &amp; -1 \\3 &amp; 0 &amp; -1 &amp; 2 \\1 &amp; -1 &amp; 2 &amp; 0\end{pmatrix},\textrm{Kernel} = \begin{pmatrix}-1 &amp; 1 \\-1 &amp; 1\end{pmatrix}\]</span></p></blockquote><p>由卷积运算公式可知 <span class="math display">\[\begin{aligned}output_{11} &amp;= 1 \cdot (-1) + 3 \cdot 1 + 3 \cdot (-1) + 0 \cdot 1 = -1 \\output_{12} &amp;= 3 \cdot (-1) + 0 \cdot 1 + 0 \cdot (-1) + (-1) \cdot 1 = -4 \\output_{13} &amp;= 0 \cdot (-1) + (-1) \cdot 1 + (-1) \cdot (-1) + 2 \cdot 1 = 2 \\output_{21} &amp;= 3 \cdot (-1) + 0 \cdot 1 + 1 \cdot (-1) + (-1) \cdot 1 = -5 \\output_{22} &amp;= 0 \cdot (-1) + (-1) \cdot 1 + (-1) \cdot (-1) + 2 \cdot 1 = 2 \\output_{23} &amp;= (-1) \cdot (-1) + 2 \cdot 1 + 2 \cdot (-1) + 0 \cdot 1 = 1 \\\end{aligned}\]</span></p><p>故 <span class="math display">\[\textrm{Output} = \begin{pmatrix}-1 &amp; -4 &amp; 2 \\-5 &amp; 2 &amp; 1\end{pmatrix}\]</span></p><h2 id="二">二</h2><blockquote><p>现有一组图片数据集，任务目标是将这些图片分类。其中图片中包含的类别有：猫、狗、鹦鹉、人。试用One-Hot向量将类别表示为向量。</p></blockquote><p><span class="math display">\[\begin{aligned}猫 &amp;\xlongequal{def} [1,0,0,0]^T \\狗 &amp;\xlongequal{def} [0,1,0,0]^T \\鹦鹉 &amp;\xlongequal{def} [0,0,1,0]^T \\人 &amp;\xlongequal{def} [0,0,0,1]^T\end{aligned}\]</span></p><h2 id="三">三</h2><blockquote><p>现有文本集（一行为一个文本）如下。试计算，该文本集中各个单词（不区分大小写）在各文本中的TF-IDF值。</p><figure class="highlight erlang"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs erlang">I know.<br>You know.<br>I know that you know.<br>I know that you know that I know.<br></code></pre></td></tr></table></figure></blockquote><p>首先计算整个文档中各个词语的IDF值 <span class="math display">\[\begin{aligned}IDF_{(I)} &amp;= \ln \frac{4}{3} \\IDF_{(know)} &amp;= \ln \frac{4}{4} = 0 \\IDF_{(you)} &amp;= \ln \frac{4}{3} \\IDF_{(that)} &amp;= \ln \frac{4}{2} = \ln 2\end{aligned}\]</span></p><p>随后分别计算各个文档中各个词语的TF值 <span class="math display">\[TF_{(I,1)} = \frac{1}{2} , TF_{(know,1)} = \frac{1}{2} \\TF_{(you,2)} = \frac{1}{2} , TF_{(know,2)} = \frac{1}{2} \\TF_{(I,3)} = \frac{1}{5} , TF_{(you,3)} = \frac{1}{5},TF_{(know,3)} = \frac{2}{5} , TF_{(that,2)} = \frac{1}{5} \\TF_{(I,4)} = \frac{1}{4} , TF_{(you,4)} = \frac{1}{8},TF_{(know,4)} = \frac{3}{8} , TF_{(that,4)} = \frac{1}{4}\]</span> 由此可得各个单词在各文本中的TF-IDF值 <span class="math display">\[TF-IDF_{(I,1)} = \frac{1}{2} \cdot \ln \frac{4}{3} \approx 0.1438 \\TF-IDF_{(know,1)} = \frac{1}{2} \cdot 0 = 0 \\TF-IDF_{(you,2)} = \frac{1}{2} \cdot \ln \frac{4}{3} \approx 0.1438 \\TF-IDF_{(know,2)} = \frac{1}{2} \cdot 0 = 0 \\TF-IDF_{(I,3)} = \frac{1}{5} \cdot \ln \frac{4}{3} \approx 0.0575 \\TF-IDF_{(you,3)} = \frac{1}{5} \cdot \ln \frac{4}{3} \approx 0.0575 \\TF-IDF_{(know,3)} = \frac{2}{5} \cdot 0 = 0 \\TF-IDF_{(that,3)} = \frac{1}{5} \cdot \ln 2 \approx 0.1386 \\TF-IDF_{(I,4)} = \frac{1}{4} \cdot \ln \frac{4}{3} \approx 0.0719 \\TF-IDF_{(you,4)} = \frac{1}{8} \cdot \ln \frac{4}{3} \approx 0.0360 \\TF-IDF_{(know,4)} = \frac{3}{8} \cdot 0 = 0 \\TF-IDF_{(that,4)} = \frac{1}{4} \cdot \ln 2 \approx 0.1733 \\\]</span></p><h2 id="四">四</h2><blockquote><p>现有一个数据集有5个数据，分别被分类在 <span class="math inline">\((0,1)^T, (0,1)^T, (0,1)^T, (1,0)^T, (1,0)^T\)</span>，而一个模型给出的评分分别为 <span class="math inline">\((2,8)^T, (1,9)^T, (3,2)^T, (1,5)^T, (2,0)^T\)</span>，试给出此时模型给各个数据的概率评分以及交叉熵损失的值。</p></blockquote><p>由 <span class="math display">\[Softmax(x_i) = \frac{e^{x_i}}{\sum_\limits{j=1}^n e^{x_j}}\]</span></p><p>可知各个数据的概率评分为 <span class="math display">\[\begin{aligned}&amp;\begin{pmatrix}e^2/(e^2+e^8) \\e^8/(e^2+e^8)\end{pmatrix},\begin{pmatrix}e^1/(e^1+e^9) \\e^9/(e^1+e^9)\end{pmatrix},\begin{pmatrix}e^3/(e^3+e^2) \\e^2/(e^3+e^2)\end{pmatrix},\begin{pmatrix}e^1/(e^1+e^5) \\e^5/(e^1+e^5)\end{pmatrix},\begin{pmatrix}e^2/(e^2+e^0) \\e^0/(e^2+e^0)\end{pmatrix} \\\approx&amp;\begin{pmatrix}0.0025 \\0.9975\end{pmatrix},\begin{pmatrix}0.0003 \\0.9997\end{pmatrix},\begin{pmatrix}0.7311 \\0.2689\end{pmatrix},\begin{pmatrix}0.0180 \\0.9820\end{pmatrix},\begin{pmatrix}0.8808 \\0.1192\end{pmatrix}\end{aligned}\]</span></p><p>又由交叉熵损失计算公式 <span class="math display">\[L=-\sum_{c=1}^K y_c \log (p_c)\]</span> 可知各个数据的交叉熵损失为 <span class="math display">\[L_1 = - (0 \cdot \log 0.0025 + 1 \cdot \log 0.9975) \approx 0.0036 \\L_2 = - (0 \cdot \log 0.0003 + 1 \cdot \log 0.9997) \approx 0.0004 \\L_3 = - (0 \cdot \log 0.7311 + 1 \cdot \log 0.2689) \approx 1.8949 \\L_4 = - (1 \cdot \log 0.0180 + 0 \cdot \log 0.9820) \approx 5.7959 \\L_5 = - (1 \cdot \log 0.8808 + 0 \cdot \log 0.1192) \approx 0.1831\]</span></p><h2 id="五">五</h2><blockquote><p>设数据集为 <span class="math inline">\(x_1, x_2, \cdots, x_n\)</span> 其中被分为两类 <span class="math inline">\(y_1, y_2\)</span>。如果使用线性分类器，试给出一个考虑结构风险的损失函数的公式。</p></blockquote><p>线性分类器的评分函数可表示为（使用<strong>Softmax</strong>作为概率评分函数） <span class="math display">\[f(W,b,\textbf{x}) = Softmax(W \textbf{x} + b)\]</span></p><p>若使用交叉熵作为基础损失函数，使用 <span class="math inline">\(L_2\)</span> 范数作为正则化项，则最终的损失函数可以定义为 <span class="math display">\[J =-  \sum_{i = 1}^2 y_c \log (p_c) + \lambda ||\textbf{W}||_2^2\]</span> 其中 <span class="math inline">\(y_c\)</span> 为分类结果指示函数，<span class="math inline">\(p_c\)</span> 为模型给出当前分类的概率评分</p><h2 id="六">六</h2><blockquote><p>利用Python将一张黑白图片或彩色图片转化为矩阵或张量，并使图片水平翻转。</p></blockquote><p>翻转结果：</p><img src="/2021/03/12/dase-math/dase-math-assignment-1/merged.png" class="" title="merged"><p>实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>origin_path = <span class="hljs-string">&#x27;origin.jpg&#x27;</span><br>image = Image.open(origin_path)<br>tensor = np.asarray(image)<br>tensor_flipped = np.flip(tensor, <span class="hljs-number">1</span>)<br>image_flipped = Image.fromarray(tensor_flipped)<br>image_flipped = image_flipped.convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)<br>image_flipped.save(<span class="hljs-string">&#x27;flipped.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据科学数学基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>DataScience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验 Shell及系统调用</title>
    <link href="/2021/03/02/os/os-exp-shell/"/>
    <url>/2021/03/02/os/os-exp-shell/</url>
    
    <content type="html"><![CDATA[<h2 id="this-page-is-temporarily-forbidden-for-the-course-regulation.">This page is temporarily forbidden for the course regulation.</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Operating-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实数集不可数的证明</title>
    <link href="/2021/02/27/math-analysis/real-number-uncountability/"/>
    <url>/2021/02/27/math-analysis/real-number-uncountability/</url>
    
    <content type="html"><![CDATA[<p>实数集是不可数集这一结论的证明是近代集合论研究的一大重要标志。随着近代分析学的发展，这一结论可以从许多不同的角度推导而出。这些方法融合了许多重要的分析思想及数学技巧，在此进行一个简单的整理和总结。</p><a id="more"></a><blockquote><p><strong>Theorem:</strong> 实数集 <span class="math display">\[\mathbb{R}\]</span> 不可数</p></blockquote><h2 id="对角线法">对角线法</h2><p>若 <span class="math display">\[\mathbb{R}\]</span> 可数，则区间 <span class="math display">\[[0,1] \subset \mathbb{R}\]</span> 必然可数</p><p>因此必然可以使用十进制表示法将 <span class="math display">\[[0,1]\]</span> 中的每一个数一一列出： <span class="math display">\[r_1 = 0.d_{11} d_{12} d_{13} d_{14} ... \\r_2 = 0.d_{21} d_{22} d_{23} d_{24} ... \\r_3 = 0.d_{31} d_{32} d_{33} d_{34} ... \\r_4 = 0.d_{41} d_{42} d_{43} d_{44} ... \\...\]</span> 其中 <span class="math display">\[d_{ij} \in \{0, 1, 2, ..., 9\}\]</span></p><p>现构造一新的实数 <span class="math display">\[r = 0.d_1 d_2 d_3 d_4 ...\]</span>，使得 <span class="math display">\[d_i = \left\{\begin{aligned}4, \ if \ d_{ii} \neq 4 \\5, \ if \ d_{ii} = 4\end{aligned}\right.\]</span> 显然 <span class="math display">\[r \in [0, 1]\]</span></p><p>而由于对任意 <span class="math display">\[i \in \mathbb{N}^+\]</span>，<span class="math display">\[r\]</span> 与 <span class="math display">\[r_i\]</span> 的第 <span class="math display">\[i\]</span> 位数字均不相同，因此 <span class="math display">\[r \neq r_i\]</span></p><p>由此我们构造出了一个未被列出的实数，这与 <span class="math display">\[[0,1]\]</span> 中的每一个数均可被列出矛盾</p><p>故 <span class="math display">\[[0,1]\]</span> 为不可数集，进而可知 <span class="math display">\[\mathbb{R}\]</span> 为不可数集。</p><h2 id="区间套法">区间套法</h2><blockquote><p><strong>Lemma:</strong> 若 <span class="math display">\[\{[a_n, b_n]\}\]</span> 形成一闭区间套，则存在唯一的实数 <span class="math display">\[\xi\]</span> 属于所有的闭区间 <span class="math display">\[[a_n, b_n]\]</span>，且 <span class="math display">\[\xi = \lim_\limits{n \to \infty} a_n = \lim_\limits{n \to \infty} b_n\]</span></p></blockquote><p>若 <span class="math display">\[\mathbb{R}\]</span> 可数，则区间 <span class="math display">\[[0,1] \subset \mathbb{R}\]</span> 必然可数</p><p>因此我们可将 <span class="math display">\[[0,1]\]</span> 写为一数列 <span class="math display">\[r_1, r_2, ...,r_n,...\]</span></p><p>现将 <span class="math display">\[[0,1]\]</span> 三等分，则必存在某个区间 <span class="math display">\[[a_1, b_1] \subset [0,1]\]</span>，使得 <span class="math display">\[r_1 \notin [a_1, b_1]\]</span></p><p>接着继续将 <span class="math display">\[[a_1, b_1]\]</span> 三等分，则必存在某一子区间 <span class="math display">\[[a_2, b_2] \subset [a_1, b_1]\]</span>，使得 <span class="math display">\[r_2 \notin [a_2, b_2]\]</span></p><p>如此进行下去，可得一闭区间套 <span class="math display">\[\{[a_n, b_n]\}\]</span>，且满足对任意 <span class="math display">\[i \in \mathbb{N^+}\]</span>，有 <span class="math display">\[r_i \notin [a_i, b_i]\]</span></p><p>故由<strong>闭区间套定理</strong>可知，存在 <span class="math display">\[\xi \in \mathbb{R}\]</span>，使得对任意 <span class="math display">\[n \in \mathbb{N^+}\]</span>，有 <span class="math display">\[\xi \in [a_n, b_n]\]</span></p><p>于是存在 <span class="math display">\[\xi \in [0,1]\]</span>，使得对任意 <span class="math display">\[i \in \mathbb{R}^+\]</span>，有 <span class="math display">\[\xi \neq r_i\]</span>，与 <span class="math display">\[[0,1]\]</span> 中每一个数均可被列出矛盾</p><p>故 <span class="math display">\[[0,1]\]</span> 为不可数集，进而可知 <span class="math display">\[\mathbb{R}\]</span> 为不可数集。</p><h2 id="外测度法">外测度法</h2><p>对于 <span class="math display">\[\mathbb{R}\]</span> 上的任意闭区间 <span class="math display">\[I=[a,b]\]</span>，其体积 <span class="math display">\[V(I)=b-a\]</span></p><p>故由外测度定义 <span class="math display">\[m(S) = \inf \{ \sum_{i=1}^\infty V(I_i) \big| S \subset \bigcup_{i \in \mathbb{N}} I_i \}\]</span> 可知 <span class="math display">\[m(I) = b-a\]</span></p><p>而对任意可数集 <span class="math display">\[S\]</span>，<span class="math display">\[m(S) = 0\]</span></p><p>因此 <span class="math display">\[\mathbb{R}\]</span> 不可数</p><h2 id="baire纲定理">Baire纲定理</h2><blockquote><p>Lemma: 设 <span class="math display">\[(X, d)\]</span> 是一个完备的度量空间，则</p><ol type="1"><li>若 <span class="math display">\[(F_n)_{n=0}^\infty\]</span> 是一列无处稠密的闭集，则它的并的内部是空的</li><li>若 <span class="math display">\[(O_n))_{n=0}^\infty\]</span> 是一列在 <span class="math display">\[X\]</span> 中稠密的开集，则它的交在也 <span class="math display">\[X\]</span> 中稠密</li></ol></blockquote><p>Baire纲定理指出，一个完备的度量空间不能写成可数个无处稠密的集合的并</p><p>由于 <span class="math display">\[\mathbb{R}\]</span> 是完备的，且在其上有自然度量 <span class="math display">\[d(x,y) = |x-y|\]</span>，因此其为一个完备的度量空间</p><p>若 <span class="math display">\[\mathbb{R}\]</span> 可数，则其可以表示为可数个单点集的并，而单点集的闭包即为它本身，也即是无处稠密的</p><p>这与Baire纲定理矛盾，因此 <span class="math display">\[\mathbb{R}\]</span> 必不可数</p>]]></content>
    
    
    <categories>
      
      <category>分析学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>Analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell Lab实验记录</title>
    <link href="/2021/01/29/computer-system/csapp-shlab/"/>
    <url>/2021/01/29/computer-system/csapp-shlab/</url>
    
    <content type="html"><![CDATA[<p>简单来说就是用C语言以及各种系统调用实现一个简单的Unix Shell，说的更直白点就是把CSAPP书上第八章提到的关于Shell的内容全部实现一遍，因此最快的办法应该就是先搭一个基本的框架出来，然后跟着trace的要求把功能一个个补齐。</p><a id="more"></a><h2 id="概览">概览</h2><p>首先我们来看一下Lab的具体要求和操作流程。</p><p>在Lab下的<strong>tsh.c</strong>文件里给出了一个Shell的基本框架，我们的任务就是要完成如下几个函数的具体实现：</p><ul><li><p><strong>eval</strong>：解析并执行用户输入的命令</p></li><li><p><strong>builtin_cmd</strong>：识别并解析Shell的内置函数</p></li><li><p><strong>do_bgfg</strong>：内置函数bg和fg的功能实现</p></li><li><p><strong>waitfg</strong>：等待前台任务完成</p></li><li><p><strong>sigchld_handler</strong>：SIGCHLD信号处理</p></li><li><p><strong>sigint_handler</strong>：SIGINT信号处理</p></li><li><p><strong>sigstp_handler</strong>：SIGSTP信号处理</p></li></ul><p>其中，内置函数包括如下几个：</p><ul><li><strong>quit</strong>：结束当前的Shell进程</li><li><strong>jobs</strong>：列出所有当前的后台任务</li><li><strong>bg &lt;jobs&gt;</strong>：向被挂起的前台任务发送SIGCONT信号，并将其转到后台运行</li><li><strong>fg &lt;jobs&gt;</strong>：向被挂起的后台任务发送SIGCONT信号，并将其转到前台运行</li></ul><p>任务要求我们必须回收所有的僵尸孩子进程，并对相应的信号给出正确的反馈。</p><p>为了方便起见，tsh.c文件中提供了一些已封装完成的函数可供我们使用：（仅列出了需要使用到的函数）</p><ul><li><strong>parseline</strong>：解析命令行字符串</li><li><strong>addjob</strong>：向任务列表添加任务</li><li><strong>deletejob</strong>：从任务列表移除任务</li><li><strong>listjobs</strong>：输出任务列表中所有任务的信息</li><li><strong>fgpid</strong>：获取当前前台任务的PID</li><li><strong>getjobpid/getjobjid</strong>：使用PID/Job ID获取任务实例</li><li><strong>pid2jid</strong>：PID号转Job ID号</li><li><strong>unix_error</strong>：发送错误信息并退出</li></ul><p>Lab设计了16个Trace任务用于测试给出的Shell，我们可以使用Lab中提供的<strong>sdriver.pl</strong>工具测试我们的Shell代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> ./sdriver.pl -t traceXX.txt -s ./tsh -a <span class="hljs-string">&quot;-p&quot;</span>  <span class="hljs-comment"># XX代表要使用的trace编号</span></span><br></code></pre></td></tr></table></figure><p>作为参考，我们可以将每个Trace的输出结果与tshref.out中的相应内容进行比对以验证功能是否正确。</p><h2 id="基本功能">基本功能</h2><h3 id="eval及builtin_cmd">eval及builtin_cmd</h3><p>我们先从eval和builtin_cmd函数入手。对于eval函数，其基本的逻辑如下：</p><ul><li>使用parseline函数解析命令行</li><li>边界判断（判断输入命令是否为空或仅有一个&amp;符号）</li><li>判断是否为内置函数，若是，则直接执行并返回</li><li>创建子进程并执行命令</li><li>将任务加入任务列表</li><li>若为前台任务，则等待其执行完成；否则输出信息并返回</li></ul><p>于是我们可以快速写出其对应的代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *argv[MAXARGS]; <span class="hljs-comment">//参数列表</span><br>    <span class="hljs-keyword">int</span> bg; <span class="hljs-comment">//前后台标识符</span><br>    <span class="hljs-keyword">pid_t</span> pid; <span class="hljs-comment">//最近创建子任务的PID号</span><br>  <span class="hljs-comment">//解析命令行</span><br>    bg = parseline(cmdline, argv);<br>  <span class="hljs-comment">//特判</span><br>    <span class="hljs-keyword">if</span>(argv[<span class="hljs-number">0</span>] == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;&amp;&quot;</span>))<br>        <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">//内置函数判断</span><br>    <span class="hljs-keyword">if</span>(!builtin_cmd(argv))&#123;<br>      <span class="hljs-comment">//创建子进程</span><br>        <span class="hljs-keyword">if</span>((pid = fork()) == <span class="hljs-number">0</span>)&#123;<br>          <span class="hljs-comment">//执行任务</span><br>            <span class="hljs-keyword">if</span>(execve(argv[<span class="hljs-number">0</span>], argv, environ) &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Command not found.\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//将任务加入任务列表</span><br>        <span class="hljs-keyword">if</span>(bg)<br>    addjob(jobs, pid, BG, cmdline);<br>        <span class="hljs-keyword">else</span><br>          addjob(jobs, pid, FG, cmdline);<br>      <span class="hljs-comment">//前后台任务处理</span><br>        <span class="hljs-keyword">if</span>(bg)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            waitfg(pid);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>builtin_cmd函数的功能仅为判断命令是否为内置函数并调用对应的函数，因此其实现更为简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">builtin_cmd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//处理quit指令</span><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;quit&quot;</span>))&#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>  <span class="hljs-comment">//处理jobs指令</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;jobs&quot;</span>))&#123;<br>        listjobs(jobs);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>  <span class="hljs-comment">//处理bg指令</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;bg&quot;</span>))&#123;<br>        do_bgfg(argv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>  <span class="hljs-comment">//处理fg指令</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>))&#123;<br>        do_bgfg(argv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do_bgfg">do_bgfg</h3><p>随后我们来处理内置函数bg和fg的实现。当用户输入bg或fg时，需要切换指定任务的运行状态。首先我们来看一下job实例的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> &#123;</span>              <br>    <span class="hljs-keyword">pid_t</span> pid;              <span class="hljs-comment">// 任务PID</span><br>    <span class="hljs-keyword">int</span> jid;                <span class="hljs-comment">// 任务Job ID</span><br>    <span class="hljs-keyword">int</span> state;              <span class="hljs-comment">// 任务状态：UNDEF（未定义）, BG（后台）, FG（前台）, or ST（停止）</span><br>    <span class="hljs-keyword">char</span> cmdline[MAXLINE];  <span class="hljs-comment">// 命令行字符串</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>由此可知我们只需要切换job实例中的state变量即可。这一逻辑可以通过下面这段代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>))&#123;<br>job-&gt;state = FG; <span class="hljs-comment">//转为前台任务</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>job-&gt;state = BG; <span class="hljs-comment">//转为后台任务</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们需要根据用户的输入获取到对应的job实例。用户可以通过PID或Job ID来指定要操作的任务，不过根据题目要求，我们需要讨论所有的输入情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> jid;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span><br><span class="hljs-keyword">pid_t</span> pid;<br><span class="hljs-comment">//无参数的情况</span><br><span class="hljs-keyword">if</span>(argv[<span class="hljs-number">1</span>] == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//输入Job ID的情况</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%%%d&quot;</span>, &amp;jid) &gt; <span class="hljs-number">0</span>)&#123;<br>job = getjobjid(jobs, jid);<br><span class="hljs-keyword">if</span>(job == <span class="hljs-literal">NULL</span> || job-&gt;state == UNDEF)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: No such job\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//输入PID的情况</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%d&quot;</span>, &amp;pid) &gt; <span class="hljs-number">0</span>)&#123;<br>job = getjobpid(jobs, pid);<br><span class="hljs-keyword">if</span>(job == <span class="hljs-literal">NULL</span> || job-&gt;state == UNDEF)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%s): No such process\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//输入其他字符的情况</span><br><span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后我们需要向任务发送SIGCONT信号。需要注意的是，我们需要向任务及其子任务同时发送信号，因此我们需要在创建任务时将其自身和后续的子任务打包到一个独立的进程组中，这可以通过<strong>setpgid</strong>函数来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span> </span><br><span class="hljs-function"></span>&#123;<br>...<br>    <span class="hljs-keyword">if</span>(!builtin_cmd(argv))&#123;<br>        <span class="hljs-keyword">if</span>((pid = fork()) == <span class="hljs-number">0</span>)&#123;<br>            setpgid(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//将自身及子进程放入一个以自身PID为组号的进程组中</span><br>            ...<br>        &#125;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以使用<strong>kill</strong>函数向整个进程组发送信号了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">kill(-pid, SIGCONT); <span class="hljs-comment">//向pid进程组发送SIGCONT信号</span><br></code></pre></td></tr></table></figure><p>随后的行为和eval中类似，只需分情况处理前台或后台任务即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>))&#123;<br>waitfg(pid);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, pid, job-&gt;cmdline);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="waitfg">waitfg</h3><p>waitfg的作用基本就是<strong>在前台任务终止前锁住Shell进程的指令执行</strong>。我们可以使用<strong>while+pause</strong>语句来快速实现这一功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(pid == fgpid(jobs))&#123;<br>        pause();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号处理">信号处理</h2><h3 id="sigint及sigtstp">SIGINT及SIGTSTP</h3><p>首先我们来处理SIGINT和SIGTSTP信号。这两种信号的处理方式完全一致，均为向前台任务的整个进程组发送相应的信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">pid_t</span> pid = fgpid(jobs);<br><span class="hljs-keyword">if</span>(pid != <span class="hljs-number">0</span>)&#123;<br>    kill(-pid, sig);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于这一过程中可能会由于出现另外的异常而改变errno的值，因此我们需要在刚进入函数时保存errno的值，再在函数返回前将其恢复：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> old_errno = errno;<br>...<br>errno = old_errno; <br></code></pre></td></tr></table></figure><h3 id="sigchld">SIGCHLD</h3><p>按照实验要求，共有三种可能的情况会触发SIGCHLD信号：</p><ul><li>子任务正常结束</li><li>前台任务被信号终止</li><li>前台任务被信号暂停</li></ul><p>因此我们需要分情况处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span> </span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> old_errno = errno;<br><span class="hljs-keyword">pid_t</span> pid;<br><span class="hljs-keyword">int</span> state; <span class="hljs-comment">//子进程结束状态码</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span><br><span class="hljs-comment">//对所有已终止或暂停的子进程进行操作</span><br><span class="hljs-keyword">while</span>((pid = waitpid(<span class="hljs-number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">//正常退出的情况</span><br><span class="hljs-keyword">if</span>(WIFEXITED(state))&#123;<br>deletejob(jobs, pid);<br>&#125;<br>    <span class="hljs-comment">//被信号终止的情况</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(WIFSIGNALED(state))&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d\n&quot;</span>, pid2jid(pid), pid, WTERMSIG(state));<br>deletejob(jobs, pid);<br>&#125;<br>    <span class="hljs-comment">//被信号暂停的情况</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(WIFSTOPPED(state))&#123;<br>job = getjobpid(jobs, pid);<br>job-&gt;state = ST; <span class="hljs-comment">//将子进程设置为暂停状态</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stopped by signal %d\n&quot;</span>, job-&gt;jid, pid, WSTOPSIG(state));<br>&#125;<br>&#125;<br>  errno = old_errno;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们需要备份errno以防止破坏其他的操作。</p><h2 id="调度排查">调度排查</h2><p>现在我们的程序已经能够通过绝大部分的Trace任务，但由于<strong>进程调度机制</strong>的存在，某些操作的执行顺序可能并不会如我们所愿，这样在某些情况下可能会导致<strong>竞争</strong>或<strong>死锁</strong>的问题，因此我们需要排查这些情况并解决。</p><p>首先在任务的添加和删除时，由于要修改全局变量jobs，我们不希望有其他信号处理函数打断这一过程导致jobs被修改，因此在执行这些函数时我们要屏蔽所有的信号接收：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">sigset_t</span> mask_all, mask_prev;<br>    ...<br>    <span class="hljs-keyword">if</span>(!builtin_cmd(argv))&#123;<br>    sigfillset(&amp;mask_all);<br>    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);<br>    ...<br>    <span class="hljs-keyword">if</span>(bg)<br>addjob(jobs, pid, BG, cmdline);<br>    <span class="hljs-keyword">else</span><br>        addjob(jobs, pid, FG, cmdline);<br>sigprocmask(SIG_SETMASK, &amp;mask_prev, <span class="hljs-literal">NULL</span>);<br>...<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">sigset_t</span> mask_all, mask_prev;<br>...<br>sigfillset(&amp;mask_all);<br><span class="hljs-keyword">while</span>((pid = waitpid(<span class="hljs-number">-1</span>, &amp;state, WNOHANG | WUNTRACED)) &gt; <span class="hljs-number">0</span>)&#123;<br>sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);<br>...<br>sigprocmask(SIG_SETMASK, &amp;mask_prev, <span class="hljs-literal">NULL</span>);<br>&#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，在修改任务状态时我们也需要屏蔽所有信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">do_bgfg</span><span class="hljs-params">(<span class="hljs-keyword">char</span> **argv)</span> </span><br><span class="hljs-function"></span>&#123;<br>    ...<br><span class="hljs-keyword">sigset_t</span> mask_all, mask_prev;<br>  ...<br>sigfillset(&amp;mask_all);<br>sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;mask_prev);<br>...<br>sigprocmask(SIG_SETMASK, &amp;mask_prev, <span class="hljs-literal">NULL</span>);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们继续检查eval函数，发现如果子进程在addjob函数被执行前便已终止，则sigchld_handler中的deletejob便无法正确删除相应的任务，因此我们需要在addjob被执行前屏蔽SIGCHLD信号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span> </span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">sigset_t</span> mask_one, mask_prev;<br>    ...<br>    <span class="hljs-keyword">if</span>(!builtin_cmd(argv))&#123;<br>        sigemptyset(&amp;mask_one);<br>sigaddset(&amp;mask_one, SIGCHLD);<br>sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;mask_prev);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，这一操作可能会使得子进程也无法接收到SIGCHLD信号，因此我们需要在创建子进程后恢复信号的接收：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *cmdline)</span> </span><br><span class="hljs-function"></span>&#123;<br>...<br>    <span class="hljs-keyword">if</span>(!builtin_cmd(argv))&#123;<br>        <span class="hljs-keyword">if</span>((pid = fork()) == <span class="hljs-number">0</span>)&#123;<br>            sigprocmask(SIG_SETMASK, &amp;mask_prev, <span class="hljs-literal">NULL</span>);<br>            ...<br>        &#125;<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们考察waitfg函数，发现经过上面的修改后Shell进程已无法正确接受SIGCHLD指令。此时尽管我们可以暂时放开SIGCHLD信号的接收，但如果程序刚放开信号进程调度程序便调度至子进程并运行至子进程退出，则pause指令永远无法正确接收到SIGCHLD信号，此时便会出现死锁的情况。因此我们需要使用<strong>sigsuspend</strong>函数来代替以保证其不会被打断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitfg</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">sigset_t</span> empty_mask;<br>    sigemptyset(&amp;empty_mask);<br><br>    <span class="hljs-keyword">while</span>(pid == fgpid(jobs))&#123;<br>        sigsuspend(&amp;empty_mask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Computer-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求解最大团</title>
    <link href="/2021/01/08/algorithm/course-exp/algorithm-exp13/"/>
    <url>/2021/01/08/algorithm/course-exp/algorithm-exp13/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><p>给定一个图，如下所示。请找出这个图的最大团。</p><a id="more"></a><figure><img src="clique.png" alt="clique" /><figcaption aria-hidden="true">clique</figcaption></figure><h2 id="实现代码">实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> adj[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;, n;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; cliques;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_clique</span><span class="hljs-params">(<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; r, <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; p, <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p.empty() &amp;&amp; x.empty())&#123;<br>        cliques.push_back(r);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.empty())&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; p_mut = p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> iter : p)&#123;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; r_tmp = r, p_tmp, x_tmp, adj_tmp;<br>        r_tmp.insert(iter);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            <span class="hljs-keyword">if</span>(adj[iter][i] == <span class="hljs-number">1</span>)<br>                adj_tmp.insert(i);<br>        set_intersection(begin(p_mut), end(p_mut), begin(adj_tmp), end(adj_tmp), inserter(p_tmp, p_tmp.begin()));<br>        set_intersection(begin(x), end(x), begin(adj_tmp), end(adj_tmp), inserter(x_tmp, x_tmp.begin()));<br>        find_clique(r_tmp, p_tmp, x_tmp);<br>        p_mut.erase(iter);<br>        x.insert(iter);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; r, p, x;<br>    fin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        <span class="hljs-keyword">int</span> fe, te;<br>        fin&gt;&gt;fe&gt;&gt;te;<br>        adj[fe][te] = <span class="hljs-number">1</span>;<br>        adj[te][fe] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) p.insert(i);<br>    find_clique(r, p, x);<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> max_cs = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cliques.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span>(cliques[i].size() &gt; max_cs) max_cs = cliques[i].size();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cliques.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span>(cliques[i].size() == max_cs)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> iter: cliques[i])&#123;<br>                <span class="hljs-built_in">cout</span>&lt;&lt;iter&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            &#125;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法正确性">算法正确性</h2><p>使用Bron-Kerbosch算法，维护三个不相交的顶点集 <span class="math inline">\(P,R,X\)</span>，其中 <span class="math inline">\(P\)</span> 代表待搜索的元素，<span class="math inline">\(R\)</span> 代表当前极大环中的元素，<span class="math inline">\(X\)</span> 代表被排除的元素。从图中的某个点开始，递归的遍历所有其邻接顶点，当 <span class="math inline">\(P\)</span> 为空集时，若 <span class="math inline">\(X\)</span> 也为空集，则表明找到了一个极大团，否则回溯到上一节点，并将其从<span class="math inline">\(P\)</span> 中除去加入 <span class="math inline">\(X\)</span> 中。最终即可找到所有极大团，进而比较找出整张图中的最大环。</p><h2 id="总结">总结</h2><p>求最大团问题是一个NPC问题，即无法确定其是否存在多项式时间算法的可归约问题。Bron-Kerbosch算法的时间复杂度约为 <span class="math inline">\(\mathcal{O}(3^n)\)</span>，随着数据规模增大运行时间会显著增加。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K-Means聚类与层次聚类</title>
    <link href="/2020/12/30/machine-learning/clustering/"/>
    <url>/2020/12/30/machine-learning/clustering/</url>
    
    <content type="html"><![CDATA[<h2 id="cluster-analysis">Cluster Analysis</h2><p><strong>Cluster analysis</strong> or <strong>clustering</strong> is a task of grouping a set of objects in such a way that objects in the same group are more similar to each other than to those in other groups. It is <strong>a main task of exploratory data mining</strong>, and <strong>a common technique for statistical data analysis</strong> which is used in many fields including <strong>pattern recognition</strong>, <strong>image analysis</strong>, <strong>information retrieval</strong>, <strong>bioinformatics</strong>, <strong>data compression</strong>, <strong>computer graphics</strong> and <strong>machine learning</strong>.</p><a id="more"></a><p>There are various clustering algorithms that differ significantly in their understanding of what constitutes a cluster and how to effectively find them, which proved to be useful in different scenarios.</p><h2 id="k-means-clustering">K-means Clustering</h2><h3 id="concept">Concept</h3><p>K-means clustering is a partition-based method that can be used to partition a dataset into a fixed number of clusters. We can use the famous <strong>priest-villager model</strong> to illustrate the main idea of K-means algorithm.</p><p>There are four priests preaching in the countryside. At first, they chose four preaching points arbitrarily, and told villagers to take the preaching course that is nearest to their own house. After the first class, some villagers complained that the preaching points were still too far from their home, so each of the priests collected the home addresses of all the villagers that came to his class and move the preaching point to the center of all the addresses. Since the update of preaching points, some villagers found that another preaching points became closer to their house than the previous one, so they chose to take the course at the new preaching point. In this way, the priests updated their preaching points every week, and villagers decided which course to take according to the distance of each preaching points. After several weeks, the preaching points became stable and both the villagers and the priests got satisfied.</p><p>In formal words, K-means algorithm can be described as follows:</p><ol type="1"><li>Choose a set of <span class="math display">\[K\]</span> initial points <span class="math display">\[\{c_1, c_2, ..., c_K\}\]</span> that denotes the centroid of each cluster</li><li>Iteratively execute the following steps until all the centroid points stop to change (or hit some global restriction):<ul><li>For each sample points in the dataset, compute the distances from it to every centroids and assign it to the centroid with the smallest distance</li><li>Recompute the position of each centroid according to the positions of all the samples assigned to it</li></ul></li></ol><h3 id="mathematical-details">Mathematical Details</h3><p>Intuitively, we want to find a set of centroids and an assignment of every instances in the dataset to these centroids so that every centroid covers the most reasonable amount of instances and anchors at exactly the average point of all the instances that assigned to it. We can use a mathematical trick to convert this intuition into an optimization problem.</p><p>If we define an indicator variable <span class="math display">\[r_{nk}\]</span> to describe which cluster an instance is in, which is <span class="math display">\[r_{nk} = \left\{\begin{aligned}&amp;1, &amp;if \ n \ is \ assigned \ to \ k \\&amp;0, &amp;otherwise\end{aligned}\right.\]</span> , then the sum of the distance of all the instances in the dataset to their centroids can be written as <span class="math display">\[J = \sum_{n=1}^N \sum_{k=1}^K r_{nk} \cdot dist(x_n, c_k)\]</span> where <span class="math display">\[N\]</span> is the size of the dataset, <span class="math display">\[K\]</span> is the number of clusters, <span class="math display">\[x_n\]</span> is the <span class="math display">\[n^{th}\]</span> instance in the dataset, <span class="math display">\[c_k\]</span> is the <span class="math display">\[k^{th}\]</span> centroid, <span class="math display">\[dist(a, b)\]</span> is the distance between <span class="math display">\[a\]</span> and <span class="math display">\[b\]</span>.</p><p>Specifically, if the dataset is in the Euclidean space, then we can use the <strong>square of Euclidean distance</strong> as the distance function (square is for the convenience of derivation operations), which is <span class="math display">\[dist(x_n, c_k) = ||x_n - c_k||^2 = (x_{n1}-c_{k1})^2 + (x_{n2}-c_{k2})^2 + ... + (x_{nm}-c_{km})^2\]</span> where <span class="math display">\[x_{ni}\]</span> and <span class="math display">\[c_{ki}\]</span> is the <span class="math display">\[i^{th}\]</span> component of <span class="math display">\[x\]</span> and <span class="math display">\[c\]</span> respectively.</p><p>If the dataset denotes some broader set (usually text data), we can also use the <strong>Jaccard distance</strong> as the distance function, which is defined as <span class="math display">\[dist(A, B) = \frac{A \Delta B}{|A \cup B|} = \frac{|A \cup B - A \cap B|}{|A \cup B|}\]</span> where <span class="math display">\[A, B\]</span> are two sets and <span class="math display">\[|S|\]</span> is the size of set <span class="math display">\[S\]</span>.</p><p>Therefore, our goal becomes to minimize the function <span class="math display">\[J\]</span>. A famous solution to this kind of problems is the <strong>EM(Expectation-Maximization) Algorithm</strong> where optimizing <span class="math display">\[r_{nk}\]</span> is the expectation step and minimizing <span class="math display">\[dist(x_n, c_k)\]</span> is the maximization step.</p><p>First we optimize <span class="math display">\[r_{nk}\]</span>. Since <span class="math display">\[J\]</span> is the linear function of <span class="math display">\[r_{nk}\]</span>, we can simply assigned every instance to the centroid <span class="math display">\[k\]</span> if the distance between them is the smallest among all centroids to get the minimum <span class="math display">\[J\]</span> when the centroids are fixed.</p><p>Then we try to minimize the distance function. Here we only consider the situation when we use the Euclidean distance as the distance metrics. More specifically, our goal is to minimize <span class="math display">\[J = \sum_{n=1}^N \sum_{k=1}^K r_{nk} ||x_n - c_k||^2\]</span> when <span class="math display">\[r_{nk}\]</span> is fixed (This function are also called the <strong>sum of squared error</strong> function). Since each cluster is independent, we can optimize each cluster respectively to get the global minimum, which is to minimize the following expression <span class="math display">\[J_k = \sum_{n=1}^N r_{nk} \cdot ||x_n-c_k||^2\]</span> for every <span class="math display">\[k\]</span> from <span class="math display">\[1\]</span> to <span class="math display">\[K\]</span>.</p><p>We can notice that this is a quadratic function of <span class="math display">\[c_k\]</span>, so we can simply set its derivative function to <span class="math display">\[0\]</span> and solve for <span class="math display">\[c_k\]</span> to get the minimum point. From this we can get the final formula to find the position of <span class="math display">\[c_k\]</span> <span class="math display">\[c_k = \frac{\sum_\limits{n=1}^N r_{nk}x_n}{\sum_\limits{n=1}^N r_{nk}}\]</span> Since both of the two steps aims at reducing <span class="math display">\[J\]</span> while <span class="math display">\[J\]</span> is always greater than <span class="math display">\[0\]</span>, we can prove that the function will finally converges.</p><h3 id="complexity-analysis">Complexity Analysis</h3><p>We can implement K-means algorithm in pseudo-code:</p><figure class="highlight plain"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs pseudocode">K-MEANS(K, t, s): &#x2F;&#x2F;The paramaters denote the number of clusters, the iteration times and the dataset respectively<br>Initialize c[K] &#x2F;&#x2F;Denote the centroid set<br>While t<br>For i in s<br>min_dist &#x3D; INF<br>For j &#x3D; 1 to K<br>d &#x3D; Distance between i and c[j]<br>If d &lt; min_dist<br>min_dist &#x3D; d<br>min_index &#x3D; j<br>Append i into the cluster set of c[min_index]<br>For i &#x3D; 1 to K<br>c[i].pos &#x3D; Mean position of all the points in the cluster set of c[i]<br>return c<br></code></pre></td></tr></table></figure><p>If we use the standard Euclidean distance (<span class="math display">\[L_2\]</span> norm) as the distance metrics, then the time complexity of K-means algorithm is <span class="math display">\[\mathcal{O}(tknm)\]</span> where <span class="math display">\[t\]</span> is the iteration times, <span class="math display">\[k\]</span> is the number of clusters, <span class="math display">\[n\]</span> is the size of the dataset and <span class="math display">\[m\]</span> is the dimension of each sample in the dataset.</p><p>Similarly, if the samples of the dataset and the centroids are all in <span class="math display">\[m\]</span>-dimensional Euclidean space, than the space complexity of K-means algorithm is <span class="math display">\[\mathcal{O}((n+k) \cdot m)\]</span> where <span class="math display">\[n\]</span> is the size of the dataset, <span class="math display">\[k\]</span> is the number of clusters.</p><h3 id="applications">Applications</h3><p>Due to its simplicity, K-means clustering algorithm has been successfully used in many domains such as market segmentation, computer vision and astronomy. It is also used as a preprocessing step before many other alogirithms to find a starting configuration.</p><p>For example, in computer graphics, there is a task called <strong>color quantization</strong> which is to reduce the color palette of a picture into a fixed number. K-means algorithm can easily been used for this task and often produces a competitive result.</p><p>As an unsupervised learning algorithm, K-means algorithm is also widely used to explore the implicit features of a dataset before applying subsequent learning algorithms in data mining area, which can be very useful in some NLP(Natural Language Processing) and computer vision tasks.</p><h3 id="pros-and-cons">Pros And Cons</h3><p>The advantage of K-means algorithm is that it <strong>has a relatively low time and space complexity</strong>, and <strong>has a good flexibility even when applying to a large dataset</strong>. However, there are also some drawbacks of it:</p><ol type="1"><li>The algorithm may converges to a local minimum, which is counterintuitive in some situation.</li><li>Unable to get a correct partition when the clusters is not spherical or non-convex.</li><li>The algorithm is sensitive to the cluster number K and the initial point of the centroids.</li></ol><h2 id="hierarchical-clustering">Hierarchical Clustering</h2><h3 id="concept-1">Concept</h3><p>As its name suggests, hierarchical clustering is a hierarchical-based method to group similar objects into clusters. Its main idea is to build a <strong>hierarchical tree</strong> (or <strong>dendrogram</strong>) to represent the nested group relations. In general, there are two different strategies to achieve this goal: <strong>Agglomerative Hierarchical Clustering</strong> and <strong>Divisive Hierarchical Clustering</strong>. Agglomative method is a <strong>bottom-up</strong> method, which is to regard each of the instances as a single cluster at first and then keep merging the most similar clusters until there is only one cluster left. In comparison, divisive method is a <strong>top-down</strong> method, which consider the whole dataset as a big cluster and keep splitting down until each of the clusters have only one instance in it.</p><h3 id="complexity-analysis-1">Complexity Analysis</h3><p>Agglomerative hierarchical clustering algorithm can be implemented as follow:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">AHC(s): &#x2F;&#x2F;s denotes the dataset<br>Initialize c &#x2F;&#x2F;Denote the clusters at the current level<br>Append every instance from s to c<br>While c.length !&#x3D; 1<br>min_dist &#x3D; INF<br>For i in c<br>For j in c<br>If i !&#x3D; j<br>d &#x3D; Distance between i and j<br>If d &lt; min_dist<br>min_dist &#x3D; d<br>min_cp &#x3D; i, j<br>cm &#x3D; merge(min_cp)<br>Remove min_cp from c<br>Append cm to c<br></code></pre></td></tr></table></figure><p>The basic structure of Divisive hierarchical clustering algorithm is the same as the agglomerative one, except the divisive one needs to split the farthest sub-clusters from the larger cluster in every loop.</p><p>If we use the Euclidean distance as the distance metrics, then the <strong>time complexity</strong> of hierarchical clustering is <span class="math display">\[\mathcal{O}(mn^3)\]</span> where <span class="math display">\[m\]</span> is the dimension of each sample in the dataset and <span class="math display">\[n\]</span> is the size of the dataset.</p><p>Since every cluster needs to record its member and its sub-clusters, the <strong>space complexity</strong> of hierarchical clustering is <span class="math display">\[\mathcal{O}(n^2)\]</span></p><h3 id="applications-1">Applications</h3><p>Hierarchical clustering is an ideal methods to find the hierarchical relations between instances. These instances often differ from each other in some aspects, but not to the extent that we should put them into two mutual exclusive groups.</p><p>For instance, we can use hierarchical clustering to find the members of each party in America senate. To achieve this, we can define how much one senator agrees with another's words as a metrics, and implement hierarchical clustering algorithm on all senator's twitter accounts.</p><h3 id="pros-and-cons-1">Pros And Cons</h3><p>A conspicuous benefit for hierarchical clustering is that it can get the whole cluster information once-and-for-all. Once we get the hierarchical relation tree of a dataset, we can probe the cluster information in different granularity and get the fittest cluster results we want to get.</p><p>However, the defects of it is equally distinct. The huge cost of computing distance between every two clusters and storing hierarchical information makes it unsuitable to handle large dataset. Once a cluster partition or congregation is determined, it is not easy to change since every subsequent judgement is based on clusters existed, which gives the algorithm a poor flexibility. Moreover, the strategy for merging or splitting the clusters is a greedy strategy, which may leads to an local-optimum result.</p><h3 id="k-means-v.s.-hierarchical-clustering">K-means V.S. Hierarchical Clustering</h3><p>In view of their different features, K-means and hierarchical clustering are often used in different scenarios. K-means can be easily adapted to a large or dense dataset thanks to its simplity and low computational cost. When it is uneasy to determine how many clusters in the dataset or the instance relations are unambiguous, hierarchical clustering proves to be a better choice. In practice, we often perform K-means clustering first to get a rough understanding of a dataset and reduce the data size. Then we perform hierarchical clustering to explore the deeper interrelationships among the dataset.</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Machine-Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单源最短路径</title>
    <link href="/2020/12/25/algorithm/course-exp/algorithm-exp12/"/>
    <url>/2020/12/25/algorithm/course-exp/algorithm-exp12/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><p>川西风光几枚，以下图片是川西路线图。张三是旅游爱好者，他从成都出发自驾到西藏江达。</p><a id="more"></a><figure><img src="travel_map.png" alt="travel_map" /><figcaption aria-hidden="true">travel_map</figcaption></figure><ol type="1"><li><p>从成都到江达的最短自驾路线是什么？可以用Dijkstra算法来求解。</p></li><li><p>张三把理塘列为必游之地。怎么规划路线，使得总行程最短？</p></li><li><p>张三觉得理塘风景很美，道孚也不错，两个地方如果能够去一个地方的话就心满意足了。应该怎么安排行程使得总行程最短？</p></li><li><p>张三在规划线路的时候，发现不同路况行驶速度不一样。地图中粗的路径表示平均时速可以达到80公里每小时，而细的路径表示平均时速仅仅有每小时60公里每小时。那么用时最短的路径是哪一条？</p></li><li><p>（<strong>思考题</strong>）考虑到Dijkstra算法仅仅从一段开始寻找路径，效率不高。李教授想到一个高招，就是同时从出发地和目的地进行搜索，扩展搜索节点，然后两个方向扩展的路径会在中途相遇，则拼接起来的路径就是最短路径。如何实现李教授这个想法？</p></li></ol><h2 id="实现代码">实现代码</h2><h3 id="从成都到江达的最短路">从成都到江达的最短路</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> graph[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], d[<span class="hljs-number">50</span>], visit[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;, pred[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//Procedure of finding the shortest path</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) d[i] = SUP;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) visit[i] = <span class="hljs-number">0</span>;<br>    d[from] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        <span class="hljs-keyword">int</span> min_dist = SUP, min_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span> &amp;&amp; d[i] &lt; min_dist)&#123;<br>                min_dist = d[i];<br>                min_idx = i;<br>            &#125;<br>        &#125;<br>        visit[min_idx] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(min_idx == to) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[min_idx][i] != SUP)&#123;<br>                <span class="hljs-keyword">if</span>(d[i] &gt; d[min_idx] + graph[min_idx][i]) &#123;<br>                    d[i] = d[min_idx] + graph[min_idx][i];<br>                    pred[i] = min_idx;<br>                &#125;<br>            &#125;<br>        &#125;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; path;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; location_index;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; inv_location_index;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>, start, end, flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> start_city, end_city;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50</span>; j++) &#123;<br>            graph[i][j] = SUP;<br>            graph[j][i] = SUP;<br>        &#125;<br>    <span class="hljs-comment">//Read in data &amp; build the graph</span><br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        <span class="hljs-built_in">string</span> from, to;<br>        <span class="hljs-keyword">int</span> from_index, to_index, distance, speed;<br>        fin&gt;&gt;from&gt;&gt;to&gt;&gt;distance&gt;&gt;speed;<br>        <span class="hljs-keyword">if</span> (location_index.find(from) == location_index.end())&#123;<br>            from_index = n;<br>            location_index[from] = from_index;<br>            inv_location_index[from_index] = from;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            from_index = location_index[from];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (location_index.find(to) == location_index.end())&#123;<br>            to_index = n;<br>            location_index[to] = to_index;<br>            inv_location_index[to_index] = to;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            to_index = location_index[to];<br>        &#125;<br>        graph[from_index][to_index] = distance;<br>        graph[to_index][from_index] = distance;<br>    &#125;<br>    start_city = <span class="hljs-string">&quot;成都&quot;</span>;<br>    end_city = <span class="hljs-string">&quot;江达&quot;</span>;<br>    start = location_index[start_city];<br>    end = location_index[end_city];<br>    find_path(start, end, n);<br>    <span class="hljs-comment">//Recall the path</span><br>    <span class="hljs-keyword">int</span> cur = end;<br>    path.push(end);<br>    <span class="hljs-keyword">while</span>(cur != start)&#123;<br>        path.push(pred[cur]);<br>        cur = pred[cur];<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;路径：&quot;</span>;<br>    <span class="hljs-keyword">while</span>(!path.empty()) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; inv_location_index[path.top()] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        path.pop();<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total: &quot;</span>&lt;&lt;d[end]&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="从成都经过理塘再到江达的最短路">从成都经过理塘再到江达的最短路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> graph[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], d[<span class="hljs-number">50</span>], visit[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;, pred[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) d[i] = SUP;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) visit[i] = <span class="hljs-number">0</span>;<br>    d[from] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        <span class="hljs-keyword">int</span> min_dist = SUP, min_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span> &amp;&amp; d[i] &lt; min_dist)&#123;<br>                min_dist = d[i];<br>                min_idx = i;<br>            &#125;<br>        &#125;<br>        visit[min_idx] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(min_idx == to) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[min_idx][i] != SUP)&#123;<br>                <span class="hljs-keyword">if</span>(d[i] &gt; d[min_idx] + graph[min_idx][i]) &#123;<br>                    d[i] = d[min_idx] + graph[min_idx][i];<br>                    pred[i] = min_idx;<br>                &#125;<br>            &#125;<br>        &#125;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; path;<br>    <span class="hljs-keyword">int</span> tot_dist = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; location_index;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; inv_location_index;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>, start, mid, end;<br>    <span class="hljs-built_in">string</span> start_city, mid_city, end_city;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50</span>; j++) &#123;<br>            graph[i][j] = SUP;<br>            graph[j][i] = SUP;<br>        &#125;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        <span class="hljs-built_in">string</span> from, to;<br>        <span class="hljs-keyword">int</span> from_index, to_index, distance, speed;<br>        fin&gt;&gt;from&gt;&gt;to&gt;&gt;distance&gt;&gt;speed;<br>        <span class="hljs-keyword">if</span> (location_index.find(from) == location_index.end())&#123;<br>            from_index = n;<br>            location_index[from] = from_index;<br>            inv_location_index[from_index] = from;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            from_index = location_index[from];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (location_index.find(to) == location_index.end())&#123;<br>            to_index = n;<br>            location_index[to] = to_index;<br>            inv_location_index[to_index] = to;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            to_index = location_index[to];<br>        &#125;<br>        graph[from_index][to_index] = distance;<br>        graph[to_index][from_index] = distance;<br>    &#125;<br>    start_city = <span class="hljs-string">&quot;成都&quot;</span>;<br>    mid_city = <span class="hljs-string">&quot;理塘&quot;</span>;<br>    end_city = <span class="hljs-string">&quot;江达&quot;</span>;<br>    start = location_index[start_city];<br>    mid = location_index[mid_city];<br>    end = location_index[end_city];<br>    find_path(mid, end, n);<br>    <span class="hljs-keyword">int</span> cur = end;<br>    path.push(end);<br>    <span class="hljs-keyword">while</span>(cur != mid)&#123;<br>        path.push(pred[cur]);<br>        cur = pred[cur];<br>    &#125;<br>    tot_dist += d[end];<br>    find_path(start, mid, n);<br>    cur = pred[mid];<br>    path.push(pred[mid]);<br>    <span class="hljs-keyword">while</span>(cur != start)&#123;<br>        path.push(pred[cur]);<br>        cur = pred[cur];<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;路径：&quot;</span>;<br>    <span class="hljs-keyword">while</span>(!path.empty())&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;inv_location_index[path.top()]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        path.pop();<br>    &#125;<br>    tot_dist += d[mid];<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total: &quot;</span>&lt;&lt;tot_dist&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="从成都经过理塘或道孚再到江达的最短路">从成都经过理塘或道孚再到江达的最短路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> graph[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], d[<span class="hljs-number">50</span>], visit[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;, pred[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) d[i] = SUP;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) visit[i] = <span class="hljs-number">0</span>;<br>    d[from] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        <span class="hljs-keyword">int</span> min_dist = SUP, min_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span> &amp;&amp; d[i] &lt; min_dist)&#123;<br>                min_dist = d[i];<br>                min_idx = i;<br>            &#125;<br>        &#125;<br>        visit[min_idx] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(min_idx == to) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[min_idx][i] != SUP)&#123;<br>                <span class="hljs-keyword">if</span>(d[i] &gt; d[min_idx] + graph[min_idx][i]) &#123;<br>                    d[i] = d[min_idx] + graph[min_idx][i];<br>                    pred[i] = min_idx;<br>                &#125;<br>            &#125;<br>        &#125;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; path_1, path_2;<br>    <span class="hljs-keyword">int</span> tot_dist_1 = <span class="hljs-number">0</span>, tot_dist_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; location_index;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; inv_location_index;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>, start, mid_1, mid_2, end;<br>    <span class="hljs-built_in">string</span> start_city, mid_city_1, mid_city_2, end_city;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50</span>; j++) &#123;<br>            graph[i][j] = SUP;<br>            graph[j][i] = SUP;<br>        &#125;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        <span class="hljs-built_in">string</span> from, to;<br>        <span class="hljs-keyword">int</span> from_index, to_index, distance, speed;<br>        fin&gt;&gt;from&gt;&gt;to&gt;&gt;distance&gt;&gt;speed;<br>        <span class="hljs-keyword">if</span> (location_index.find(from) == location_index.end())&#123;<br>            from_index = n;<br>            location_index[from] = from_index;<br>            inv_location_index[from_index] = from;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            from_index = location_index[from];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (location_index.find(to) == location_index.end())&#123;<br>            to_index = n;<br>            location_index[to] = to_index;<br>            inv_location_index[to_index] = to;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            to_index = location_index[to];<br>        &#125;<br>        graph[from_index][to_index] = distance;<br>        graph[to_index][from_index] = distance;<br>    &#125;<br>    start_city = <span class="hljs-string">&quot;成都&quot;</span>;<br>    mid_city_1 = <span class="hljs-string">&quot;理塘&quot;</span>;<br>    mid_city_2 = <span class="hljs-string">&quot;道孚&quot;</span>;<br>    end_city = <span class="hljs-string">&quot;江达&quot;</span>;<br>    start = location_index[start_city];<br>    mid_1 = location_index[mid_city_1];<br>    mid_2 = location_index[mid_city_2];<br>    end = location_index[end_city];<br>    <span class="hljs-comment">//Find path 1</span><br>    find_path(mid_1, end, n);<br>    <span class="hljs-keyword">int</span> cur = end;<br>    path_1.push(end);<br>    <span class="hljs-keyword">while</span>(cur != mid_1)&#123;<br>        path_1.push(pred[cur]);<br>        cur = pred[cur];<br>    &#125;<br>    tot_dist_1 += d[end];<br>    find_path(start, mid_1, n);<br>    cur = pred[mid_1];<br>    path_1.push(pred[mid_1]);<br>    <span class="hljs-keyword">while</span>(cur != start)&#123;<br>        path_1.push(pred[cur]);<br>        cur = pred[cur];<br>    &#125;<br>    tot_dist_1 += d[mid_1];<br>    <span class="hljs-comment">//Find path 2</span><br>    find_path(mid_2, end, n);<br>    cur = end;<br>    path_2.push(end);<br>    <span class="hljs-keyword">while</span>(cur != mid_2)&#123;<br>        path_2.push(pred[cur]);<br>        cur = pred[cur];<br>    &#125;<br>    tot_dist_2 += d[end];<br>    find_path(start, mid_2, n);<br>    cur = pred[mid_2];<br>    path_2.push(pred[mid_2]);<br>    <span class="hljs-keyword">while</span>(cur != start)&#123;<br>        path_2.push(pred[cur]);<br>        cur = pred[cur];<br>    &#125;<br>    tot_dist_2 += d[mid_2];<br>    <span class="hljs-comment">//Compare and print the smaller one</span><br>    <span class="hljs-keyword">if</span>(tot_dist_1 &lt;= tot_dist_2)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;途径：理塘&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;路径：&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!path_1.empty())&#123;<br>            <span class="hljs-keyword">int</span> p = path_1.top();<br>            <span class="hljs-built_in">cout</span>&lt;&lt;inv_location_index[p]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            path_1.pop();<br>        &#125;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total: &quot;</span>&lt;&lt;tot_dist_1&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;途径：道孚&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;路径：&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!path_2.empty())&#123;<br>            <span class="hljs-keyword">int</span> p = path_2.top();<br>            <span class="hljs-built_in">cout</span>&lt;&lt;inv_location_index[p]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            path_2.pop();<br>        &#125;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total: &quot;</span>&lt;&lt;tot_dist_2&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有时速限制时的最短路">有时速限制时的最短路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">double</span> graph[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], d[<span class="hljs-number">50</span>];<br><span class="hljs-keyword">int</span> graph_dist[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], visit[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;, pred[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) d[i] = SUP;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) visit[i] = <span class="hljs-number">0</span>;<br>    d[from] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        <span class="hljs-keyword">double</span> min_dist = SUP;<br>        <span class="hljs-keyword">int</span> min_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span> &amp;&amp; d[i] &lt; min_dist)&#123;<br>                min_dist = d[i];<br>                min_idx = i;<br>            &#125;<br>        &#125;<br>        visit[min_idx] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(min_idx == to) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[min_idx][i] != SUP)&#123;<br>                <span class="hljs-keyword">if</span>(d[i] &gt; d[min_idx] + graph[min_idx][i]) &#123;<br>                    d[i] = d[min_idx] + graph[min_idx][i];<br>                    pred[i] = min_idx;<br>                &#125;<br>            &#125;<br>        &#125;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; path;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; location_index;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; inv_location_index;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>, start, end, flag = <span class="hljs-number">0</span>, tot_dist = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> start_city, end_city;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50</span>; j++) &#123;<br>            graph[i][j] = SUP;<br>            graph[j][i] = SUP;<br>            graph_dist[i][j] = SUP;<br>            graph_dist[j][i] = SUP;<br>        &#125;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        <span class="hljs-built_in">string</span> from, to;<br>        <span class="hljs-keyword">int</span> from_index, to_index, distance, speed;<br>        fin&gt;&gt;from&gt;&gt;to&gt;&gt;distance&gt;&gt;speed;<br>        <span class="hljs-keyword">if</span> (location_index.find(from) == location_index.end())&#123;<br>            from_index = n;<br>            location_index[from] = from_index;<br>            inv_location_index[from_index] = from;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            from_index = location_index[from];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (location_index.find(to) == location_index.end())&#123;<br>            to_index = n;<br>            location_index[to] = to_index;<br>            inv_location_index[to_index] = to;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            to_index = location_index[to];<br>        &#125;<br>        graph[from_index][to_index] = (<span class="hljs-keyword">double</span>)distance / speed;<br>        graph[to_index][from_index] = (<span class="hljs-keyword">double</span>)distance / speed;<br>        graph_dist[from_index][to_index] = distance;<br>        graph_dist[to_index][from_index] = distance;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) d[i] = SUP;<br>    start_city = <span class="hljs-string">&quot;成都&quot;</span>;<br>    end_city = <span class="hljs-string">&quot;江达&quot;</span>;<br>    start = location_index[start_city];<br>    end = location_index[end_city];<br>    find_path(start, end, n);<br>    <span class="hljs-keyword">int</span> cur = end;<br>    path.push(end);<br>    <span class="hljs-keyword">while</span>(cur != start)&#123;<br>        path.push(pred[cur]);<br>        tot_dist += graph_dist[cur][pred[cur]];<br>        cur = pred[cur];<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;路径：&quot;</span>;<br>    <span class="hljs-keyword">while</span>(!path.empty()) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; inv_location_index[path.top()] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        path.pop();<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total: &quot;</span>&lt;&lt;tot_dist&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分别从两边开始搜索的最短路">分别从两边开始搜索的最短路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> graph[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], d1[<span class="hljs-number">50</span>], d2[<span class="hljs-number">50</span>], visit_1[<span class="hljs-number">50</span>], visit_2[<span class="hljs-number">50</span>], pred_1[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;, pred_2[<span class="hljs-number">50</span>] = &#123;<span class="hljs-number">0</span>&#125;, inter_idx;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find_path</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) d1[i] = SUP;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) d2[i] = SUP;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) visit_1[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) visit_2[i] = <span class="hljs-number">0</span>;<br>    d1[from] = <span class="hljs-number">0</span>;<br>    d2[to] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        <span class="hljs-keyword">int</span> min_dist = SUP, min_idx_1 = <span class="hljs-number">-1</span>, min_idx_2 = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit_1[i] == <span class="hljs-number">0</span> &amp;&amp; d1[i] &lt; min_dist)&#123;<br>                min_dist = d1[i];<br>                min_idx_1 = i;<br>            &#125;<br>        &#125;<br>        visit_1[min_idx_1] = <span class="hljs-number">1</span>;<br>        min_dist = SUP;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit_2[i] == <span class="hljs-number">0</span> &amp;&amp; d2[i] &lt; min_dist)&#123;<br>                min_dist = d2[i];<br>                min_idx_2 = i;<br>            &#125;<br>        &#125;<br>        visit_2[min_idx_2] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(visit_1[min_idx_2] == <span class="hljs-number">1</span> || visit_2[min_idx_1] == <span class="hljs-number">1</span>) &#123;<br>            inter_idx = visit_1[min_idx_2] ? min_idx_2 : min_idx_1;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(min_idx_1 == to || min_idx_2 == from) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit_1[i] == <span class="hljs-number">0</span> &amp;&amp; graph[min_idx_1][i] != SUP)&#123;<br>                <span class="hljs-keyword">if</span>(d1[i] &gt; d1[min_idx_1] + graph[min_idx_1][i]) &#123;<br>                    d1[i] = d1[min_idx_1] + graph[min_idx_1][i];<br>                    pred_1[i] = min_idx_1;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span> (visit_2[i] == <span class="hljs-number">0</span> &amp;&amp; graph[min_idx_2][i] != SUP)&#123;<br>                <span class="hljs-keyword">if</span>(d2[i] &gt; d1[min_idx_2] + graph[min_idx_2][i]) &#123;<br>                    d2[i] = d1[min_idx_2] + graph[min_idx_2][i];<br>                    pred_2[i] = min_idx_2;<br>                &#125;<br>            &#125;<br>        &#125;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (visit_1[i] == <span class="hljs-number">0</span> || visit_2[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; path;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; location_index;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; inv_location_index;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>, start, end, flag = <span class="hljs-number">0</span>, tot_dist = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">string</span> start_city, end_city;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">50</span>; j++) &#123;<br>            graph[i][j] = SUP;<br>            graph[j][i] = SUP;<br>        &#125;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        <span class="hljs-built_in">string</span> from, to;<br>        <span class="hljs-keyword">int</span> from_index, to_index, distance, speed;<br>        fin&gt;&gt;from&gt;&gt;to&gt;&gt;distance&gt;&gt;speed;<br>        <span class="hljs-keyword">if</span> (location_index.find(from) == location_index.end())&#123;<br>            from_index = n;<br>            location_index[from] = from_index;<br>            inv_location_index[from_index] = from;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            from_index = location_index[from];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (location_index.find(to) == location_index.end())&#123;<br>            to_index = n;<br>            location_index[to] = to_index;<br>            inv_location_index[to_index] = to;<br>            n++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            to_index = location_index[to];<br>        &#125;<br>        graph[from_index][to_index] = distance;<br>        graph[to_index][from_index] = distance;<br>    &#125;<br>    start_city = <span class="hljs-string">&quot;成都&quot;</span>;<br>    end_city = <span class="hljs-string">&quot;江达&quot;</span>;<br>    start = location_index[start_city];<br>    end = location_index[end_city];<br>    find_path(start, end, n);<br>    <span class="hljs-keyword">int</span> cur = inter_idx;<br>    path.push(inter_idx);<br>    <span class="hljs-keyword">while</span>(cur != start)&#123;<br>        path.push(pred_1[cur]);<br>        cur = pred_1[cur];<br>    &#125;<br>    tot_dist += d1[inter_idx];<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;路径：&quot;</span>;<br>    <span class="hljs-keyword">while</span>(!path.empty()) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; inv_location_index[path.top()] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        path.pop();<br>    &#125;<br>    cur = inter_idx;<br>    <span class="hljs-keyword">while</span>(cur != end)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;inv_location_index[pred_2[cur]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cur = pred_2[cur];<br>    &#125;<br>    tot_dist += d2[inter_idx];<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total: &quot;</span>&lt;&lt;tot_dist&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法正确性">算法正确性</h2><h3 id="从成都到江达的最短路-1">从成都到江达的最短路</h3><p>使用Dijkstra算法思想，每次从未完成点集中选择离源点距离最短的加入已完成点集，并更新与其相邻所有点到源点的最短距离及对应的前继节点编号，最终即可得到源点到目标点的最短路径。</p><h3 id="从成都经过理塘再到江达的最短路-1">从成都经过理塘再到江达的最短路</h3><p>使用(1)的算法先找出成都到理塘的最短路径，再以理塘为起点找出到江达的最短路径，拼在一起即为满足要求的最短路。</p><h3 id="从成都经过理塘或道孚再到江达的最短路-1">从成都经过理塘或道孚再到江达的最短路</h3><p>使用(2)的方法先找出成都经过理塘到江达的最短路径，再找出成都经过道孚到江达的最短路径，比较两者路径长度选择更短的即可。</p><h3 id="有时速限制时的最短路-1">有时速限制时的最短路</h3><p>在建图时，将最短行驶时间（路程/时速限制）作为每条边的权值，再使用(1)的算法搜索即可。</p><h3 id="分别从两边开始搜索的最短路-1">分别从两边开始搜索的最短路</h3><p>使用(1)的算法，分别从两边开始遍历图。当其中一个遍历过程遍历到另一个的路径上时，记录相遇节点并停止遍历。再分别回溯即可拼接成完整的最短路径。</p><h2 id="总结">总结</h2><p>旅行路径规划问题本质上即为单源最短路问题，可使用Dijkstra算法在 <span class="math inline">\(\mathcal{O}(E^2)\)</span> 的时间内找到最短路。</p><p>第(1)(3)(4)(5)问的最短路径结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>第(2)的最短路径结果如下：</p><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2020/12/18/algorithm/course-exp/algorithm-exp11/"/>
    <url>/2020/12/18/algorithm/course-exp/algorithm-exp11/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><p>国家电网公司想在全国布局超高压输电网络，联通所有省会城市。为了降低成本，并且达到某些硬性要求，国家电网按照以下五种策略进行规划布局。</p><ol type="1"><li><p>要求整个电网的长度最短。</p></li><li><p>要求在西宁与郑州拉一根直达专线的情况下，使得整个电网长度最短</p></li><li><p>要求不仅在西宁与郑州之间拉直达专线，还在杭州与长沙之间拉直达专线的情况下，使得整个电网长度最短。</p></li><li><p>在香港与澳门、澳门与广州不拉直达线路的前提之下，使得整个电网的长度最短。</p></li><li><p>山东、河南、山西、甘肃、青海、新疆以及比他们更北的省份称为北方省份，其余省份称为南方省份。如果在南方省份和北方省份之间仅规划一条直通专线，如何使得整个电网的长度最短。</p></li></ol><a id="more"></a><p>请分别根据这五种情况计算最优情况。</p><figure><img src="china_map.png" alt="china_map" /><figcaption aria-hidden="true">china_map</figcaption></figure><p>提示：</p><ol type="1"><li><p>如无特殊约定，各个城市之间均可拉专线，其长度是直线长度。</p></li><li><p>地球上任意两点之间的距离计算方法可以参照以下文件：https://www.cnblogs.com/ycsfwhh/archive/2010/12/20/1911232.html</p></li></ol><p>摘录如下：</p><p>地球是一个近乎标准的椭球体，它的赤道半径为 <span class="math inline">\(6378.140\)</span> 千米，极半径为 <span class="math inline">\(6356.755\)</span> 千米，平均半径 <span class="math inline">\(6371.004\)</span> 千米。如果我们假设地球是一个完美的球体，那么它的半径就是地球的平均半径，记为 <span class="math inline">\(R\)</span>。如果以 <span class="math inline">\(0\)</span> 度经线为基 准，那么根据地球表面任意两点的经纬度就可以计算出这两点间的地表距离（这里忽略地球表面地形对计算带来的误差，仅仅是理论上的估算值）。设第一点 <span class="math inline">\(A\)</span> 的经纬度为 <span class="math inline">\((LonA, LatA)\)</span>，第二点 <span class="math inline">\(B\)</span> 的经纬度为 <span class="math inline">\((LonB, LatB)\)</span>，按照 <span class="math inline">\(0\)</span> 度经线的基准，东经取经度的正值(Longitude)，西经取经度负值(-Longitude)，北纬取90-纬度值(90- Latitude)，南纬取90+纬度值(90+Latitude)，则经过上述处理过后的两点被计为 <span class="math inline">\((MLonA, MLatA)\)</span> 和 <span class="math inline">\((MLonB, MLatB)\)</span>。那么根据三角推导，可以得到计算两点距离的如下公式： $$ C = (MLatA) (MLatB) (MLonA-MLonB) + (MLatA) (MLatB) \</p><p>Distance = R* (C) $$ 这里，R和Distance单位是相同，如果是采用 <span class="math inline">\(6371.004\)</span> 千米作为半径，那么Distance就是千米为单位，如果要使用其他单位，比如mile，还需要做单位换算，1千米=0.621371192mile</p><p>如果仅对经度作正负的处理，而不对纬度作90-Latitude(假设都是北半球，南半球只有澳洲具有应用意义)的处理，那么公式将是： $$ C = (LatA) (LatB) + (LatA) (LatB) (MLonA-MLonB) \</p><p>Distance = R (C)  $$ 以上通过简单的三角变换就可以推出。</p><ol start="3" type="1"><li>全国省会城市的经纬度如下所示。</li></ol><p>城市,经度,纬度 沈阳市,123.429092,41.796768 长春市,125.324501,43.886841 哈尔滨市,126.642464,45.756966 北京市,116.405289,39.904987 天津市,117.190186,39.125595 呼和浩特市,111.751990,40.841490 银川市,106.232480,38.486440 太原市,112.549248,37.857014 石家庄市,114.502464,38.045475 济南市,117.000923,36.675808 郑州市,113.665413,34.757977 西安市,108.948021,34.263161 武汉市,114.298569,30.584354 南京市,118.76741,32.041546 合肥市,117.283043,31.861191 上海市,121.472641,31.231707 长沙市,112.982277,28.19409 南昌市,115.892151,28.676493 杭州市,120.15358,30.287458 福州市,119.306236,26.075302 广州市,113.28064,23.125177 台北市,121.5200760,25.0307240 海口市,110.199890,20.044220 南宁市,108.320007,22.82402 重庆市,106.504959,29.533155 昆明市,102.71225,25.040609 贵阳市,106.713478,26.578342 成都市,104.065735,30.659462 兰州市,103.834170,36.061380 西宁市,101.777820,36.617290 拉萨市,91.11450,29.644150 乌鲁木齐市,87.616880,43.826630 香港,114.165460,22.275340 澳门,113.549130,22.198750</p><h2 id="实现代码">实现代码</h2><h3 id="整个电网的长度最短">整个电网的长度最短</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R 6371.004</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">city</span>&#123;</span><br>    <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">double</span> longitude;<br>    <span class="hljs-keyword">double</span> latitude;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> from;<br>    <span class="hljs-keyword">int</span> to;<br>    <span class="hljs-keyword">double</span> weight;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">rad</span><span class="hljs-params">(<span class="hljs-keyword">double</span> angle)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> angle * M_PI / <span class="hljs-number">180</span>;<br>&#125;<br><span class="hljs-comment">//Only correct when the positions are in the north-eastern hemisphere</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">earth_dist</span><span class="hljs-params">(city *pos_a, city *pos_b)</span></span>&#123;<br>    <span class="hljs-keyword">double</span> long_a = rad(pos_a-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_a = rad(pos_a-&gt;latitude);<br>    <span class="hljs-keyword">double</span> long_b = rad(pos_b-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_b = rad(pos_b-&gt;latitude);<br>    <span class="hljs-keyword">double</span> c = <span class="hljs-built_in">sin</span>(lat_a) * <span class="hljs-built_in">sin</span>(lat_b) + <span class="hljs-built_in">cos</span>(lat_a) * <span class="hljs-built_in">cos</span>(lat_b) * <span class="hljs-built_in">cos</span>(long_b - long_a);<br>    <span class="hljs-keyword">return</span> R * <span class="hljs-built_in">acos</span>(c);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    city c[<span class="hljs-number">35</span>];<br>    edge chosen[<span class="hljs-number">35</span>], low_cost[<span class="hljs-number">35</span>];<br>    <span class="hljs-keyword">double</span> graph[<span class="hljs-number">35</span>][<span class="hljs-number">35</span>] = &#123;SUP&#125;;<br>    <span class="hljs-keyword">int</span> visit[<span class="hljs-number">35</span>] = &#123;<span class="hljs-number">0</span>&#125;, flag = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, last_visit, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;position.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (!fin.eof())&#123;<br>        fin&gt;&gt;c[n].name&gt;&gt;c[n].longitude&gt;&gt;c[n].latitude;<br>        n++;<br>    &#125;<br>    <span class="hljs-comment">//Build the graph</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(i == j) graph[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">double</span> dist = earth_dist(&amp;c[i], &amp;c[j]);<br>                graph[i][j] = dist;<br>                graph[j][i] = dist;<br>            &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        low_cost[i] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, SUP&#125;;<br>    &#125;<br>    visit[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    last_visit = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//Procedure of searching the MST</span><br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//Update the lowest-cost edge set</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>                low_cost[i].from = last_visit;<br>                low_cost[i].to = i;<br>                low_cost[i].weight = graph[last_visit][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> min_edge_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">double</span> min_edge_dist = SUP;<br>        <span class="hljs-comment">//Search for the smallest edge</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span>(low_cost[i].weight != <span class="hljs-number">-1.0</span> &amp;&amp; low_cost[i].weight &lt; min_edge_dist)&#123;<br>                min_edge_dist = low_cost[i].weight;<br>                min_edge_idx = i;<br>            &#125;<br>        &#125;<br>        chosen[cnt] = low_cost[min_edge_idx];<br>        visit[min_edge_idx] = <span class="hljs-number">1</span>;<br>        low_cost[min_edge_idx] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1.0</span>&#125;;<br>        last_visit = min_edge_idx;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;c[chosen[i].from].name&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;c[chosen[i].to].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;chosen[i].weight&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        sum += chosen[i].weight;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;总长度: &quot;</span>&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在西宁与郑州拉一根直达专线的情况下使得整个电网长度最短">在西宁与郑州拉一根直达专线的情况下，使得整个电网长度最短</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R 6371.004</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">city</span>&#123;</span><br>    <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">double</span> longitude;<br>    <span class="hljs-keyword">double</span> latitude;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> from;<br>    <span class="hljs-keyword">int</span> to;<br>    <span class="hljs-keyword">double</span> weight;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">rad</span><span class="hljs-params">(<span class="hljs-keyword">double</span> angle)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> angle * M_PI / <span class="hljs-number">180</span>;<br>&#125;<br><span class="hljs-comment">//Only correct when the positions are on the north-eastern hemisphere</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">earth_dist</span><span class="hljs-params">(city *pos_a, city *pos_b)</span></span>&#123;<br>    <span class="hljs-keyword">double</span> long_a = rad(pos_a-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_a = rad(pos_a-&gt;latitude);<br>    <span class="hljs-keyword">double</span> long_b = rad(pos_b-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_b = rad(pos_b-&gt;latitude);<br>    <span class="hljs-keyword">double</span> c = <span class="hljs-built_in">sin</span>(lat_a) * <span class="hljs-built_in">sin</span>(lat_b) + <span class="hljs-built_in">cos</span>(lat_a) * <span class="hljs-built_in">cos</span>(lat_b) * <span class="hljs-built_in">cos</span>(long_b - long_a);<br>    <span class="hljs-keyword">return</span> R * <span class="hljs-built_in">acos</span>(c);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    city c[<span class="hljs-number">35</span>];<br>    edge chosen[<span class="hljs-number">35</span>], low_cost[<span class="hljs-number">35</span>];<br>    <span class="hljs-keyword">double</span> graph[<span class="hljs-number">35</span>][<span class="hljs-number">35</span>] = &#123;SUP&#125;;<br>    <span class="hljs-keyword">int</span> visit[<span class="hljs-number">35</span>] = &#123;<span class="hljs-number">0</span>&#125;, flag = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, last_visit, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> xi_ning_idx, zheng_zhou_idx;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;position.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (!fin.eof())&#123;<br>        fin&gt;&gt;c[n].name&gt;&gt;c[n].longitude&gt;&gt;c[n].latitude;<br>        <span class="hljs-keyword">if</span> (c[n].name == <span class="hljs-string">&quot;西宁市&quot;</span>) xi_ning_idx = n;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[n].name == <span class="hljs-string">&quot;郑州市&quot;</span>) zheng_zhou_idx = n;<br>        n++;<br>    &#125;<br>    <span class="hljs-comment">//Build the graph</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(i == j) graph[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">double</span> dist = earth_dist(&amp;c[i], &amp;c[j]);<br>                graph[i][j] = dist;<br>                graph[j][i] = dist;<br>            &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        low_cost[i] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, SUP&#125;;<br>    &#125;<br>    chosen[<span class="hljs-number">0</span>].from = xi_ning_idx;<br>    chosen[<span class="hljs-number">0</span>].to = zheng_zhou_idx;<br>    chosen[<span class="hljs-number">0</span>].weight = graph[xi_ning_idx][zheng_zhou_idx];<br>    cnt++;<br>    visit[xi_ning_idx] = <span class="hljs-number">1</span>;<br>    visit[zheng_zhou_idx] = <span class="hljs-number">1</span>;<br>    last_visit = xi_ning_idx;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>            low_cost[i].from = last_visit;<br>            low_cost[i].to = i;<br>            low_cost[i].weight = graph[last_visit][i];<br>        &#125;<br>    &#125;<br>    last_visit = zheng_zhou_idx;<br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>                low_cost[i].from = last_visit;<br>                low_cost[i].to = i;<br>                low_cost[i].weight = graph[last_visit][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> min_edge_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">double</span> min_edge_dist = SUP;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span>(low_cost[i].weight != <span class="hljs-number">-1.0</span> &amp;&amp; low_cost[i].weight &lt; min_edge_dist)&#123;<br>                min_edge_dist = low_cost[i].weight;<br>                min_edge_idx = i;<br>            &#125;<br>        &#125;<br>        chosen[cnt] = low_cost[min_edge_idx];<br>        visit[min_edge_idx] = <span class="hljs-number">1</span>;<br>        low_cost[min_edge_idx] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1.0</span>&#125;;<br>        last_visit = min_edge_idx;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;c[chosen[i].from].name&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;c[chosen[i].to].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;chosen[i].weight&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        sum += chosen[i].weight;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;总长度: &quot;</span>&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不仅在西宁与郑州之间拉直达专线还在杭州与长沙之间拉直达专线的情况下使得整个电网长度最短">不仅在西宁与郑州之间拉直达专线，还在杭州与长沙之间拉直达专线的情况下，使得整个电网长度最短</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R 6371.004</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">city</span>&#123;</span><br>    <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">double</span> longitude;<br>    <span class="hljs-keyword">double</span> latitude;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> from;<br>    <span class="hljs-keyword">int</span> to;<br>    <span class="hljs-keyword">double</span> weight;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">rad</span><span class="hljs-params">(<span class="hljs-keyword">double</span> angle)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> angle * M_PI / <span class="hljs-number">180</span>;<br>&#125;<br><span class="hljs-comment">//Only correct when the positions are on the north-eastern hemisphere</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">earth_dist</span><span class="hljs-params">(city *pos_a, city *pos_b)</span></span>&#123;<br>    <span class="hljs-keyword">double</span> long_a = rad(pos_a-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_a = rad(pos_a-&gt;latitude);<br>    <span class="hljs-keyword">double</span> long_b = rad(pos_b-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_b = rad(pos_b-&gt;latitude);<br>    <span class="hljs-keyword">double</span> c = <span class="hljs-built_in">sin</span>(lat_a) * <span class="hljs-built_in">sin</span>(lat_b) + <span class="hljs-built_in">cos</span>(lat_a) * <span class="hljs-built_in">cos</span>(lat_b) * <span class="hljs-built_in">cos</span>(long_b - long_a);<br>    <span class="hljs-keyword">return</span> R * <span class="hljs-built_in">acos</span>(c);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    city c[<span class="hljs-number">35</span>];<br>    edge chosen[<span class="hljs-number">35</span>], low_cost[<span class="hljs-number">35</span>];<br>    <span class="hljs-keyword">double</span> graph[<span class="hljs-number">35</span>][<span class="hljs-number">35</span>] = &#123;SUP&#125;;<br>    <span class="hljs-keyword">int</span> visit[<span class="hljs-number">35</span>] = &#123;<span class="hljs-number">0</span>&#125;, flag = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, last_visit, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> xi_ning_idx, zheng_zhou_idx, hang_zhou_idx, chang_sha_idx;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;position.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (!fin.eof())&#123;<br>        fin&gt;&gt;c[n].name&gt;&gt;c[n].longitude&gt;&gt;c[n].latitude;<br>        <span class="hljs-keyword">if</span> (c[n].name == <span class="hljs-string">&quot;西宁市&quot;</span>) xi_ning_idx = n;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[n].name == <span class="hljs-string">&quot;郑州市&quot;</span>) zheng_zhou_idx = n;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[n].name == <span class="hljs-string">&quot;杭州市&quot;</span>) hang_zhou_idx = n;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[n].name == <span class="hljs-string">&quot;长沙市&quot;</span>) chang_sha_idx = n;<br>        n++;<br>    &#125;<br>    <span class="hljs-comment">//Build the graph</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(i == j) graph[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">double</span> dist = earth_dist(&amp;c[i], &amp;c[j]);<br>                graph[i][j] = dist;<br>                graph[j][i] = dist;<br>            &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        low_cost[i] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, SUP&#125;;<br>    &#125;<br>    chosen[<span class="hljs-number">0</span>].from = xi_ning_idx;<br>    chosen[<span class="hljs-number">0</span>].to = zheng_zhou_idx;<br>    chosen[<span class="hljs-number">0</span>].weight = graph[xi_ning_idx][zheng_zhou_idx];<br>    cnt ++;<br>    visit[xi_ning_idx] = <span class="hljs-number">1</span>;<br>    visit[zheng_zhou_idx] = <span class="hljs-number">1</span>;<br>    last_visit = xi_ning_idx;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>            low_cost[i].from = last_visit;<br>            low_cost[i].to = i;<br>            low_cost[i].weight = graph[last_visit][i];<br>        &#125;<br>    &#125;<br>    last_visit = zheng_zhou_idx;<br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>                low_cost[i].from = last_visit;<br>                low_cost[i].to = i;<br>                low_cost[i].weight = graph[last_visit][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> min_edge_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">double</span> min_edge_dist = SUP;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span>(low_cost[i].weight != <span class="hljs-number">-1.0</span> &amp;&amp; low_cost[i].weight &lt; min_edge_dist)&#123;<br>                min_edge_dist = low_cost[i].weight;<br>                min_edge_idx = i;<br>            &#125;<br>        &#125;<br>        chosen[cnt] = low_cost[min_edge_idx];<br>        visit[min_edge_idx] = <span class="hljs-number">1</span>;<br>        low_cost[min_edge_idx] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1.0</span>&#125;;<br>        last_visit = min_edge_idx;<br>        cnt++;<br>        <span class="hljs-keyword">if</span>(last_visit == hang_zhou_idx &amp;&amp; visit[chang_sha_idx] == <span class="hljs-number">0</span>)&#123;<br>            chosen[cnt].from = hang_zhou_idx;<br>            chosen[cnt].to = chang_sha_idx;<br>            chosen[cnt].weight = graph[hang_zhou_idx][chang_sha_idx];<br>            visit[chang_sha_idx] = <span class="hljs-number">1</span>;<br>            low_cost[chang_sha_idx] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1.0</span>&#125;;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>                    low_cost[i].from = last_visit;<br>                    low_cost[i].to = i;<br>                    low_cost[i].weight = graph[last_visit][i];<br>                &#125;<br>            &#125;<br>            cnt++;<br>            last_visit = chang_sha_idx;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last_visit == chang_sha_idx &amp;&amp; visit[hang_zhou_idx] == <span class="hljs-number">0</span>)&#123;<br>            chosen[cnt].from = chang_sha_idx;<br>            chosen[cnt].to = hang_zhou_idx;<br>            chosen[cnt].weight = graph[chang_sha_idx][hang_zhou_idx];<br>            visit[hang_zhou_idx] = <span class="hljs-number">1</span>;<br>            low_cost[hang_zhou_idx] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1.0</span>&#125;;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>                <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>                    low_cost[i].from = last_visit;<br>                    low_cost[i].to = i;<br>                    low_cost[i].weight = graph[last_visit][i];<br>                &#125;<br>            &#125;<br>            cnt++;<br>            last_visit = hang_zhou_idx;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;c[chosen[i].from].name&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;c[chosen[i].to].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;chosen[i].weight&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        sum += chosen[i].weight;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;总长度: &quot;</span>&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在香港与澳门澳门与广州不拉直达线路的前提之下使得整个电网的长度最短">在香港与澳门、澳门与广州不拉直达线路的前提之下，使得整个电网的长度最短</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R 6371.004</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">city</span>&#123;</span><br>    <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">double</span> longitude;<br>    <span class="hljs-keyword">double</span> latitude;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> from;<br>    <span class="hljs-keyword">int</span> to;<br>    <span class="hljs-keyword">double</span> weight;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">rad</span><span class="hljs-params">(<span class="hljs-keyword">double</span> angle)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> angle * M_PI / <span class="hljs-number">180</span>;<br>&#125;<br><span class="hljs-comment">//Only correct when the positions are on the north-eastern hemisphere</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">earth_dist</span><span class="hljs-params">(city *pos_a, city *pos_b)</span></span>&#123;<br>    <span class="hljs-keyword">double</span> long_a = rad(pos_a-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_a = rad(pos_a-&gt;latitude);<br>    <span class="hljs-keyword">double</span> long_b = rad(pos_b-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_b = rad(pos_b-&gt;latitude);<br>    <span class="hljs-keyword">double</span> c = <span class="hljs-built_in">sin</span>(lat_a) * <span class="hljs-built_in">sin</span>(lat_b) + <span class="hljs-built_in">cos</span>(lat_a) * <span class="hljs-built_in">cos</span>(lat_b) * <span class="hljs-built_in">cos</span>(long_b - long_a);<br>    <span class="hljs-keyword">return</span> R * <span class="hljs-built_in">acos</span>(c);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    city c[<span class="hljs-number">35</span>];<br>    edge chosen[<span class="hljs-number">35</span>], low_cost[<span class="hljs-number">35</span>];<br>    <span class="hljs-keyword">double</span> graph[<span class="hljs-number">35</span>][<span class="hljs-number">35</span>] = &#123;SUP&#125;;<br>    <span class="hljs-keyword">int</span> visit[<span class="hljs-number">35</span>] = &#123;<span class="hljs-number">0</span>&#125;, flag = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, last_visit, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> hong_kong_idx, macao_idx, guang_zhou_idx;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;position.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (!fin.eof())&#123;<br>        fin&gt;&gt;c[n].name&gt;&gt;c[n].longitude&gt;&gt;c[n].latitude;<br>        <span class="hljs-keyword">if</span> (c[n].name == <span class="hljs-string">&quot;香港&quot;</span>) hong_kong_idx = n;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[n].name == <span class="hljs-string">&quot;澳门&quot;</span>) macao_idx = n;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[n].name == <span class="hljs-string">&quot;广州市&quot;</span>) guang_zhou_idx = n;<br>        n++;<br>    &#125;<br>    <span class="hljs-comment">//Build the graph</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(i == j) graph[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">double</span> dist = earth_dist(&amp;c[i], &amp;c[j]);<br>                graph[i][j] = dist;<br>                graph[j][i] = dist;<br>            &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        low_cost[i] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, SUP&#125;;<br>    &#125;<br>    visit[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    last_visit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>                <span class="hljs-keyword">bool</span> spec_1, spec_2;<br>                spec_1 = (last_visit == hong_kong_idx &amp;&amp; i == macao_idx) || (last_visit == macao_idx &amp;&amp; i == hong_kong_idx);<br>                spec_2 = (last_visit == macao_idx &amp;&amp; i == guang_zhou_idx) || (last_visit == guang_zhou_idx &amp;&amp; i == macao_idx);<br>                <span class="hljs-keyword">if</span> (!spec_1 &amp;&amp; !spec_2) &#123;<br>                    low_cost[i].from = last_visit;<br>                    low_cost[i].to = i;<br>                    low_cost[i].weight = graph[last_visit][i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> min_edge_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">double</span> min_edge_dist = SUP;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span>(low_cost[i].weight != <span class="hljs-number">-1.0</span> &amp;&amp; low_cost[i].weight &lt; min_edge_dist)&#123;<br>                min_edge_dist = low_cost[i].weight;<br>                min_edge_idx = i;<br>            &#125;<br>        &#125;<br>        chosen[cnt] = low_cost[min_edge_idx];<br>        visit[min_edge_idx] = <span class="hljs-number">1</span>;<br>        low_cost[min_edge_idx] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1.0</span>&#125;;<br>        last_visit = min_edge_idx;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;c[chosen[i].from].name&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;c[chosen[i].to].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;chosen[i].weight&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        sum += chosen[i].weight;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;总长度: &quot;</span>&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在南方省份和北方省份之间仅规划一条直通专线使得整个电网的长度最短">在南方省份和北方省份之间仅规划一条直通专线，使得整个电网的长度最短</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R 6371.004</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SUP 100000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">city</span>&#123;</span><br>    <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-keyword">double</span> longitude;<br>    <span class="hljs-keyword">double</span> latitude;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> from;<br>    <span class="hljs-keyword">int</span> to;<br>    <span class="hljs-keyword">double</span> weight;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">rad</span><span class="hljs-params">(<span class="hljs-keyword">double</span> angle)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> angle * M_PI / <span class="hljs-number">180</span>;<br>&#125;<br><span class="hljs-comment">//Only correct when the positions are on the north-eastern hemisphere</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">earth_dist</span><span class="hljs-params">(city *pos_a, city *pos_b)</span></span>&#123;<br>    <span class="hljs-keyword">double</span> long_a = rad(pos_a-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_a = rad(pos_a-&gt;latitude);<br>    <span class="hljs-keyword">double</span> long_b = rad(pos_b-&gt;longitude);<br>    <span class="hljs-keyword">double</span> lat_b = rad(pos_b-&gt;latitude);<br>    <span class="hljs-keyword">double</span> c = <span class="hljs-built_in">sin</span>(lat_a) * <span class="hljs-built_in">sin</span>(lat_b) + <span class="hljs-built_in">cos</span>(lat_a) * <span class="hljs-built_in">cos</span>(lat_b) * <span class="hljs-built_in">cos</span>(long_b - long_a);<br>    <span class="hljs-keyword">return</span> R * <span class="hljs-built_in">acos</span>(c);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> north_province[<span class="hljs-number">15</span>] = &#123;<span class="hljs-string">&quot;济南市&quot;</span>, <span class="hljs-string">&quot;石家庄市&quot;</span>, <span class="hljs-string">&quot;天津市&quot;</span>, <span class="hljs-string">&quot;北京市&quot;</span>, <span class="hljs-string">&quot;沈阳市&quot;</span>,<br>                                 <span class="hljs-string">&quot;长春市&quot;</span>, <span class="hljs-string">&quot;哈尔滨市&quot;</span>, <span class="hljs-string">&quot;郑州市&quot;</span>, <span class="hljs-string">&quot;太原市&quot;</span>, <span class="hljs-string">&quot;西安市&quot;</span>,<br>                                 <span class="hljs-string">&quot;呼和浩特市&quot;</span>, <span class="hljs-string">&quot;兰州市&quot;</span>, <span class="hljs-string">&quot;银川市&quot;</span>, <span class="hljs-string">&quot;西宁市&quot;</span>, <span class="hljs-string">&quot;乌鲁木齐市&quot;</span>&#125;;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; region_map;<br>    city c[<span class="hljs-number">35</span>];<br>    edge chosen[<span class="hljs-number">35</span>], low_cost[<span class="hljs-number">35</span>];<br>    <span class="hljs-keyword">double</span> graph[<span class="hljs-number">35</span>][<span class="hljs-number">35</span>] = &#123;SUP&#125;;<br>    <span class="hljs-keyword">int</span> visit[<span class="hljs-number">35</span>] = &#123;<span class="hljs-number">0</span>&#125;, flag = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, last_visit, cnt = <span class="hljs-number">0</span>, north_tag;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;position.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (!fin.eof())&#123;<br>        fin&gt;&gt;c[n].name&gt;&gt;c[n].longitude&gt;&gt;c[n].latitude;<br>        north_tag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span> (north_province[i] == c[n].name)&#123;<br>                region_map[n] = <span class="hljs-number">0</span>;<br>                north_tag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (north_tag == <span class="hljs-number">0</span>) region_map[n] = <span class="hljs-number">1</span>;<br>        n++;<br>    &#125;<br>    <span class="hljs-comment">//Build the graph</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(i == j) graph[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">double</span> dist = earth_dist(&amp;c[i], &amp;c[j]);<br>                graph[i][j] = dist;<br>                graph[j][i] = dist;<br>            &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        low_cost[i] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, SUP&#125;;<br>    &#125;<br>    visit[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    last_visit = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//Connect northern city</span><br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(region_map[i] == <span class="hljs-number">0</span> &amp;&amp; visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>                low_cost[i].from = last_visit;<br>                low_cost[i].to = i;<br>                low_cost[i].weight = graph[last_visit][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> min_edge_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">double</span> min_edge_dist = SUP;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span>(low_cost[i].weight != <span class="hljs-number">-1.0</span> &amp;&amp; low_cost[i].weight &lt; min_edge_dist)&#123;<br>                min_edge_dist = low_cost[i].weight;<br>                min_edge_idx = i;<br>            &#125;<br>        &#125;<br>        chosen[cnt] = low_cost[min_edge_idx];<br>        visit[min_edge_idx] = <span class="hljs-number">1</span>;<br>        low_cost[min_edge_idx] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1.0</span>&#125;;<br>        last_visit = min_edge_idx;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(region_map[i] == <span class="hljs-number">0</span> &amp;&amp; visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        low_cost[i] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, SUP&#125;;<br>    &#125;<br>    visit[<span class="hljs-number">12</span>] = <span class="hljs-number">1</span>;<br>    last_visit = <span class="hljs-number">12</span>;<br>    <span class="hljs-comment">//Connect southern city</span><br>    <span class="hljs-keyword">while</span> (!flag)&#123;<br>        flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(region_map[i] == <span class="hljs-number">1</span> &amp;&amp; visit[i] == <span class="hljs-number">0</span> &amp;&amp; graph[last_visit][i] &lt; low_cost[i].weight)&#123;<br>                low_cost[i].from = last_visit;<br>                low_cost[i].to = i;<br>                low_cost[i].weight = graph[last_visit][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> min_edge_idx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">double</span> min_edge_dist = SUP;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span>(low_cost[i].weight != <span class="hljs-number">-1.0</span> &amp;&amp; low_cost[i].weight &lt; min_edge_dist)&#123;<br>                min_edge_dist = low_cost[i].weight;<br>                min_edge_idx = i;<br>            &#125;<br>        &#125;<br>        chosen[cnt] = low_cost[min_edge_idx];<br>        visit[min_edge_idx] = <span class="hljs-number">1</span>;<br>        low_cost[min_edge_idx] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1.0</span>&#125;;<br>        last_visit = min_edge_idx;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">if</span>(region_map[i] == <span class="hljs-number">1</span> &amp;&amp; visit[i] == <span class="hljs-number">0</span>)&#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> min_from, min_to;<br>    <span class="hljs-keyword">double</span> min_dist = SUP;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>            <span class="hljs-keyword">int</span> spec = (region_map[i] == <span class="hljs-number">0</span> &amp;&amp; region_map[j] == <span class="hljs-number">1</span>) || (region_map[i] == <span class="hljs-number">1</span> &amp;&amp; region_map[j] == <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (spec &amp;&amp; graph[i][j] &lt; min_dist)&#123;<br>                min_from = i;<br>                min_to = j;<br>                min_dist = graph[i][j];<br>            &#125;<br>        &#125;<br>    chosen[cnt].from = min_from;<br>    chosen[cnt].to = min_to;<br>    chosen[cnt].weight = min_dist;<br>    cnt++;<br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;c[chosen[i].from].name&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;c[chosen[i].to].name&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;chosen[i].weight&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        sum += chosen[i].weight;<br>    &#125;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;总长度: &quot;</span>&lt;&lt;sum&lt;&lt;<span class="hljs-string">&quot;km&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法正确性">算法正确性</h2><h3 id="整个电网的长度最短-1">整个电网的长度最短</h3><p>利用Prim算法，每次选择已连通节点集到未连通相邻节点集中最小的边连通，并更新相邻节点集及对应的最小边，最终即可得到长度最短的电网图。</p><h3 id="在西宁与郑州拉一根直达专线的情况下使得整个电网长度最短-1">在西宁与郑州拉一根直达专线的情况下，使得整个电网长度最短</h3><p>先将西宁到郑州的边加入电网图，并更新西宁和郑州的相邻节点，再以西宁或郑州为起点执行<strong>(1)</strong>的步骤。</p><h3 id="不仅在西宁与郑州之间拉直达专线还在杭州与长沙之间拉直达专线的情况下使得整个电网长度最短-1">不仅在西宁与郑州之间拉直达专线，还在杭州与长沙之间拉直达专线的情况下，使得整个电网长度最短</h3><p>在<strong>(2)</strong>的基础上，当电网图扩展到杭州或长沙时，将杭州到长沙的边加入电网图，并更新杭州和长沙的相邻节点，再以杭州或长沙为起点继续扩展电网图。</p><h3 id="在香港与澳门澳门与广州不拉直达线路的前提之下使得整个电网的长度最短-1">在香港与澳门、澳门与广州不拉直达线路的前提之下，使得整个电网的长度最短</h3><p>在<strong>(1)</strong>的基础上，当电网图扩展到香港、澳门或广州时，不更新其禁连通节点的最小边，即可避免算法选择非法边。</p><h3 id="在南方省份和北方省份之间仅规划一条直通专线使得整个电网的长度最短-1">在南方省份和北方省份之间仅规划一条直通专线，使得整个电网的长度最短</h3><p>将南方省份和北方省份分别看作两张图，并使用(1)的方法分别生成两张电网图，最后找出南方省份中到北方省份最近的一条边加入电网图，即可得到一张全连通的电网图。由于初始位置对Prim算法没有影响，故可以保证得到的电网长度最短。</p><h2 id="输出各组实验的电网数据表以及电网总长度并且通过可视化方式进行呈现">输出各组实验的电网数据表，以及电网总长度，并且通过可视化方式进行呈现</h2><h3 id="整个电网的长度最短-2">整个电网的长度最短</h3><p>沈阳市-&gt;长春市 279.076km</p><p>长春市-&gt;哈尔滨市 232.473km</p><p>沈阳市-&gt;天津市 605.429km</p><p>天津市-&gt;北京市 109.744km</p><p>天津市-&gt;石家庄市 262.662km</p><p>石家庄市-&gt;太原市 172.534km</p><p>石家庄市-&gt;济南市 268.228km</p><p>太原市-&gt;呼和浩特市 338.861km</p><p>太原市-&gt;郑州市 358.809km</p><p>郑州市-&gt;西安市 435.687km</p><p>郑州市-&gt;合肥市 465.513km</p><p>合肥市-&gt;南京市 141.475km</p><p>南京市-&gt;杭州市 235.447km</p><p>杭州市-&gt;上海市 164.04km</p><p>合肥市-&gt;武汉市 317.307km</p><p>武汉市-&gt;南昌市 262.154km</p><p>南昌市-&gt;长沙市 289.531km</p><p>南昌市-&gt;福州市 444.143km</p><p>福州市-&gt;台北市 250.622km</p><p>西安市-&gt;兰州市 505.96km</p><p>兰州市-&gt;西宁市 194.278km</p><p>兰州市-&gt;银川市 343.112km</p><p>长沙市-&gt;广州市 564.43km</p><p>广州市-&gt;澳门 106.634km</p><p>澳门-&gt;香港 64.0048km</p><p>澳门-&gt;海口市 421.967km</p><p>海口市-&gt;南宁市 365.228km</p><p>南宁市-&gt;贵阳市 447.881km</p><p>贵阳市-&gt;重庆市 329.197km</p><p>重庆市-&gt;成都市 265.982km</p><p>贵阳市-&gt;昆明市 435.472km</p><p>成都市-&gt;拉萨市 1249.67km</p><p>西宁市-&gt;乌鲁木齐市 1441.9km</p><p>总长度: 12369.5km</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><h3 id="在西宁与郑州拉一根直达专线的情况下使得整个电网长度最短-2">在西宁与郑州拉一根直达专线的情况下，使得整个电网长度最短</h3><p>西宁市-&gt;郑州市 1092.57km</p><p>西宁市-&gt;兰州市 194.278km</p><p>兰州市-&gt;银川市 343.112km</p><p>郑州市-&gt;太原市 358.809km</p><p>太原市-&gt;石家庄市 172.534km</p><p>石家庄市-&gt;天津市 262.662km</p><p>天津市-&gt;北京市 109.744km</p><p>石家庄市-&gt;济南市 268.228km</p><p>太原市-&gt;呼和浩特市 338.861km</p><p>郑州市-&gt;西安市 435.687km</p><p>郑州市-&gt;合肥市 465.513km</p><p>合肥市-&gt;南京市 141.475km</p><p>南京市-&gt;杭州市 235.447km</p><p>杭州市-&gt;上海市 164.04km</p><p>合肥市-&gt;武汉市 317.307km</p><p>武汉市-&gt;南昌市 262.154km</p><p>南昌市-&gt;长沙市 289.531km</p><p>南昌市-&gt;福州市 444.143km</p><p>福州市-&gt;台北市 250.622km</p><p>长沙市-&gt;广州市 564.43km</p><p>广州市-&gt;澳门 106.634km</p><p>澳门-&gt;香港 64.0048km</p><p>澳门-&gt;海口市 421.967km</p><p>海口市-&gt;南宁市 365.228km</p><p>南宁市-&gt;贵阳市 447.881km</p><p>贵阳市-&gt;重庆市 329.197km</p><p>重庆市-&gt;成都市 265.982km</p><p>贵阳市-&gt;昆明市 435.472km</p><p>天津市-&gt;沈阳市 605.429km</p><p>沈阳市-&gt;长春市 279.076km</p><p>长春市-&gt;哈尔滨市 232.473km</p><p>成都市-&gt;拉萨市 1249.67km</p><p>西宁市-&gt;乌鲁木齐市 1441.9km</p><p>总长度: 12956.1km</p><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h3 id="不仅在西宁与郑州之间拉直达专线还在杭州与长沙之间拉直达专线的情况下使得整个电网长度最短-2">不仅在西宁与郑州之间拉直达专线，还在杭州与长沙之间拉直达专线的情况下，使得整个电网长度最短</h3><p>西宁市-&gt;郑州市 1092.57km</p><p>西宁市-&gt;兰州市 194.278km</p><p>兰州市-&gt;银川市 343.112km</p><p>郑州市-&gt;太原市 358.809km</p><p>太原市-&gt;石家庄市 172.534km</p><p>石家庄市-&gt;天津市 262.662km</p><p>天津市-&gt;北京市 109.744km</p><p>石家庄市-&gt;济南市 268.228km</p><p>太原市-&gt;呼和浩特市 338.861km</p><p>郑州市-&gt;西安市 435.687km</p><p>郑州市-&gt;合肥市 465.513km</p><p>合肥市-&gt;南京市 141.475km</p><p>南京市-&gt;杭州市 235.447km</p><p>杭州市-&gt;长沙市 733.531km</p><p>杭州市-&gt;上海市 164.04km</p><p>长沙市-&gt;南昌市 289.531km</p><p>南昌市-&gt;武汉市 262.154km</p><p>南昌市-&gt;福州市 444.143km</p><p>福州市-&gt;台北市 250.622km</p><p>长沙市-&gt;广州市 564.43km</p><p>广州市-&gt;澳门 106.634km</p><p>澳门-&gt;香港 64.0048km</p><p>澳门-&gt;海口市 421.967km</p><p>海口市-&gt;南宁市 365.228km</p><p>南宁市-&gt;贵阳市 447.881km</p><p>贵阳市-&gt;重庆市 329.197km</p><p>重庆市-&gt;成都市 265.982km</p><p>贵阳市-&gt;昆明市 435.472km</p><p>天津市-&gt;沈阳市 605.429km</p><p>沈阳市-&gt;长春市 279.076km</p><p>长春市-&gt;哈尔滨市 232.473km</p><p>成都市-&gt;拉萨市 1249.67km</p><p>西宁市-&gt;乌鲁木齐市 1441.9km</p><p>总长度: 13372.3km</p><figure><img src="3.png" alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><h3 id="在香港与澳门澳门与广州不拉直达线路的前提之下使得整个电网的长度最短-2">在香港与澳门、澳门与广州不拉直达线路的前提之下，使得整个电网的长度最短</h3><p>沈阳市-&gt;长春市 279.076km</p><p>长春市-&gt;哈尔滨市 232.473km</p><p>沈阳市-&gt;天津市 605.429km</p><p>天津市-&gt;北京市 109.744km</p><p>天津市-&gt;石家庄市 262.662km</p><p>石家庄市-&gt;太原市 172.534km</p><p>石家庄市-&gt;济南市 268.228km</p><p>太原市-&gt;呼和浩特市 338.861km</p><p>太原市-&gt;郑州市 358.809km</p><p>郑州市-&gt;西安市 435.687km</p><p>郑州市-&gt;合肥市 465.513km</p><p>合肥市-&gt;南京市 141.475km</p><p>南京市-&gt;杭州市 235.447km</p><p>杭州市-&gt;上海市 164.04km</p><p>合肥市-&gt;武汉市 317.307km</p><p>武汉市-&gt;南昌市 262.154km</p><p>南昌市-&gt;长沙市 289.531km</p><p>南昌市-&gt;福州市 444.143km</p><p>福州市-&gt;台北市 250.622km</p><p>西安市-&gt;兰州市 505.96km</p><p>兰州市-&gt;西宁市 194.278km</p><p>兰州市-&gt;银川市 343.112km</p><p>长沙市-&gt;广州市 564.43km</p><p>广州市-&gt;香港 131.027km</p><p>广州市-&gt;海口市 467.756km</p><p>海口市-&gt;南宁市 365.228km</p><p>海口市-&gt;澳门 421.967km</p><p>南宁市-&gt;贵阳市 447.881km</p><p>贵阳市-&gt;重庆市 329.197km</p><p>重庆市-&gt;成都市 265.982km</p><p>贵阳市-&gt;昆明市 435.472km</p><p>成都市-&gt;拉萨市 1249.67km</p><p>西宁市-&gt;乌鲁木齐市 1441.9km</p><p>总长度: 12797.6km</p><figure><img src="4.png" alt="4" /><figcaption aria-hidden="true">4</figcaption></figure><h3 id="在南方省份和北方省份之间仅规划一条直通专线使得整个电网的长度最短-2">在南方省份和北方省份之间仅规划一条直通专线，使得整个电网的长度最短</h3><p>与(1)结果相同</p><h2 id="总结">总结</h2><p>电网规划问题本质上就是求最小生成树。由于两两城市均可连通，故为一张稠密图，因此使用Prim算法更加合适。Prim算法可在 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的时间内求出一张对应的最小生成树，而实验中对特殊情况处理的时间复杂度均未超过 <span class="math inline">\(\mathcal{O}(n^2)\)</span>，因此总时间代价仍为 <span class="math inline">\(\mathcal{O}(n^2)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Malloc Lab实验记录</title>
    <link href="/2020/12/15/computer-system/csapp-malloclab/"/>
    <url>/2020/12/15/computer-system/csapp-malloclab/</url>
    
    <content type="html"><![CDATA[<p>Malloc Lab要求我们利用CSAPP中9.9节所介绍的技术设计一个简单的动态内存分配器，并且尽可能的使得分配效率最高且空间利用率最大。一个基本的思路便是先构建一个内存分配器的框架，并在此基础上不断优化使得效率和空间使用率均相对达到最优。</p><a id="more"></a><h2 id="概览">概览</h2><p>首先我们来看一下Lab的基本情况。在Lab的<strong>mm.c</strong>文件中提供了一个最简单的动态内存分配器，我们需要实现以下四个函数以实现更加高效紧凑的内存分配：</p><ul><li><strong>mm_init</strong>：初始化堆</li><li><strong>mm_malloc</strong>：在堆中申请一段空间</li><li><strong>mm_free</strong>：在堆中释放一段之前申请的空间</li><li><strong>mm_realloc</strong>：重新调整之前申请的空间大小</li></ul><p>为了方便起见，Lab在<strong>memlib.c</strong>中为我们提供了一些封装好的基础函数可供我们调用：</p><ul><li><strong>mem_sbrk</strong>：改变堆大小（仅能扩张堆）</li><li><strong>mem_heap_lo</strong>：返回指向堆首的指针</li><li><strong>mem_heap_hi</strong>：返回指向堆尾的指针</li><li><strong>mem_heapsize</strong>：返回当前的堆大小</li><li><strong>mem_pagesize</strong>：返回系统页大小</li></ul><p>我们可以使用Lab为我们提供的<strong>mdriver</strong>工具装载预先设计好的<strong>Trace</strong>文件测试我们的内存分配器效率和空间使用率：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> ./mdriver -V -f shortX-bal.rep <span class="hljs-comment"># X代表Trace文件编号</span></span><br></code></pre></td></tr></table></figure><h2 id="基本功能">基本功能</h2><h3 id="宏定义">宏定义</h3><p>首先我们仿照CSAPP中9.9.12的例子定义一组宏以方便后续的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WSIZE 4   <span class="hljs-comment">//字大小（Bytes）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DSIZE 8   <span class="hljs-comment">//双字大小（Bytes）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CHUNKSIZE (1&lt;&lt;12) <span class="hljs-comment">//扩展堆的最小大小（Bytes）</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(x,y) ((x) &gt; (y)? (x):(y)) <span class="hljs-comment">//求二者最大值</span></span><br><span class="hljs-comment">//将块大小和使用标识符组合进一个字中</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PACK(size,alloc) ((size) | (alloc))</span><br><span class="hljs-comment">//将任意指针转为一个字指针</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET(p) (*(unsigned int *)(p))</span><br><span class="hljs-comment">//在指针位置放入长度为一个字的值</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PUT(p,val) (*(unsigned int *)(p)=(val))</span><br><span class="hljs-comment">//将任意指针转为通用指针</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_ADDRESS(p) (*(void **)(p))</span><br><span class="hljs-comment">//从头部获取块大小</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span><br><span class="hljs-comment">//从头部获取使用标识符</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span><br><span class="hljs-comment">//计算块头部位置</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HDRP(bp) ((char *)(bp)-WSIZE)</span><br><span class="hljs-comment">//计算块尾部位置</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FTRP(bp) ((char *)(bp)+ GET_SIZE(HDRP(bp))-DSIZE)</span><br><span class="hljs-comment">//计算有效载荷大小</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GET_PAYLOAD(bp) (GET_SIZE(HDRP(bp))-DSIZE) </span><br><span class="hljs-comment">//计算后一个块的位置</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp)+GET_SIZE(((char *)(bp)-WSIZE)))</span><br><span class="hljs-comment">//计算前一个块的位置</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(((char *)(bp)-DSIZE)))</span><br></code></pre></td></tr></table></figure><h3 id="堆初始化">堆初始化</h3><p>堆初始化的一个基本作用就是向内存系统申请一块初始空间并标识为空闲状态。不过我们会发现，这一行为和后续当需要额外向系统申请新的空间时的行为完全相同，因此我们可以将这一逻辑封装为一个单独的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">extend_heap</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> words)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *bp; <span class="hljs-comment">//新空间的起始指针</span><br>    <span class="hljs-keyword">size_t</span> size;<br>  <span class="hljs-comment">//向上对齐为双字的倍数</span><br>    size=(words %<span class="hljs-number">2</span>)? (words+<span class="hljs-number">1</span>)*WSIZE: words*WSIZE;<br>  <span class="hljs-comment">//向系统申请空间</span><br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)(bp = mem_sbrk(size)) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-comment">//设置块头部</span><br>    PUT(HDRP(bp),PACK(size,<span class="hljs-number">0</span>));<br>  <span class="hljs-comment">//设置块尾部</span><br>    PUT(FTRP(bp),PACK(size,<span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)bp;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是初始化函数可以被写成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mm_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE)==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="申请空间">申请空间</h3><p>现在我们来考虑如何响应用户的空间申请。由于堆需要保持双字对其，我们必须将用户的申请要求向上对齐为双字大小。而由于一个块还需要额外的双字空间用于存放块头部和块尾部，因此一次申请的空间必须为四字以上。随后我们需要找到合适的位置分配给用户的这一申请，由于后续我们需要不断优化分配的算法，因此我们将这一过程单独封装。此外，如果当前堆中找不到合适的位置分配给用户，我们还需要申请额外的空间以满足用户的需求。于是空间申请函数的基本构架就可以写成这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> asize; <span class="hljs-comment">//实际分配的大小</span><br>    <span class="hljs-keyword">size_t</span> extendsize; <span class="hljs-comment">//扩展堆大小</span><br>    <span class="hljs-keyword">char</span> *bp;<br>  <span class="hljs-comment">//申请空间大小为0的情况</span><br>    <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <span class="hljs-comment">//向上对齐</span><br>    <span class="hljs-keyword">if</span>(size&lt;=DSIZE)<br>        asize=<span class="hljs-number">2</span>*DSIZE;<br>    <span class="hljs-keyword">else</span><br>        asize=DSIZE*((size+(DSIZE)+(DSIZE<span class="hljs-number">-1</span>))/DSIZE);<br><span class="hljs-comment">//寻找合适的位置并分配空间</span><br>    <span class="hljs-keyword">if</span>((bp=find_fit(asize))!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        place(bp,asize);<br>        <span class="hljs-keyword">return</span> bp;<br>    &#125;<br>  <span class="hljs-comment">//当空间不够使扩展堆大小</span><br>    extendsize = MAX(asize, CHUNKSIZE);<br>    <span class="hljs-keyword">if</span>((bp=extend_heap(extendsize/WSIZE))==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <span class="hljs-comment">//分配空间</span><br>    place(bp,asize);<br>    <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="释放空间">释放空间</h3><p>释放空间本质上就是把块头部的使用标识符从已使用改为空闲状态，因此我们可以快速实现出这一函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mm_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> size=GET_SIZE(HDRP(ptr)); <span class="hljs-comment">//块大小</span><br>  <span class="hljs-comment">//将头部设置为空闲状态</span><br>    PUT(HDRP(ptr),PACK(size,<span class="hljs-number">0</span>));<br>  <span class="hljs-comment">//将尾部设置为空闲状态</span><br>    PUT(FTRP(ptr),PACK(size,<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>不过进一步思考我们会发现，当有多个连续的空闲块时，我们需要在释放时将其合并。由于空闲块可能在新释放的块之前或之后，因此我们需要讨论所有情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">coalesce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *bp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp))); <span class="hljs-comment">//前一个块是否空闲</span><br>    <span class="hljs-keyword">size_t</span> next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp))); <span class="hljs-comment">//后一个块是否空闲</span><br>    <span class="hljs-keyword">size_t</span> size=GET_SIZE(HDRP(bp)); <span class="hljs-comment">//块大小</span><br>  <span class="hljs-comment">//前后都不空闲</span><br>    <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; next_alloc)<br>    &#123;<br>        <span class="hljs-keyword">return</span> bp;<br>    &#125;<br>  <span class="hljs-comment">//前一个块空闲</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)<br>    &#123;<br>        size+=GET_SIZE(HDRP(NEXT_BLKP(bp)));<br>        PUT(HDRP(bp),PACK(size,<span class="hljs-number">0</span>));<br>        PUT(FTRP(bp),PACK(size,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> bp;<br>    &#125;<br>  <span class="hljs-comment">//后一个块空闲</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)<br>    &#123;<br>        size+=GET_SIZE(FTRP(PREV_BLKP(bp)));<br>        PUT(FTRP(bp),PACK(size,<span class="hljs-number">0</span>));<br>        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> PREV_BLKP(bp);<br>    &#125;<br>  <span class="hljs-comment">//前后都空闲</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        size+=(GET_SIZE(HDRP(NEXT_BLKP(bp)))+GET_SIZE(FTRP(PREV_BLKP(bp))));<br>        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="hljs-number">0</span>));<br>        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> PREV_BLKP(bp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在合并的过程中，我们还需要考虑遇到堆的前后边界时的情况。我们可以利用CSAPP中介绍的通过在堆首和堆尾引入首位块的方法规避这一问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mm_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//申请空间存放首位块</span><br>    <span class="hljs-keyword">if</span>((head_listp = mem_sbrk(<span class="hljs-number">4</span>*WSIZE)) == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-comment">//填充</span><br>    PUT(head_listp,<span class="hljs-number">0</span>);<br>  <span class="hljs-comment">//序言块首</span><br>    PUT(head_listp+(<span class="hljs-number">1</span>*WSIZE),PACK(DSIZE,<span class="hljs-number">1</span>));<br>  <span class="hljs-comment">//序言块尾</span><br>    PUT(head_listp+(<span class="hljs-number">2</span>*WSIZE),PACK(DSIZE,<span class="hljs-number">1</span>));<br>  <span class="hljs-comment">//结尾块首</span><br>    PUT(head_listp+(<span class="hljs-number">3</span>*WSIZE),PACK(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));<br>  <span class="hljs-comment">//堆首指针指向序言块</span><br>    head_listp += (<span class="hljs-number">2</span>*WSIZE);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，在扩展堆大小的时候，我们也需要考虑到合并的情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">extend_heap</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> words)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">return</span> coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调整空间大小">调整空间大小</h3><p>当用户需要调整空间的大小时，我们需要考虑所有可能的情况。如果这一行为相当于申请更大的空间，我们可以先使用合并空闲块的思想将前后的空闲块合并进来，当合并后的空间大小还不够时，我们就需要重新在堆中申请一块更大的空间，并将原本空间中的数据复制过去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//如果没有原始位置，相当于申请一块新的空间</span><br>    <span class="hljs-keyword">if</span>(ptr==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> mm_malloc(size);<br>  <span class="hljs-comment">//如果新空间大小为0，相当于释放原本的空间</span><br>    <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)<br>    &#123; <br>        mm_free(ptr);<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br>    <span class="hljs-keyword">size_t</span> asize=<span class="hljs-number">0</span>; <span class="hljs-comment">//实际分配大小</span><br>  <span class="hljs-comment">//对齐处理</span><br>    <span class="hljs-keyword">if</span>(size&lt;=DSIZE)<br>        asize=<span class="hljs-number">2</span>*DSIZE;<br>    <span class="hljs-keyword">else</span><br>        asize=DSIZE*((size+(DSIZE)+(DSIZE<span class="hljs-number">-1</span>))/DSIZE);<br>    <span class="hljs-keyword">if</span>(ptr!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">size_t</span> oldsize=GET_PAYLOAD(ptr); <span class="hljs-comment">//获取原本的有效载荷大小</span><br>      <span class="hljs-comment">//原本大小小于新申请空间的大小</span><br>        <span class="hljs-keyword">if</span>(oldsize&lt;size)<br>        &#123;<br>            <span class="hljs-keyword">void</span>* newptr=recoalesce(ptr,asize); <span class="hljs-comment">//尝试合并前后块</span><br>          <span class="hljs-comment">//合并空间无法满足需求，申请额外的空间</span><br>            <span class="hljs-keyword">if</span>(newptr==<span class="hljs-literal">NULL</span>)<br>            &#123;<br>                newptr=mm_malloc(asize); <span class="hljs-comment">//申请新空间</span><br>                <span class="hljs-built_in">memcpy</span>(newptr,ptr,oldsize); <span class="hljs-comment">//复制数据</span><br>                mm_free(ptr); <span class="hljs-comment">//释放原空间</span><br>                <span class="hljs-keyword">return</span> newptr;<br>            &#125;<br>          <span class="hljs-comment">//合并后空间能够满足需求</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> newptr;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//原本大小和新空间大小一致</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(oldsize==size)<br>        &#123;<br>            <span class="hljs-keyword">return</span> ptr;<br>        &#125;<br>      <span class="hljs-comment">//原本大小大于新空间大小</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> ptr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//合并前后空闲块</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">recoalesce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *bp,<span class="hljs-keyword">size_t</span> needsize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp))); <span class="hljs-comment">//前一个块是否空闲</span><br>    <span class="hljs-keyword">size_t</span> next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp))); <span class="hljs-comment">//后一个块是否空闲</span><br>    <span class="hljs-keyword">size_t</span> size=GET_SIZE(HDRP(bp)); <span class="hljs-comment">//当前块大小</span><br>  <span class="hljs-comment">//前后都不空闲</span><br>    <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; next_alloc)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <span class="hljs-comment">//后一个块空闲</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)<br>    &#123;<br>        size += GET_SIZE(HDRP(NEXT_BLKP(bp))); <span class="hljs-comment">//合并后一个块后的大小</span><br>        <span class="hljs-keyword">if</span>(size&lt;needsize)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            PUT(HDRP(bp),PACK(size,<span class="hljs-number">1</span>));<br>            PUT(FTRP(bp),PACK(size,<span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">return</span> bp;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">//前一个块空闲</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)<br>    &#123;<br>        size += GET_SIZE(HDRP(PREV_BLKP(bp)));<br>        <span class="hljs-keyword">if</span>(size&lt;needsize)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">size_t</span> thissize=GET_PAYLOAD(bp); <span class="hljs-comment">//当前有效载荷大小</span><br>            <span class="hljs-keyword">void</span>* prev_point=PREV_BLKP(bp); <span class="hljs-comment">//前一个块的位置</span><br>            PUT(FTRP(bp),PACK(size,<span class="hljs-number">1</span>));<br>            PUT(HDRP(prev_point),PACK(size,<span class="hljs-number">1</span>));<br>            <span class="hljs-built_in">memcpy</span>(prev_point,bp,thissize); <span class="hljs-comment">//向前复制数据</span><br>            <span class="hljs-keyword">return</span> prev_point;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">//前后都空闲</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        size += (GET_SIZE(HDRP(NEXT_BLKP(bp)))+GET_SIZE(FTRP(PREV_BLKP(bp))));<br>        <span class="hljs-keyword">if</span>(size&lt;needsize)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">size_t</span> thissize=GET_PAYLOAD(bp);<br>            <span class="hljs-keyword">void</span>* prev_point=PREV_BLKP(bp);<br>            PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="hljs-number">1</span>));<br>            PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="hljs-number">1</span>));<br>            <span class="hljs-built_in">memcpy</span>(prev_point,bp,thissize);<br>            <span class="hljs-keyword">return</span> prev_point;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="性能优化">性能优化</h2><p>前面我们使用隐式链表的方式实现了内存分配器的基本逻辑。但以这种方式实现的内存分配器效率极低且会产生大量的外部碎片，因此我们需要对其逐步优化。</p><h3 id="显式分离存储">显式分离存储</h3><p>在使用隐式链表存储块信息的情况下，搜索一个空闲块的平均时间复杂度为 <span class="math display">\[\mathcal{O}(n)\]</span>，当块的数量很大或空闲块分布较为稀疏时，搜索效率就会变得极低。如果我们显式地将空闲块连在一起，搜索效率会得到一定的提高，然而，每当我们需要释放一段空间时，就需要在空闲链表中搜索合适的位置放置新的空闲块，这一操作有可能使得总时间复杂度再次退化到 <span class="math display">\[\mathcal{O}(n)\]</span>，因此我们还需要使用CSAPP中介绍的分离链表的方式存储不同规模的空闲块。我们可以按照2的幂来划分每个空闲链表的大小范围，这里一共划分成了10类：<span class="math display">\[(0,8],(9,16],(17,32],(33,64],(65,128],(129,256],(257,512],(513,2048],(2049,4096],(4097, +\infty)\]</span></p><p>我们可以通过一个指针数据来保存每张链表的头位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> MAX_SIZE=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>* linkhead[<span class="hljs-number">10</span>]=&#123;<span class="hljs-literal">NULL</span>&#125;;  <br></code></pre></td></tr></table></figure><p>随后我们实现一个根据块大小计算属于哪一张链表的辅助函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findlink</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">8</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">16</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">32</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">64</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">128</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">256</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">512</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">2048</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size&lt;=<span class="hljs-number">4096</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们就可以实现空闲块的插入和删除逻辑了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//向对应的空闲链表中插入空闲块</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">placefree</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* bp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> index=findlink(GET_SIZE(HDRP(bp))); <span class="hljs-comment">//空闲链表头下标</span><br>    <span class="hljs-keyword">void</span>* head=linkhead[index]; <span class="hljs-comment">//空闲链表入口</span><br>  <span class="hljs-comment">//相应链表未初始化时</span><br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">//把当前块作为标首</span><br>        linkhead[index]=bp;<br>        GET_ADDRESS(PRED(bp))=<span class="hljs-literal">NULL</span>;<br>        GET_ADDRESS(SUCC(bp))=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">size_t</span> bpsize=GET_SIZE(HDRP(bp)); <span class="hljs-comment">//当前块大小</span><br>        <span class="hljs-keyword">void</span>* temp=<span class="hljs-literal">NULL</span>;<br>      <span class="hljs-comment">//移动到链表中和当前块大小最接近的元素前</span><br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            temp=head;<br>            <span class="hljs-keyword">if</span>(GET_SIZE(HDRP(head))&gt;=bpsize) <span class="hljs-keyword">break</span>;<br>            head=GET_ADDRESS(SUCC(head));<br>        &#125;<br>      <span class="hljs-comment">//插入当前块</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            GET_ADDRESS(SUCC(temp))=bp;<br>            GET_ADDRESS(PRED(bp))=temp;<br>            GET_ADDRESS(SUCC(bp))=<span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(head==linkhead[index])<br>            &#123;<br>                GET_ADDRESS(PRED(head))=bp;<br>                GET_ADDRESS(SUCC(bp))=head;<br>                GET_ADDRESS(PRED(bp))=<span class="hljs-literal">NULL</span>;<br>                linkhead[index]=bp;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                GET_ADDRESS(SUCC(GET_ADDRESS(PRED(head))))=bp;<br>                GET_ADDRESS(PRED(bp))=GET_ADDRESS(PRED(head));<br>                GET_ADDRESS(SUCC(bp))=head;<br>                GET_ADDRESS(PRED(head))=bp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//从对应的空闲链表中删除块</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deletefree</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* bp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> index=findlink(GET_SIZE(HDRP(bp)));<br>  <span class="hljs-comment">//特判</span><br>    <span class="hljs-keyword">if</span>(linkhead[index]==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freelist is empty!&quot;</span>);<br>  <span class="hljs-comment">//链表中仅有一个元素时</span><br>    <span class="hljs-keyword">if</span>(GET_ADDRESS(PRED(bp))==<span class="hljs-literal">NULL</span> &amp;&amp; GET_ADDRESS(SUCC(bp))==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        linkhead[index]=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <span class="hljs-comment">//当前元素为表首元素时</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GET_ADDRESS(PRED(bp))==<span class="hljs-literal">NULL</span> &amp;&amp; GET_ADDRESS(SUCC(bp))!=<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        GET_ADDRESS(PRED(GET_ADDRESS(SUCC(bp))))=<span class="hljs-literal">NULL</span>;<br>        linkhead[index]=GET_ADDRESS(SUCC(bp));<br>        GET_ADDRESS(SUCC(bp))=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <span class="hljs-comment">//当前元素为表尾元素时</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(GET_ADDRESS(PRED(bp))!=<span class="hljs-literal">NULL</span> &amp;&amp; GET_ADDRESS(SUCC(bp))==<span class="hljs-literal">NULL</span>)<br>    &#123;<br>        GET_ADDRESS(SUCC(GET_ADDRESS(PRED(bp))))=<span class="hljs-literal">NULL</span>;<br>        GET_ADDRESS(PRED(bp))=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>  <span class="hljs-comment">//当前元素在表的中间位置时</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        GET_ADDRESS(SUCC(GET_ADDRESS(PRED(bp))))=GET_ADDRESS(SUCC(bp));<br>        GET_ADDRESS(PRED(GET_ADDRESS(SUCC(bp))))=GET_ADDRESS(PRED(bp));<br>        GET_ADDRESS(PRED(bp))=GET_ADDRESS(SUCC(bp))=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后我们需要在合并空闲块时引入这一管理机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">coalesce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *bp)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>    <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; next_alloc)<br>    &#123;<br>        placefree(bp); <span class="hljs-comment">//向空闲链表插入当前块</span><br>        ...<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)<br>    &#123;<br>        deletefree(NEXT_BLKP(bp)); <span class="hljs-comment">//从空闲链表中删除后一个块</span><br>        ...<br>        placefree(bp);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)<br>    &#123;<br>        deletefree(PREV_BLKP(bp)); <span class="hljs-comment">//从空闲链表中删除前一个块</span><br>        ...<br>        placefree(PREV_BLKP(bp)); <span class="hljs-comment">//向空闲链表插入更新过的前一个块</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        deletefree(PREV_BLKP(bp)); <span class="hljs-comment">//从空闲链表中删除前一个块</span><br>        deletefree(NEXT_BLKP(bp)); <span class="hljs-comment">//从空闲链表中删除后一个块</span><br>        ...<br>        placefree(PREV_BLKP(bp)); <span class="hljs-comment">//向空闲链表插入更新过的前一个块</span><br>        ...<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">recoalesce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *bp,<span class="hljs-keyword">size_t</span> needsize)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)<br>    &#123;<br>        ...<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            deletefree(NEXT_BLKP(bp));<br>            ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)<br>    &#123;<br>        ...<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ...<br>            deletefree(prev_point);<br>            ...<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        ...<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ...<br>            deletefree(prev_point);<br>            deletefree(NEXT_BLKP(bp));<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分离适配">分离适配</h3><p>有了分离存储的结构后，我们就可以使用分离适配的方法来寻找合适的块分配给用户的每一次空间请求了。其具体思路就是当用户申请某个大小的空间时，我们在其对应空间大小范围的链表中搜索，一旦搜索到一块不小于用户申请大小的块，就将其分配给用户。不过需要注意的是，如果分配给用户的块剩下的大小还可以单独形成一个新的空闲块，则需要将其分割成两个块。用代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//寻找合适的块</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">find_fit</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//遍历对应的链表</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> index=findlink(size);index&lt;MAX_SIZE;++index)<br>    &#123;<br>        <span class="hljs-keyword">void</span>* bp=linkhead[index];<br>        <span class="hljs-keyword">while</span>(bp!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-comment">//在找到第一个不小于用户申请大小的块时返回</span><br>            <span class="hljs-keyword">if</span>(GET_SIZE(HDRP(bp))&gt;=size) <span class="hljs-keyword">return</span> bp;<br>            bp=GET_ADDRESS(SUCC(bp));<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//如果找不到合适的空间则返回空</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//在块中分配空间</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* bp,<span class="hljs-keyword">size_t</span> asize)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//剩余块大小</span><br>    <span class="hljs-keyword">size_t</span> left=GET_SIZE(HDRP(bp))-asize;<br>    <span class="hljs-keyword">int</span> alloc=GET_ALLOC(HDRP(bp));<br>  <span class="hljs-comment">//如果块为空闲状态，则把它从空闲链表中移除</span><br>    <span class="hljs-keyword">if</span>(alloc==<span class="hljs-number">0</span>)<br>        deletefree(bp);<br>  <span class="hljs-comment">//剩余空间可以构成一个新块</span><br>    <span class="hljs-keyword">if</span>(left&gt;=(DSIZE*<span class="hljs-number">2</span>))<br>    &#123;<br>        PUT(HDRP(bp),PACK(asize,<span class="hljs-number">1</span>));<br>        PUT(FTRP(bp),PACK(asize,<span class="hljs-number">1</span>));<br>        PUT(HDRP(NEXT_BLKP(bp)),PACK(left,<span class="hljs-number">0</span>));<br>        PUT(FTRP(NEXT_BLKP(bp)),PACK(left,<span class="hljs-number">0</span>));<br>        coalesce(NEXT_BLKP(bp));<br><br>    &#125;<br>  <span class="hljs-comment">//剩余空间不能构成一个新块</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">size_t</span> allsize=GET_SIZE(HDRP(bp));<br>        PUT(HDRP(bp),PACK(allsize,<span class="hljs-number">1</span>));<br>        PUT(FTRP(bp),PACK(allsize,<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以证明，这种方法的空间利用率近似于对整个堆做最佳适配搜索，且其搜索效率明显优于对整个堆做最佳适配搜索。</p>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Computer-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2020/12/11/algorithm/course-exp/algorithm-exp10/"/>
    <url>/2020/12/11/algorithm/course-exp/algorithm-exp10/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><ol type="1"><li><strong>最优打印等待问题</strong> 某个班级有 <span class="math inline">\(m\)</span> 位同学一起去打印店打印实验报告。这个打印店只有一台打印机。由于各实验报告的厚薄不同，所需打印时间也不相同。同学 <span class="math inline">\(i\)</span> 需要的打印时间为 <span class="math inline">\(t_i(1 \leq i \leq m)\)</span>。应该应如何安排这些同学的打印次序使得平均等待时间最小？ <strong>输入数据格式：</strong>在文件students.txt中。第 <span class="math inline">\(1\)</span> 行是正整数 <span class="math inline">\(m\)</span>，表示有 <span class="math inline">\(m\)</span> 位同学。接下来的一行中有 <span class="math inline">\(m\)</span> 个正整数，表示 <span class="math inline">\(m\)</span> 个同学所需要的打印时间。 <strong>输出数据格式：</strong>将最小平均等待时间输出到文件waittime.txt。</li><li><strong>零钱找零问题</strong> 张阿姨是超市售货员，经常需要给客户找零。为了买卖便利，张阿姨在找零钱的过程中通常返回最少张（枚）数零钱，市面上流通的钱币有 <span class="math inline">\(100, 50, 20, 10, 5, 1, 0.5, 0.1\)</span> 元等各种样式，若某顾客购物消费 <span class="math inline">\(m\)</span> 元，付款 $ 1.05m  / 10$，则找零钱使用的最少钱币数量是？ <strong>输入数据格式：</strong>在文件customer.txt中。第 <span class="math inline">\(1\)</span> 行是正整数 <span class="math inline">\(a\)</span>，表示顾客有几次消费。第 <span class="math inline">\(2\)</span> 行有 <span class="math inline">\(a\)</span> 个整数，表示这些顾客的消费 <span class="math inline">\(1\)</span>。 <strong>输出数据格式：</strong>将找零策略输出到文件output.txt中。共有 <span class="math inline">\(a\)</span> 行。每行 <span class="math inline">\(8\)</span> 个数字，分别表示不同面值钱币的数量。</li></ol><a id="more"></a><h2 id="实现代码">实现代码</h2><h3 id="最优打印等待问题">最优打印等待问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;students.txt&quot;</span>)</span></span>;<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;waittime.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> m, sum, pre;<br>    <span class="hljs-keyword">double</span> mean;<br>    fin&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) fin&gt;&gt;a[i];<br>    sort(a, a + m);<br>    sum = <span class="hljs-number">0</span>;<br>    pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m - <span class="hljs-number">1</span>; i++)&#123;<br>        pre += a[i];<br>        sum += pre;<br>    &#125;<br>    mean = (<span class="hljs-keyword">double</span>)sum / m;<br>    fout&lt;&lt;mean;<br>    fin.close();<br>    fout.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="零钱找零问题">零钱找零问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> m[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;customer.txt&quot;</span>)</span></span>;<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;output.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> a, rec[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">double</span> nom[<span class="hljs-number">8</span>] = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.1</span>&#125;;<br>    <span class="hljs-keyword">double</span> res;<br>    fin&gt;&gt;a;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a; i++)&#123;<br>        fin&gt;&gt;m[i];<br>        res = <span class="hljs-built_in">floor</span>(<span class="hljs-number">1.05</span> * m[i] * <span class="hljs-number">10</span>) / <span class="hljs-number">10</span> - m[i];<br>        <span class="hljs-built_in">memset</span>(rec, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(rec));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(res / nom[j] &gt;= <span class="hljs-number">1</span>)&#123;<br>                rec[j] = <span class="hljs-built_in">floor</span>(res / nom[j]);<br>                res -= nom[j] * rec[j];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(res &lt; <span class="hljs-number">0.1</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>; w &lt; <span class="hljs-number">8</span>; w++) fout&lt;&lt;rec[w]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        fout&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    fin.close();<br>    fout.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法正确性">算法正确性</h2><h3 id="最优打印等待问题-1">最优打印等待问题</h3><h4 id="算法思路">算法思路</h4><p>将打印时间从小到大排序，打印时间小的先开始打印。</p><h4 id="正确性证明">正确性证明</h4><p>设排好序的打印时间序列为 <span class="math inline">\(\left&lt; a_1,a_2,…,a_n \right&gt;(a_1 \leq a_2 \leq \cdots \leq a_n)\)</span></p><p>则所有人的总等待时间 <span class="math display">\[T = \sum_{k = 1}^{n} \sum_{i = 0}^{k - 1} a_i\]</span> 由于平均等待时间 <span class="math inline">\(\bar{T}=T / n\)</span>，故要证 <span class="math inline">\(\bar{T}\)</span> 最小，即要证 <span class="math inline">\(T\)</span> 最小</p><p>下证该打印序列的总等待时间最小</p><p>任取 <span class="math inline">\(p \neq q \in \{1,2,…,n \}\)</span>，将 <span class="math inline">\(a_p\)</span> 与 <span class="math inline">\(a_q\)</span> 互换</p><p>不妨设 <span class="math inline">\(p&lt;q\)</span>，则此时所有人的总等待时间 <span class="math display">\[\begin{aligned}T&#39; &amp;= \sum_{k=1}^p \sum_{i=0}^{k-1} a_i + \sum_{k=p+1}^q \left( \sum_{i=0}^{p-1} a_i + a_q + \sum_{i=p+1}^{k-1} a_i \right) + \sum_{k=q+1}^n \sum_{i=0}^{k-1} a_i \\&amp;= \sum_{k=1}^p \sum_{i=0}^{k-1} a_i + \sum_{k=q+1}^n \sum_{i=0}^{k-1} a_i + \sum_{k=p+1}^q \sum_{i=0}^{p-1} a_i + \sum_{k=p+1}^q \sum_{i=p+1}^{k-1} a_i + (q-p) a_q\end{aligned}\]</span> 而 <span class="math display">\[T = \sum_{k = 1}^p \sum_{i = 0}^{k - 1} a_i + \sum_{k = q+1}^n \sum_{i = 0}^{k - 1} a_i + \sum_{k = p+1}^q \sum_{i = 0}^{p - 1}a_i + \sum_{k = p+1}^q \sum_{i = p+1}^{k - 1}a_i + (q-p)a_p\]</span> 又由于 <span class="math inline">\(a_p \leq a_q\)</span>，故 <span class="math inline">\(T&#39; \geq T\)</span></p><p>因此互换序列中任意两人的打印顺序所得的总等待时间均不小于原序列的总等待时间</p><p>即原序列的总等待时间最小</p><h3 id="零钱找零问题-1">零钱找零问题</h3><h4 id="算法思路-1">算法思路</h4><p>将纸币的面值从大到小排序，当大的纸币单张面额超过剩下的找零时再用更小的纸币继续找零</p><h4 id="正确性证明-1">正确性证明</h4><p>设钱币面额分别为 <span class="math inline">\(\left&lt; a_1, a_2, \cdots, a_8 \right&gt; (a_1 &gt; a_2 &gt; \cdots &gt; a_8)\)</span>，需要找零的数额 <span class="math inline">\(r = \lfloor 1.05m \times 10 \rfloor / 10 - m\)</span>，贪心算法下对应的找零钱币个数为 <span class="math inline">\(k_1, k_2, \cdots, k_8\)</span>。则 <span class="math display">\[r = \sum_{i = 1}^8 k_i a_i\]</span> 下证明 <span class="math inline">\(s = \sum_{i = 1}^8 k_i\)</span> 最小</p><p>若在某一种面额的钱币上少用一张换作更小面额的钱币，即 <span class="math inline">\(k_p&#39; = k_p - 1 (p \in \{1, 2, \cdots, 8\})\)</span>，则 <span class="math display">\[r = \sum_{i = 1}^{p - 1} k_i a_i + k_p a_p - a_p + \sum_{i = p+1}^8 k_i&#39; a_i\]</span> 由于 <span class="math inline">\(a_i &lt; a_p (i &gt; p)\)</span>，故 <span class="math inline">\(\sum_{i = p+1}^8 (k_i&#39; k_i) &gt; 1\)</span></p><p>故 <span class="math inline">\(s&#39; = \sum_{i = 1}^8 k_i&#39; &gt; s\)</span></p><p>故使用贪心算法生成的找零钱币个数总和最小。</p><h2 id="运行结果">运行结果</h2><h3 id="最优打印等待问题-2">最优打印等待问题</h3><p>输入：（students.txt）</p><p>10</p><p>8 7 5 2 19 6 20 8 1 15</p><p>输出：（waittime.txt）</p><p>23.6</p><h3 id="零钱找零问题-2">零钱找零问题</h3><p>输入：（customer.txt）</p><p>8</p><p>111 222 333 567 234 256 666 789</p><p>输出：（output.txt）</p><p>0 0 0 0 1 0 1 0</p><p>0 0 0 1 0 1 0 0</p><p>0 0 0 1 1 1 1 1</p><p>0 0 1 0 1 3 0 2</p><p>0 0 0 1 0 1 1 1</p><p>0 0 0 1 0 2 1 3</p><p>0 0 1 1 0 3 0 2</p><p>0 0 1 1 1 4 0 3</p><h2 id="总结">总结</h2><p>通过实验发现，最优打印等待问题和零钱找零问题均可以使用贪心算法得到正确的结果，文中也从数学上严格证明了贪心算法的正确性。相比动态规划算法，使用贪心算法解决这两个问题的运行效率更高，可以更快的求解出所需的结果。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态表</title>
    <link href="/2020/12/04/algorithm/course-exp/algorithm-exp9/"/>
    <url>/2020/12/04/algorithm/course-exp/algorithm-exp9/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><p>有一个公司想开发一个关于花卉的百科全书，用户只要输入花卉的名称，就能够输出花卉的详细信息。花卉包括：牡丹、芍药、茶花、菊花、梅花、兰花、月季、杜鹃花、郁金香、茉莉花、海棠、荷花、栀子花、莲花、百合、康乃馨、玫瑰、格桑花等1000种。这个公司想提升花卉检索和存储效率，打算采用<strong>动态表（Dynamic Table）</strong>来实现。由于花卉的数量可能会增加，也可能会减少，所实现的动态表需要有如下功能： 1. 能够插入数据</p><ol start="2" type="1"><li><p>能够删除数据</p></li><li><p>能够检索数据</p></li><li><p>能够按照参数扩展规模或者缩减规模</p></li></ol><a id="more"></a><h2 id="实现代码">实现代码</h2><h3 id="数据生成器">数据生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    fout&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) fout&lt;&lt;rand() % n&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    fout.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态表">动态表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">5000000</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">table_info</span>&#123;</span><br>    <span class="hljs-keyword">int</span> *p;<br>    <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">int</span> num;<br>&#125;;<br><span class="hljs-function">table_info *<span class="hljs-title">insert</span><span class="hljs-params">(table_info *table, <span class="hljs-keyword">int</span> description)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (table-&gt;size == <span class="hljs-number">0</span>)&#123;<br>        table-&gt;p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<br>        table-&gt;size = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (table-&gt;num == table-&gt;size)&#123;<br>        <span class="hljs-keyword">int</span> *ntable = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span> * table-&gt;size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; table-&gt;num; i++)&#123;<br>            ntable[i] = table-&gt;p[i];<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] table-&gt;p;<br>        table-&gt;p = ntable;<br>        table-&gt;size = <span class="hljs-number">2</span> * table-&gt;size;<br>    &#125;<br>    table-&gt;p[table-&gt;num] = description;<br>    table-&gt;num++;<br>    <span class="hljs-keyword">return</span> table;<br>&#125;<br><span class="hljs-comment">// You can add a parameter to insert the actual flower infos</span><br><span class="hljs-function">table_info *<span class="hljs-title">multi_insert</span><span class="hljs-params">(table_info *table, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t = table-&gt;num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        insert(table, t + i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> table;<br>&#125;<br><span class="hljs-function">table_info *<span class="hljs-title">remove</span><span class="hljs-params">(table_info *table)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (table-&gt;size == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> table;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (table-&gt;num &lt;= table-&gt;size / <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">int</span> *ntable = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[table-&gt;size / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; table-&gt;num; i++)&#123;<br>            ntable[i] = table-&gt;p[i];<br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] table-&gt;p;<br>        table-&gt;p = ntable;<br>        table-&gt;size = table-&gt;size / <span class="hljs-number">2</span>;<br>    &#125;<br>    table-&gt;num--;<br>    <span class="hljs-keyword">return</span> table;<br>&#125;<br><span class="hljs-function">table_info *<span class="hljs-title">multi_remove</span><span class="hljs-params">(table_info *table, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        remove(table);<br>    &#125;<br>    <span class="hljs-keyword">return</span> table;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(table_info *table, <span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= table-&gt;num) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> table-&gt;p[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> op, num;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    table_info t = &#123;<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;op&gt;&gt;num;<br>    <span class="hljs-keyword">if</span>(op == <span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-keyword">int</span> n;<br>        fin&gt;&gt;n;<br>        multi_insert(&amp;t, n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) fin&gt;&gt;a[i];<br>        start = clock();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            query(&amp;t, a[i]);<br>        &#125;<br>        stop = clock();<br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        fin.close();<br>    &#125;<br>    <span class="hljs-comment">//op: 1 - insert; 2 - delete; 3 - query; 0 - exit</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">while</span> (op != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)&#123;<br>            start = clock();<br>            multi_insert(&amp;t, num);<br>            stop = clock();<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Capacity: &quot;</span>&lt;&lt;t.size&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)&#123;<br>            start = clock();<br>            multi_remove(&amp;t, num);<br>            stop = clock();<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Capacity: &quot;</span>&lt;&lt;t.size&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>)&#123;<br>            start = clock();<br>            <span class="hljs-keyword">int</span> r = query(&amp;t, num);<br>            stop = clock();<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;description: &quot;</span>&lt;&lt;r&lt;&lt;<span class="hljs-built_in">endl</span>;<br>            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; op &gt;&gt; num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="运行效率">运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h2 id="总结">总结</h2><p>动态表执行 <span class="math inline">\(n\)</span> 次插入和删除操作的摊还代价为 <span class="math inline">\(\mathcal{O}(n)\)</span>，但在实际运行过程中，当插入或删除的数据规模越过 <span class="math inline">\(2\)</span> 的幂次时，运行时间会发生显著的增长，且幂次越高，运行时间的增长幅度越大，这与实验结果相吻合。实验中使用了直接寻址表作为动态表的存储结构，故理论上可以在 <span class="math inline">\(\mathcal{O}(1)\)</span> 的时间内查询给定的花卉信息。考虑到不同存储单元的访问代价略有不同，实验结果基本与理论吻合。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优二叉搜索树</title>
    <link href="/2020/11/27/algorithm/course-exp/algorithm-exp8/"/>
    <url>/2020/11/27/algorithm/course-exp/algorithm-exp8/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><p>有一个公司想开发一个关于花卉的百科全书，用户只要输入花卉的名称，就能够输出花卉的详细信息。花卉包括：牡丹、芍药、茶花、菊花、梅花、兰花、月季、杜鹃花、郁金香、茉莉花、海棠、荷花、栀子花、莲花、百合、康乃馨、玫瑰、格桑花。公司也在试运行阶段发现这些花的访问频率不一，有些花经常性被访问，有些被访问的次数就少很多了。这18种花中，第1种的访问频率是6，第2-3种的访问频率是5，第4-6种的访问频率是4，第7-10种的访问频率是3，第11-15种的访问频率是2，第16-18种的访问频率是1。</p><p>这个公司想提升花卉检索效率，所以对比了三种方法。</p><ol type="1"><li><p>构建优化的二叉搜索树（optimal BST），进行搜索。</p></li><li><p>将这些花卉按照访问频度从高到低放在一个数组中，并顺序访问来检索</p></li><li><p>构建哈希表来存储这些数据，并基于哈希表来检索数据。</p></li></ol><p>请实现这三种方法，并且通过实验来比较这三种方法的优劣。</p><a id="more"></a><h2 id="实现代码">实现代码</h2><h3 id="数据生成器">数据生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">string</span> a[<span class="hljs-number">10000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> rand() % length;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">string</span> flower[<span class="hljs-number">18</span>] = &#123;<span class="hljs-string">&quot;paeoniaSA&quot;</span>, <span class="hljs-string">&quot;paeoniaLP&quot;</span>, <span class="hljs-string">&quot;camellia&quot;</span>, <span class="hljs-string">&quot;chrysanthemum&quot;</span>, <span class="hljs-string">&quot;plum&quot;</span>, <span class="hljs-string">&quot;orchid&quot;</span>,<br>                         <span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;azalea&quot;</span>, <span class="hljs-string">&quot;tulip&quot;</span>, <span class="hljs-string">&quot;jasmine&quot;</span>, <span class="hljs-string">&quot;begonia&quot;</span>, <span class="hljs-string">&quot;lotus&quot;</span>,<br>                         <span class="hljs-string">&quot;gardenia&quot;</span>, <span class="hljs-string">&quot;lotus&quot;</span>, <span class="hljs-string">&quot;lily&quot;</span>, <span class="hljs-string">&quot;carnation&quot;</span>, <span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;gesang&quot;</span>&#125;;<br>    <span class="hljs-keyword">int</span> freq[<span class="hljs-number">18</span>] = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">18</span>; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (n * freq[i] / <span class="hljs-number">53</span>); j++)&#123;<br>            <span class="hljs-keyword">int</span> t = shuffle(n);<br>            <span class="hljs-keyword">while</span>(a[t] != <span class="hljs-string">&quot;&quot;</span>)&#123;<br>                t = shuffle(n);<br>            &#125;<br>            a[t] = flower[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        fout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    fout.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最优二叉搜索树">最优二叉搜索树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">string</span> a[<span class="hljs-number">10000005</span>];<br><span class="hljs-keyword">int</span> e[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>], w[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>], root[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; freq_table;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-built_in">string</span> name;<br>    <span class="hljs-built_in">string</span> description;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">lchild</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">rchild</span>;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">optimal_bst</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-built_in">string</span> *flower)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i++)&#123;<br>        e[i][i - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        w[i][i - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>; l &lt;= n; l++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - l + <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">int</span> j = i + l - <span class="hljs-number">1</span>;<br>            e[i][j] = <span class="hljs-number">999999</span>;<br>            w[i][j] = w[i][j - <span class="hljs-number">1</span>] + freq_table[flower[j - <span class="hljs-number">1</span>]];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = i; r &lt;= j; r++)&#123;<br>                <span class="hljs-keyword">int</span> t = e[i][r - <span class="hljs-number">1</span>] + e[r + <span class="hljs-number">1</span>][j] + w[i][j];<br>                <span class="hljs-keyword">if</span>(t &lt; e[i][j])&#123;<br>                    e[i][j] = t;<br>                    root[i][j] = r;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function">node *<span class="hljs-title">build_bst</span><span class="hljs-params">(<span class="hljs-built_in">string</span> *flower, <span class="hljs-built_in">string</span> *description, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">rnode</span> = <span class="hljs-title">new</span> <span class="hljs-title">node</span>();</span><br>    rnode-&gt;name = flower[root[i][j] - <span class="hljs-number">1</span>];<br>    rnode-&gt;description = description[root[i][j] - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span>(i &gt;= j) <span class="hljs-keyword">return</span> rnode;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">lc</span> = <span class="hljs-title">build_bst</span>(<span class="hljs-title">flower</span>, <span class="hljs-title">description</span>, <span class="hljs-title">i</span>, <span class="hljs-title">root</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>] - 1);</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">rc</span> = <span class="hljs-title">build_bst</span>(<span class="hljs-title">flower</span>, <span class="hljs-title">description</span>, <span class="hljs-title">root</span>[<span class="hljs-title">i</span>][<span class="hljs-title">j</span>] + 1, <span class="hljs-title">j</span>);</span><br>    rnode-&gt;lchild = lc;<br>    rnode-&gt;rchild = rc;<br>    <span class="hljs-keyword">return</span> rnode;<br>&#125;<br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">search</span><span class="hljs-params">(struct node *rnode,<span class="hljs-built_in">string</span> *name)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">cur</span> = <span class="hljs-title">rnode</span>;</span><br>    <span class="hljs-keyword">while</span> (cur)&#123;<br>        cnt++;<br>        <span class="hljs-keyword">if</span>((*name) == cur-&gt;name) <span class="hljs-keyword">return</span> cur-&gt;description;<br>        <span class="hljs-keyword">if</span> (cur-&gt;lchild &amp;&amp; ((*name) &lt; cur-&gt;name)) cur = cur-&gt;lchild;<br>        <span class="hljs-keyword">else</span> cur = cur-&gt;rchild;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">string</span> flower[<span class="hljs-number">18</span>] = &#123;<span class="hljs-string">&quot;paeoniaSA&quot;</span>, <span class="hljs-string">&quot;paeoniaLP&quot;</span>, <span class="hljs-string">&quot;camellia&quot;</span>, <span class="hljs-string">&quot;chrysanthemum&quot;</span>, <span class="hljs-string">&quot;plum&quot;</span>, <span class="hljs-string">&quot;orchid&quot;</span>,<br>                         <span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;azalea&quot;</span>, <span class="hljs-string">&quot;tulip&quot;</span>, <span class="hljs-string">&quot;jasmine&quot;</span>, <span class="hljs-string">&quot;begonia&quot;</span>, <span class="hljs-string">&quot;lotus&quot;</span>,<br>                         <span class="hljs-string">&quot;gardenia&quot;</span>, <span class="hljs-string">&quot;lotus&quot;</span>, <span class="hljs-string">&quot;lily&quot;</span>, <span class="hljs-string">&quot;carnation&quot;</span>, <span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;gesang&quot;</span>&#125;;<br>    <span class="hljs-comment">//Simulate the description of flowers</span><br>    <span class="hljs-built_in">string</span> description[<span class="hljs-number">18</span>] = &#123;<span class="hljs-string">&quot;DpaeoniaSA&quot;</span>, <span class="hljs-string">&quot;DpaeoniaLP&quot;</span>, <span class="hljs-string">&quot;Dcamellia&quot;</span>, <span class="hljs-string">&quot;Dchrysanthemum&quot;</span>, <span class="hljs-string">&quot;Dplum&quot;</span>, <span class="hljs-string">&quot;Dorchid&quot;</span>,<br>                              <span class="hljs-string">&quot;Drose&quot;</span>, <span class="hljs-string">&quot;Dazalea&quot;</span>, <span class="hljs-string">&quot;Dtulip&quot;</span>, <span class="hljs-string">&quot;Djasmine&quot;</span>, <span class="hljs-string">&quot;Dbegonia&quot;</span>, <span class="hljs-string">&quot;Dlotus&quot;</span>,<br>                              <span class="hljs-string">&quot;Dgardenia&quot;</span>, <span class="hljs-string">&quot;Dlotus&quot;</span>, <span class="hljs-string">&quot;Dlily&quot;</span>, <span class="hljs-string">&quot;Dcarnation&quot;</span>, <span class="hljs-string">&quot;Drose&quot;</span>, <span class="hljs-string">&quot;Dgesang&quot;</span>&#125;;<br>    <span class="hljs-keyword">int</span> freq[<span class="hljs-number">18</span>] = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">18</span>; i++)&#123;<br>        freq_table[flower[i]] = freq[i];<br>    &#125;<br>    sort(flower, flower + <span class="hljs-number">18</span>);<br>    sort(description, description + <span class="hljs-number">18</span>);<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        fin&gt;&gt;a[n];<br>        n++;<br>    &#125;<br>    n--;<br>    optimal_bst(<span class="hljs-number">18</span>, flower);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">troot</span> = <span class="hljs-title">build_bst</span>(<span class="hljs-title">flower</span>, <span class="hljs-title">description</span>, 1, 18);</span><br>    start = clock();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">string</span> t = search(troot, &amp;a[i]);<br>        <span class="hljs-comment">//cout&lt;&lt;t&lt;&lt;&quot; &quot;;</span><br>    &#125;<br>    stop = clock();<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total count: &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-string">&quot;s&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线性查找">线性查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">string</span> a[<span class="hljs-number">10000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">string</span> flower[<span class="hljs-number">18</span>] = &#123;<span class="hljs-string">&quot;paeoniaSA&quot;</span>, <span class="hljs-string">&quot;paeoniaLP&quot;</span>, <span class="hljs-string">&quot;camellia&quot;</span>, <span class="hljs-string">&quot;chrysanthemum&quot;</span>, <span class="hljs-string">&quot;plum&quot;</span>, <span class="hljs-string">&quot;orchid&quot;</span>,<br>                         <span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;azalea&quot;</span>, <span class="hljs-string">&quot;tulip&quot;</span>, <span class="hljs-string">&quot;jasmine&quot;</span>, <span class="hljs-string">&quot;begonia&quot;</span>, <span class="hljs-string">&quot;lotus&quot;</span>,<br>                         <span class="hljs-string">&quot;gardenia&quot;</span>, <span class="hljs-string">&quot;lotus&quot;</span>, <span class="hljs-string">&quot;lily&quot;</span>, <span class="hljs-string">&quot;carnation&quot;</span>, <span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;gesang&quot;</span>&#125;;<br>    <span class="hljs-comment">//Simulate the description of flowers</span><br>    <span class="hljs-built_in">string</span> description[<span class="hljs-number">18</span>] = &#123;<span class="hljs-string">&quot;DpaeoniaSA&quot;</span>, <span class="hljs-string">&quot;DpaeoniaLP&quot;</span>, <span class="hljs-string">&quot;Dcamellia&quot;</span>, <span class="hljs-string">&quot;Dchrysanthemum&quot;</span>, <span class="hljs-string">&quot;Dplum&quot;</span>, <span class="hljs-string">&quot;Dorchid&quot;</span>,<br>                              <span class="hljs-string">&quot;Drose&quot;</span>, <span class="hljs-string">&quot;Dazalea&quot;</span>, <span class="hljs-string">&quot;Dtulip&quot;</span>, <span class="hljs-string">&quot;Djasmine&quot;</span>, <span class="hljs-string">&quot;Dbegonia&quot;</span>, <span class="hljs-string">&quot;Dlotus&quot;</span>,<br>                              <span class="hljs-string">&quot;Dgardenia&quot;</span>, <span class="hljs-string">&quot;Dlotus&quot;</span>, <span class="hljs-string">&quot;Dlily&quot;</span>, <span class="hljs-string">&quot;Dcarnation&quot;</span>, <span class="hljs-string">&quot;Drose&quot;</span>, <span class="hljs-string">&quot;Dgesang&quot;</span>&#125;;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        fin&gt;&gt;a[n];<br>        n++;<br>    &#125;<br>    n--;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    start = clock();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">18</span>; j++) &#123;<br>            cnt++;<br>            <span class="hljs-keyword">if</span> (a[i] == flower[j]) &#123;<br>                <span class="hljs-built_in">string</span> t = description[j];<br>                <span class="hljs-comment">//cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    stop = clock();<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total count: &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-string">&quot;s&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">string</span> a[<span class="hljs-number">10000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">string</span> flower[<span class="hljs-number">18</span>] = &#123;<span class="hljs-string">&quot;paeoniaSA&quot;</span>, <span class="hljs-string">&quot;paeoniaLP&quot;</span>, <span class="hljs-string">&quot;camellia&quot;</span>, <span class="hljs-string">&quot;chrysanthemum&quot;</span>, <span class="hljs-string">&quot;plum&quot;</span>, <span class="hljs-string">&quot;orchid&quot;</span>,<br>                         <span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;azalea&quot;</span>, <span class="hljs-string">&quot;tulip&quot;</span>, <span class="hljs-string">&quot;jasmine&quot;</span>, <span class="hljs-string">&quot;begonia&quot;</span>, <span class="hljs-string">&quot;lotus&quot;</span>,<br>                         <span class="hljs-string">&quot;gardenia&quot;</span>, <span class="hljs-string">&quot;lotus&quot;</span>, <span class="hljs-string">&quot;lily&quot;</span>, <span class="hljs-string">&quot;carnation&quot;</span>, <span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;gesang&quot;</span>&#125;;<br>    <span class="hljs-comment">//Simulate the description of flowers</span><br>    <span class="hljs-built_in">string</span> description[<span class="hljs-number">18</span>] = &#123;<span class="hljs-string">&quot;DpaeoniaSA&quot;</span>, <span class="hljs-string">&quot;DpaeoniaLP&quot;</span>, <span class="hljs-string">&quot;Dcamellia&quot;</span>, <span class="hljs-string">&quot;Dchrysanthemum&quot;</span>, <span class="hljs-string">&quot;Dplum&quot;</span>, <span class="hljs-string">&quot;Dorchid&quot;</span>,<br>                              <span class="hljs-string">&quot;Drose&quot;</span>, <span class="hljs-string">&quot;Dazalea&quot;</span>, <span class="hljs-string">&quot;Dtulip&quot;</span>, <span class="hljs-string">&quot;Djasmine&quot;</span>, <span class="hljs-string">&quot;Dbegonia&quot;</span>, <span class="hljs-string">&quot;Dlotus&quot;</span>,<br>                              <span class="hljs-string">&quot;Dgardenia&quot;</span>, <span class="hljs-string">&quot;Dlotus&quot;</span>, <span class="hljs-string">&quot;Dlily&quot;</span>, <span class="hljs-string">&quot;Dcarnation&quot;</span>, <span class="hljs-string">&quot;Drose&quot;</span>, <span class="hljs-string">&quot;Dgesang&quot;</span>&#125;;<br>    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; flower_map;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">18</span>; i++)&#123;<br>        flower_map[flower[i]] = description[i];<br>    &#125;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        fin&gt;&gt;a[n];<br>        n++;<br>    &#125;<br>    n--;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    start = clock();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        cnt++;<br>        <span class="hljs-built_in">string</span> t = flower_map[a[i]];<br>        <span class="hljs-comment">//cout&lt;&lt;t&lt;&lt;&quot; &quot;;</span><br>    &#125;<br>    stop = clock();<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total count: &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-string">&quot;s&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行效率">运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h2 id="总结">总结</h2><p>由于每种鲜花被查询的频率不同，为了测试各算法的运行效率，实验中首先根据不同鲜花的查询频率生成了一串不同规模的查询序列，通过比较查询序列所花费的总时间来比较各算法的运行效率。</p><p>从实验中可以发现，通过构建哈希表来查询鲜花信息的运行效率最高，且随着数据规模的增大优势越发明显，这与哈希表 <span class="math display">\[\mathcal{O}(1)\]</span> 的理论查询时间相符。然而，实验中通过构建最优二叉搜索树进行查询的运行效率不如线性访问的运行效率，这与理论分析不符。通过进一步记录两种算法的查询次数发现在最优二叉搜索树上查询的次数的确小于线性访问的查询次数。由于实验中最优二叉搜索树的每个结点均申请在了堆上，而线性访问时所用数组申请在了栈上，故推测是堆的访问效率不如栈的访问效率导致了其运行效率不如线性访问。</p><p>由此可见，在鲜花信息查询问题上，构建哈希表查询是一个最为高效且可行的算法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从主方法到Akra-Bazzi定理</title>
    <link href="/2020/11/25/algorithm/theory/akra-bazzi/"/>
    <url>/2020/11/25/algorithm/theory/akra-bazzi/</url>
    
    <content type="html"><![CDATA[<h2 id="主方法">主方法</h2><p>在算法分析中，当我们使用分治法求解问题时，通常会遇到以递归式定义的算法运行时间函数。要得到此类算法的时间复杂度，就必须求出该递归式的渐近表达式。通常情况下，我们可以通过如下公式直接得到大部分不太复杂的递归式的渐近解。<strong>《算法导论》</strong>一书中将该方法称为<strong>“主方法”</strong>。</p><a id="more"></a><blockquote><p><strong>Theorem: </strong>设<span class="math display">\[a\geq 1, b &gt;1\]</span>，<span class="math display">\[f(n)\]</span>为一定义在非负整数上的函数， <span class="math display">\[T(n)=aT\left(\frac{n}{b}\right) + f(n)\]</span>（当 <span class="math display">\[\frac{n}{b}\]</span> 不为整数时代表 <span class="math display">\[\lfloor{\frac{n}{b}\rfloor}\]</span> 或 <span class="math display">\[\lceil{\frac{n}{b}\rceil}\]</span>），则</p><ol type="1"><li><p>若存在 <span class="math display">\[\varepsilon &gt; 0\]</span>，使得 <span class="math display">\[f(n) = \mathcal{O}\left(n^{\log_b a - \varepsilon}\right)\]</span>，则 <span class="math display">\[T(n) = \Theta\left(n^{\log_b a}\right)\]</span></p></li><li><p>若存在 <span class="math display">\[k \geq 0\]</span>，使得 <span class="math display">\[f(n) = \Theta\left(n^{\log_b a} \lg^k n\right)\]</span>，则 <span class="math display">\[T(n) = \Theta\left(n^{\log_b a} \lg^{k+1} n\right)\]</span></p></li><li><p>若存在 <span class="math display">\[\varepsilon &gt; 0\]</span>，使得 <span class="math display">\[f(n) = \Omega\left(n^{\log_b a + \varepsilon}\right)\]</span>，且存在 <span class="math display">\[0&lt;c&lt;1\]</span>及正整数 <span class="math display">\[N\]</span>，使得当 <span class="math display">\[n&gt;N\]</span> 时，有 <span class="math display">\[af\left(\frac{n}{b}\right) \leq cf(n)\]</span>，则 <span class="math display">\[T(n) = \Theta(f(n))\]</span></p></li></ol></blockquote><p>通过该定理，我们可以快速得到一些算法的时间复杂度。</p><blockquote><p><strong>Example1:</strong> Strassen矩阵算法的运行时间函数 <span class="math display">\[T(n)=7T\left(\frac{n}{2}\right) + \Theta(n^2)\]</span>，求Strassen矩阵算法的时间复杂度</p><p><strong>解：</strong>由 <span class="math display">\[\log_2 7 &gt; \log_2 4 = 2\]</span> 可知，存在 <span class="math display">\[\varepsilon &gt; 0\]</span>，使得 <span class="math display">\[f(n) = \Theta(n^2) = \mathcal{O}(n^{\log_2 7 - \varepsilon})\]</span></p><p>故由主定理可知，<span class="math display">\[T(n) = \Theta(n^{\log_2 7})\]</span></p></blockquote><blockquote><p><strong>Example2:</strong> 归并排序算法的运行时间函数 <span class="math display">\[T(n) = 2T\left(\frac{n}{2}\right) + \Theta(n)\]</span>，求归并排序算法的时间复杂度</p><p><strong>解：</strong>由 <span class="math display">\[\log_2 2 = 1\]</span> 可知，存在 <span class="math display">\[k=0\]</span>，使得 <span class="math display">\[f(n) = \Theta(n) = \Theta(n^{\log_2 2} \lg^k n)\]</span></p><p>故由主定理可知，<span class="math display">\[T(n) = \Theta(n \lg n)\]</span></p></blockquote><blockquote><p><strong>Example3:</strong> 若一个算法的运行时间函数 <span class="math display">\[T(n)=2T\left(\frac{n}{2}\right) + \Theta(n^2)\]</span>，求该算法的时间复杂度</p><p><strong>解：</strong>由 <span class="math display">\[\log_2 2 = 1\]</span> 可知，存在 <span class="math display">\[\varepsilon &gt; 0\]</span>，使得 <span class="math display">\[f(n) = \Theta(n^2) = \Omega(n^{\log_2 2 + \varepsilon})\]</span></p><p>又由于 <span class="math display">\[af\left(\frac{n}{b}\right) = 2 \left(\frac{n}{2}\right)^2 = \frac{n^2}{2}\]</span></p><p>因此仅需取 <span class="math display">\[\frac{1}{2} \leq c &lt; 1\]</span>，则有 <span class="math display">\[af\left(\frac{n}{b}\right) \leq cf(n)\]</span></p><p>故由主定理可知，<span class="math display">\[T(n) = \Theta(n^2)\]</span></p></blockquote><h2 id="主定理的证明">主定理的证明</h2><p>下面我们来尝试证明主定理。</p><p>主定理的证明思路如下：首先我们考虑当 <span class="math display">\[n\]</span> 为 <span class="math display">\[b\]</span> 的某个幂次时的情况，此时可以保证 <span class="math display">\[\frac{n}{b}\]</span> 是一个整数，因此可以直接做递推并求出其阶数。随后，通过放缩，我们可以将其推广到一切正整数的情况上去。</p><p>首先我们考虑当 <span class="math display">\[n\]</span> 为 <span class="math display">\[b\]</span> 的 <span class="math display">\[k\]</span> 次幂时的情况。此时原递归式可写为 <span class="math display">\[T(n)=\left\{\begin{aligned}&amp;\Theta(1) &amp;, &amp;n = 1 \\&amp;aT\left(\frac{n}{b}\right)+f(n) &amp;, &amp;n=b^i(i=1,2,...,k)\end{aligned}\right.\]</span> 作递推，可得 <span class="math display">\[\begin{aligned}T(n)&amp;=aT\left(\frac{n}{b}\right) + f(n) \\&amp;=a^2T\left(\frac{n}{b^2}\right) + af\left(\frac{n}{b}\right) + f(n) \\&amp;=a^3T\left(\frac{n}{b^3}\right) + a^2f\left(\frac{n}{b^2}\right) + af\left(\frac{n}{b}\right) + f(n) \\&amp;=... \\&amp;=a^{\log_b n} T(1) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right) \\&amp;=n^{\log_b a} \Theta(1) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right) \\&amp;=\Theta \left(n^{\log_b a} \right) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)\end{aligned}\]</span> 因此我们只需要考察 <span class="math display">\[\sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)\]</span> 的渐近表达式即可得到 <span class="math display">\[T(n)\]</span> 的渐近解。</p><p>现在我们来证明如下的的引理成立</p><blockquote><p><strong>Lemma:</strong> 设 <span class="math display">\[g(n) = \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)\]</span> （其中 <span class="math display">\[a \geq 1, b &gt; 1\]</span>，<span class="math display">\[n=b^k\]</span>），则</p><ol type="1"><li><p>若存在 <span class="math display">\[\varepsilon &gt; 0\]</span>，使得 <span class="math display">\[f(n) = \mathcal{O} \left(n^{\log_b a - \varepsilon} \right)\]</span>，则 <span class="math display">\[g(n) = \mathcal{O}\left(n^{\log_b a}\right)\]</span></p></li><li><p>若存在 <span class="math display">\[k \geq 0\]</span>，使得 <span class="math display">\[f(n) = \Theta\left(n^{\log_b a} \lg^k n\right)\]</span>，则 <span class="math display">\[g(n) = \Theta\left(n^{\log_b a} \lg^{k+1} n\right)\]</span></p></li><li><p>若存在 <span class="math display">\[0&lt;c&lt;1\]</span>及正整数 <span class="math display">\[N\]</span>，使得当 <span class="math display">\[n&gt;N\]</span> 时，有 <span class="math display">\[af\left(\frac{n}{b}\right) \leq cf(n)\]</span>，则 <span class="math display">\[g(n) = \Theta(f(n))\]</span></p></li></ol><p><strong>证明：①</strong> 当 <span class="math display">\[f(n) = \mathcal{O} \left(n^{\log_b a - \varepsilon} \right)\]</span> 时，<span class="math display">\[f\left(\frac{n}{b^i}\right) = \mathcal{O}\left(\left(\frac{n}{b^i}\right)^{\log_b a - \varepsilon}\right)\]</span></p><p>此时 <span class="math display">\[\begin{aligned}g(n) &amp;= \sum_\limits{i = 0}^{\log_b n - 1} a^i \cdot \mathcal{O}\left(\left(\frac{n}{b^i}\right)^{\log_b a - \varepsilon}\right) \\&amp;=\mathcal{O} \left(\sum_\limits{i = 0}^{\log_b n - 1} a^i \cdot \left(\frac{n}{b^i}\right)^{\log_b a - \varepsilon}\right) \\&amp;=\mathcal{O} \left(n^{\log_b a - \varepsilon} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \left(\frac{a}{b^{\log_b a - \varepsilon}}\right)^i\right) \\&amp;=\mathcal{O} \left(n^{\log_b a - \varepsilon} \cdot \sum_\limits{i = 0}^{\log_b n - 1} b^{i\varepsilon}\right) \\&amp;=\mathcal{O} \left(n^{\log_b a - \varepsilon} \cdot \frac{n^\varepsilon - 1}{b^\varepsilon - 1}\right) \\&amp;=\mathcal{O} \left(\frac{n^{\log_b a}}{b^\varepsilon - 1} - \frac{n^{\log_b a - \varepsilon}}{b^\varepsilon - 1}\right) \\&amp;=\mathcal{O} \left(n^{\log_b a} \right)\end{aligned}\]</span></p><p><strong>②</strong> 当 <span class="math display">\[f(n) = \Theta\left(n^{\log_b a} \lg^k n\right)\]</span> 时，<span class="math display">\[f\left(\frac{n}{b^i}\right) = \Theta \left( \left(\frac{n}{b^i}\right)^{\log_b a} \lg^k \left(\frac{n}{b^i}\right)\right)\]</span></p><p>此时 <span class="math display">\[\begin{aligned}g(n) &amp;= \sum_\limits{i = 0}^{\log_b n - 1} a^i \cdot \Theta\left(\left(\frac{n}{b^i}\right)^{\log_b a} \lg^k \left(\frac{n}{b^i}\right)\right) \\&amp;= \Theta \left(\sum_\limits{i = 0}^{\log_b n - 1} a^i\left(\frac{n}{b^i}\right)^{\log_b a} \lg^k \left(\frac{n}{b^i}\right)\right) \\&amp;=\Theta \left(n^{\log_b a} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \lg^k \left(\frac{n}{b^i}\right)\right) \\&amp;=\Theta \left(n^{\log_b a} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \left(\lg n - i \lg b \right)^k\right)\end{aligned}\]</span> 由二项式定理可知，<span class="math display">\[\left(\lg n - i \lg b \right)^k = \lg^k n + \mathcal{O}\left(\lg^k n\right)\]</span></p><p>故 <span class="math display">\[\begin{aligned}g(n) &amp;= \Theta \left(n^{\log_b a} \cdot \sum_\limits{i = 0}^{\log_b n - 1} \left(\lg^k n + \mathcal{O} \left(\lg^k n \right)\right)\right) \\&amp;= \Theta \left(n^{\log_b a} \cdot \left(\log_b n \cdot \lg^k n + \log_b n \cdot \mathcal{O} \left(\lg^k n \right)\right)\right) \\&amp;=\Theta \left( n^{\log_b a} \cdot \log_b n \cdot \lg^k n\right) \\&amp;=\Theta \left(n^{\log_b a} \lg^{k+1} n\right)\end{aligned}\]</span></p><p><strong>③</strong> 由 <span class="math display">\[g(n) = f(n) + \sum_\limits{i = 1}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)\]</span> 可知 <span class="math display">\[g(n) = \Omega(f(n))\]</span></p><p>由条件存在 <span class="math display">\[c&lt;1\]</span>及正整数 <span class="math display">\[N\]</span>，使得当 <span class="math display">\[n&gt;N\]</span> 时，有 <span class="math display">\[af\left(\frac{n}{b}\right) \leq cf(n)\]</span></p><p>作递推可知，当 <span class="math display">\[\frac{n}{b^{i-1}}&gt;N\]</span> 时，有 <span class="math display">\[a^i f\left(\frac{n}{b^i}\right) \leq c^if(n)\]</span></p><p>故 <span class="math display">\[\begin{aligned}g(n) &amp;= \sum_\limits{i = 0}^{\log_b n - \log_b N} a^i f \left( \frac{n}{b^i} \right) + \sum_\limits{i = \log_b n - \log_b N + 1}^{\log_b n - 1} a^i f \left( \frac{n}{b^i} \right) \\&amp;\leq \sum_\limits{i = 0}^{\log_b n - \log_b N}c^if(n) + \Theta(1) \\&amp;=f(n) \sum_\limits{i = 0}^{\log_b n - \log_b N}c^i + \Theta(1) \\&amp;\leq f(n) \sum_\limits{i = 0}^{\infty}c^i + \Theta(1) \\&amp;=\frac{1}{1-c} \cdot f(n) + \Theta(1) \\&amp;=\mathcal{O}(f(n))\end{aligned}\]</span> 由此可得 <span class="math display">\[g(n) = \Theta(f(n))\]</span></p></blockquote><p>由于 <span class="math display">\[T(n)=\Theta \left(n^{\log_b a} \right) + \sum_\limits{i = 0}^{\log_b n - 1} a^i f\left(\frac{n}{b^i}\right)\]</span>，故根据引理我们就能快速得到 <span class="math display">\[n\]</span> 为 <span class="math display">\[b\]</span> 的 <span class="math display">\[k\]</span> 次幂时的主定理。</p><p>下面我们需要将 <span class="math display">\[n\]</span> 为 <span class="math display">\[b\]</span> 的 <span class="math display">\[k\]</span> 次幂时的主定理推广到 <span class="math display">\[n\]</span> 为一切整数时的情况以证明完整的主定理成立。</p><p>首先由于 <span class="math display">\[\begin{aligned}T(n)&amp;=aT\left(\lceil{\frac{n}{b}\rceil}\right) + f(n) \\&amp;\geq aT\left(\frac{n}{b}\right) + f(n)\end{aligned}\]</span> 故根据 <span class="math display">\[n\]</span> 为 <span class="math display">\[b\]</span> 的幂次时的主定理可知当 <span class="math display">\[T(n)=aT\left(\lceil{\frac{n}{b}\rceil}\right) + f(n)\]</span> 时，<span class="math display">\[T(n)=\Omega(A)\]</span> （根据不同情况 <span class="math display">\[A\]</span> 取 <span class="math display">\[n^{\log_b a}\]</span>、<span class="math display">\[n^{\log_b a} \lg^{k+1} n\]</span> 或 <span class="math display">\[f(n)\]</span>）</p><p>同理可得当 <span class="math display">\[T(n)=aT\left(\lfloor{\frac{n}{b}\rfloor}\right) + f(n)\]</span> 时，<span class="math display">\[T(n)=\mathcal{O}(A)\]</span></p><p>下面我们来证明当 <span class="math display">\[T(n)=aT\left(\lceil{\frac{n}{b}\rceil}\right) + f(n)\]</span> 时，<span class="math display">\[T(n)=\mathcal{O}(A)\]</span></p><p>令 <span class="math display">\[t_0 = n, t_1 = \lceil{\frac{t_0}{b} \rceil}, t_2 = \lceil{\frac{t_1}{b} \rceil}, ..., t_k = \lceil{\frac{t_{k - 1}}{b} \rceil}=\Theta(1)\]</span></p><p>由于 <span class="math display">\[\begin{aligned}t_1 &amp;\leq \frac{n}{b} + 1 \\t_2 &amp;\leq \frac{t_1}{b} + 1 \leq \frac{n}{b^2} + \frac{1}{b} + 1 \\... \\t_k &amp;\leq \frac{t_{k-1}}{b} + 1 \leq \frac{n}{b^k} + \sum_\limits{i = 0}^{k-1} \frac{1}{b^i}\end{aligned}\]</span> 故 <span class="math display">\[\begin{aligned}t_k &amp;\leq \frac{n}{b^k} + \sum_\limits{i = 0}^{\infty} \frac{1}{b^i} \\&amp;=\frac{n}{b^k} + \frac{b}{b-1}\end{aligned}\]</span> 由于当 <span class="math display">\[k = \lfloor{\log_b n\rfloor}\]</span> 时有 <span class="math display">\[\frac{n}{b^k} + \frac{b}{b-1} \leq \frac{n}{b^{\log_b n - 1}} + \frac{b}{b-1} = \frac{b^2}{b-1} = \Theta(1)\]</span> 故 <span class="math display">\[k \leq \lfloor{\log_b n\rfloor}\]</span></p><p>故对原式作递推，可得 <span class="math display">\[\begin{aligned}T(n) &amp;= aT\left(t_1\right) + f(t_0) \\&amp;= a^2T(t_2) + af(t_1) + f(t_0) \\&amp;... \\&amp;\leq \Theta \left(n^{\log_b a} \right) + \sum_\limits{i = 0}^{\lfloor{\log_b n \rfloor} - 1} a^i f\left(t_i\right)\end{aligned}\]</span> 因此由上面 <span class="math display">\[n\]</span> 为 <span class="math display">\[b\]</span> 的幂次时主定理得推导过程同理可得，<span class="math display">\[T(n) \leq \Theta(A)\]</span>，即 <span class="math display">\[T(n) = \mathcal{O}(A)\]</span></p><p>类似的我们同样可以得到当 <span class="math display">\[T(n)=aT\left(\lfloor{\frac{n}{b}\rfloor}\right) + f(n)\]</span> 时，<span class="math display">\[T(n)=\Omega(A)\]</span></p><p>于是综上所述，<span class="math display">\[T(n) = \Theta(A)\]</span> 可推广到一切正整数，即主定理成立</p><h2 id="主方法的局限性">主方法的局限性</h2><p>通俗来说，若要使用主方法，<span class="math display">\[f(n)\]</span> 必须多项式意义上的小于或大于 <span class="math display">\[n^{\log_b a}\]</span>（即 <span class="math display">\[f(n)\]</span> 与 <span class="math display">\[n^{\log_b a}\]</span> 的阶数差能够被某个 <span class="math display">\[n^\varepsilon\]</span> 控制住），或者 <span class="math display">\[f(n)\]</span> 仅比 <span class="math display">\[n^{\log_b a}\]</span> 大 <span class="math display">\[\log\]</span> 阶。而这三种情况并不能覆盖 <span class="math display">\[f(n)\]</span> 所有可能的函数特征，若 <span class="math display">\[f(n)\]</span> 的阶数在这三种情况之间，主方法就失效了。</p><p>例如当 <span class="math display">\[T(n) = 3T \left(\frac{n}{3}\right) + \frac{n}{\lg n}\]</span> 时，对于 <span class="math display">\[f(n) = \frac{n}{\lg n}\]</span>，无法找到某个 <span class="math display">\[\varepsilon &gt; 0\]</span> 使得 <span class="math display">\[f(n) = \mathcal{O}(n)\]</span>，即 <span class="math display">\[f(n)\]</span> 不是多项式意义上的小于 <span class="math display">\[\log_b a\]</span>，此时便无法使用主定理得到该递归式的渐近解。</p><p>此外，主方法要求递归式必须由平均划分的子式定义，而对于如 <span class="math display">\[T(n) = T\left(\frac{n}{2} \right) + T\left(\frac{n}{4} \right) + T\left(\frac{n}{8} \right) + n\]</span> 这样非平均划分子式定义的递归式，同样无法使用主方法求解。</p><p>遇到此类问题，<strong>《算法导论》</strong>中推荐使用<strong>画递归树+数学归纳证明</strong>的方法解决。然而对于一些子问题情况较为复杂的递归式，这种方法的效率十分低下且容易出错，有时并不能很好的作为一种普适的办法使用。</p><h2 id="akra-bazzi定理">Akra-Bazzi定理</h2><p>Akra-Bazzi定理是由两位黎巴嫩数学家<strong>Mohamad Akra</strong>和<strong>Louay Bazzi</strong>于1998年提出的一种用于求解线性递归式的渐近解的定理。Akra-Bazzi定理相比主定理对递归式的要求更弱，其适用范围也远广于主定理。</p><p>为了引出Akra-Bazzi定理，我们需要定义一个<strong>多项式增长条件</strong></p><blockquote><p><strong>Definition:</strong> 设 <span class="math display">\[g(x)\]</span> 为一定义在非负实数上的函数，<span class="math display">\[\{b_k\}\]</span> 为一个含有 <span class="math display">\[k\]</span> 项的数列且满足 <span class="math display">\[0 &lt; b_i&lt; 1\]</span>，若存在正常数 <span class="math display">\[c_1, c_2\]</span> 使得对任意 <span class="math display">\[x \geq 1, 1 \leq i \leq k, u \in [b_i x , x]\]</span>，均有 <span class="math display">\[c_1 g(x) \leq g(u) \leq c_2 g(x)\]</span> ，则称 <span class="math display">\[g(x)\]</span> 满足多项式增长条件</p></blockquote><p>由定义可知，若存在 <span class="math display">\[c &gt; 0\]</span> ，使得 <span class="math display">\[|g&#39;(x)| \in \mathcal{O}(x^c)\]</span>，则 <span class="math display">\[g(x)\]</span> 满足多项式增长条件。例如，对任意 <span class="math display">\[\alpha, \beta \in \mathbb{R}\]</span>，<span class="math display">\[g(x) = x^{\alpha} \lg^{\beta} x\]</span> 均满足多项式增长条件。</p><p>下面我们来叙述Akra-Bazzi定理：</p><blockquote><p><strong>Theorem:</strong> 设 <span class="math display">\[g(x)\]</span> 为一非负函数， <span class="math display">\[T(x) = \left\{ \begin{aligned} &amp;\Theta(1)&amp;, &amp;1 \leq x \leq X_0 \\ &amp;\sum_\limits{i = 1}^k a_i T(b_i x) +g(x)&amp;, &amp;x &gt; X_0 \end{aligned}\right.\]</span>（其中 <span class="math display">\[k \geq 1, a_i &gt; 0, 0 &lt; b_i &lt; 1\]</span>，<span class="math display">\[X_0\]</span> 满足对任意 <span class="math display">\[1 \leq i \leq k\]</span> 有 <span class="math display">\[X_0 &gt; \frac{1}{b_i}\]</span> 且 <span class="math display">\[X_0&gt; \frac{1}{1-b_i}\]</span>），若 <span class="math display">\[g(x)\]</span> 满足多项式增长条件，<span class="math display">\[p\]</span> 为方程 <span class="math display">\[\sum_\limits{i = 1}^k a_i b_i^p = 1\]</span> 的实数解，则 <span class="math display">\[\begin{aligned}T(x) &amp;= \Theta \left(x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\right)\end{aligned}\]</span></p></blockquote><p>通过该定理，我们可以快速求解许多主方法无法处理的递归式。</p><blockquote><p><strong>Example1:</strong> 设 <span class="math display">\[T(n) = 2T \left( \frac{n}{4}\right) + 3T \left(\frac{n}{6} \right) + n \lg n\]</span>，求 <span class="math display">\[T(n)\]</span> 的渐近解</p><p><strong>解：</strong>由 <span class="math display">\[\frac{2}{4^p} + \frac{3}{6^p} = 1\]</span> 可知 <span class="math display">\[p = 1\]</span></p><p>故由Akra-Bazzi定理可知 <span class="math display">\[\begin{aligned}T(n) &amp;= \Theta \left(n \left(1 + \int_1^n \frac{x \lg x}{x^2} dx\right)\right) \\&amp;=\Theta \left(n \left(1 + \frac{1}{2}\lg^2 n \right)\right) \\&amp;=\Theta \left(n \lg^2 n \right)\end{aligned}\]</span></p></blockquote><blockquote><p><strong>Example2:</strong> 设 <span class="math display">\[T(n) = 3T \left( \frac{n}{3}\right) + \frac{n}{\lg n}\]</span>（<span class="math display">\[n \geq 2\]</span>），求 <span class="math display">\[T(n)\]</span> 的渐近解</p><p><strong>解：</strong>由 <span class="math display">\[\left(\frac{3}{3}\right)^p = 1\]</span> 可知 <span class="math display">\[p = 1\]</span></p><p>故由Akra-Bazzi定理可知 <span class="math display">\[\begin{aligned}T(n) &amp;= \Theta \left(n \left( 1 + \int_2^n \frac{\frac{x}{\lg x}}{x^2} dx\right)\right) \\&amp;=\Theta \left(n \left( 1 + \int_2^n \frac{1}{x \lg x} dx\right)\right) \\&amp;=\Theta \left(n \left( 1 + \lg \lg n \right) \right) \\&amp;=\Theta(n \lg \lg n)\end{aligned}\]</span></p></blockquote><blockquote><p><strong>Example3:</strong> 设 <span class="math display">\[T(n) = \frac{1}{2} T \left( \frac{n}{2} \right) + \frac{1}{n}\]</span>，求 <span class="math display">\[T(n)\]</span> 的渐近解</p><p>解：由 <span class="math display">\[\frac{1}{2} \cdot \left(\frac{1}{2}\right)^p = 1\]</span> 可知 <span class="math display">\[p = -1\]</span></p><p>故由Akra-Bazzi定理可知 <span class="math display">\[\begin{aligned}T(n) &amp;= \Theta \left(n^{-1} \left( 1 + \int_1^n \frac{\frac{1}{x}}{x^0} dx \right)\right) \\&amp;= \Theta(\left(n^{-1} \left(1 + \ln n \right) \right) \\&amp;= \Theta \left(\frac{\ln n}{n}\right)\end{aligned}\]</span></p></blockquote><h2 id="akra-bazzi定理的证明">Akra-Bazzi定理的证明</h2><p>Akra-Bazzi的原始论文中使用了一种称为<strong>阶变换（Order Transform）</strong>的技巧来导出Akra-Bazzi定理，但完整过程篇幅较长且较为复杂。在已经知道结论的情况下，我们还可以使用数学归纳法来证明Akra-Bazzi定理，这种方法更加简洁且相对容易理解。</p><p>首先我们证明一个引理</p><blockquote><p><strong>Lemma:</strong> 若 <span class="math display">\[g(x)\]</span> 为一非负函数且满足多项式增长条件，则存在 <span class="math display">\[c_3, c_4 &gt; 0\]</span>，使得对任意 <span class="math display">\[x \geq 1, 1 \leq i \leq k\]</span>，有 <span class="math display">\[c_3 g(x) \leq x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du \leq c_4 g(x)\]</span></p><p><strong>证明：</strong> <span class="math display">\[g(x)\]</span> 满足多项式增长条件，即存在正常数 <span class="math display">\[c_1, c_2\]</span> 使得对任意 <span class="math display">\[x \geq 1, 1 \leq i \leq k, u \in [b_i x , x]\]</span>，均有 <span class="math display">\[c_1 g(x) \leq g(u) \leq c_2 g(x)\]</span></p><p>故 <span class="math display">\[\begin{aligned}x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du &amp;\leq c_2 x^p g(x) \cdot \int_{b_i x}^x \frac{1}{u^{p + 1}} du \\&amp;\leq c_2 x^p g(x) \cdot (x - b_i x) \cdot \max \{ \frac{1}{(b_i x)^{p+1}}, \frac{1}{x^{p+1}}\} \\&amp;=c_2 \cdot (1-b_i) \cdot \max \{\frac{1}{b_i^{p+1}}, 1 \} \cdot g(x)\end{aligned}\]</span> 因此仅需令 <span class="math display">\[c_4 \geq c_2 \cdot (1-b_i) \cdot \max \{\frac{1}{b_i^{p+1}}, 1 \}\]</span>，就有 <span class="math display">\[x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du \leq c_4 g(x)\]</span></p><p>同理，令 <span class="math display">\[c_3 \leq c_2 \cdot (1-b_i) \cdot \min \{\frac{1}{b_i^{p+1}}, 1 \} \]</span>，就有 <span class="math display">\[x^p \int_{b_i x}^x \frac{g(u)}{u^{p + 1}} du \geq c_3 g(x)\]</span></p><p>故原命题成立</p></blockquote><p>下面我们使用数学归纳法证明存在 <span class="math display">\[c_5&gt;0, x_1 &gt; 1\]</span>，使得对任意 <span class="math display">\[x &gt; x_1\]</span>，有 <span class="math display">\[T(x) \geq c_5 \cdot x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\]</span></p><p>由于 <span class="math display">\[T(x)\]</span> 的取值范围包含大于1的一切实数，我们不能直接对 <span class="math display">\[x\]</span> 进行归纳。</p><p>为了使用数学归纳法，我们令 <span class="math display">\[I_0 = [1, X_0], I_1 = (X_0+1, X_0+2], ..., I_j = (X_0 + j -1, X_0 + j]\]</span>。易见 <span class="math display">\[x\]</span> 必然落在某一个区间 <span class="math display">\[j_0\]</span> 内，且 <span class="math display">\[b_i x\]</span> 必然落在 <span class="math display">\[j_0\]</span> 前面的某一区间内，因此我们可以对 <span class="math display">\[I_j\]</span> 进行归纳。</p><p>当 <span class="math display">\[j=0\]</span> 时，由定义可知 <span class="math display">\[T(x) = \Theta(1)\]</span>，结论显然成立</p><p>若结论对任意 <span class="math display">\[j &lt; j_0\]</span> 均成立，则当 <span class="math display">\[j=j_0\]</span> 时，有 <span class="math display">\[\begin{aligned}T(x) &amp;= \sum_\limits{i = 1}^k a_i T(b_i x) +g(x) \\&amp;\geq \sum_\limits{i = 1}^k a_i \cdot c_5 \cdot (b_i x)^p \left( 1 + \int_1^{b_i x} \frac{g(u)}{u^{p+1}} du\right) +g(x) \\&amp;=c_5 x ^p \sum_\limits{i = 1}^k a_i \cdot b_i^p \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du - \int_{b_i x}^{x} \frac{g(u)}{u^{p+1}} du\right) +g(x) \\&amp;\geq c_5 x ^p \cdot \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du - \frac{c_4}{x_p}g(x)\right) \cdot \sum_\limits{i = 1}^k a_i b_i^p +g(x) \\&amp;=c_5 x ^p \cdot \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du - \frac{c_4}{x_p}g(x)\right) +g(x) \\&amp;=c_5 x ^p \cdot \left( 1 + \int_1^{x} \frac{g(u)}{u^{p+1}} du \right) - (c_4c_5 - 1) g(x)\end{aligned}\]</span> 因此，只需令 <span class="math display">\[c_5 \leq \frac{1}{c_4}\]</span>，就有 <span class="math display">\[T(x) \geq c_5 \cdot x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\]</span> 成立</p><p>即 <span class="math display">\[T(x) = \Omega \left( x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right) \right)\]</span></p><p>同理可证得 <span class="math display">\[T(x) = \mathcal{O} \left( x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right) \right)\]</span></p><p>由此我们便证得了最终的结论 <span class="math display">\[T(x) = \Theta \left(x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\right)\]</span></p><h2 id="推广的akra-bazzi定理">推广的Akra-Bazzi定理</h2><p>事实上，<strong>Tom Leighton</strong>还给出过一个更一般形式的Akra-Bazzi推广定理</p><blockquote><p><strong>Definition（推广的多项式增长条件）:</strong> 设 <span class="math display">\[g(x),h(x)\]</span> 均为定义在非负实数上的函数，<span class="math display">\[\{b_k\}\]</span> 为一个含有 <span class="math display">\[k\]</span> 项的数列且满足 <span class="math display">\[0 &lt; b_i&lt; 1\]</span>，若存在正常数 <span class="math display">\[c_1, c_2\]</span> 使得对任意 <span class="math display">\[x \geq 1, 1 \leq i \leq k, u \in [b_i x + h_i(x), x]\]</span>，均有 <span class="math display">\[c_1 g(x) \leq g(u) \leq c_2 g(x)\]</span> ，则称 <span class="math display">\[g(x)\]</span> 满足多项式增长条件</p></blockquote><blockquote><p><strong>Theorem:</strong> 设 <span class="math display">\[g(x)\]</span> 为一非负函数， <span class="math display">\[T(x) = \left\{ \begin{aligned} &amp;\Theta(1)&amp;, &amp;1 \leq x \leq X_0 \\ &amp;\sum_\limits{i = 1}^k a_i T(b_i x + h_i(x)) +g(x)&amp;, &amp;x &gt; X_0 \end{aligned}\right.\]</span>，若满足以下四个条件：</p><ol type="1"><li><p><span class="math display">\[k \geq 1\]</span>，对任意 <span class="math display">\[1 \leq i \leq k\]</span>，有 <span class="math display">\[a_i &gt; 0, 0 &lt; b_i &lt; 1\]</span></p></li><li><p><span class="math display">\[X_0\]</span> 为一足够大的常数，使得存在 <span class="math display">\[\varepsilon &gt; 0\]</span>，对任意 <span class="math display">\[1 \leq i \leq k, x \geq X_0\]</span>，满足以下四个条件： <span class="math display">\[\begin{aligned}&amp;(a) \left( 1 - \frac{1}{b_i \lg^{1+\varepsilon} x} \right)^p \left( 1 + \frac{1}{\lg^{\frac{\varepsilon}{2}} \left( b_i x + \frac{x}{\lg^{1+\varepsilon} x}\right)} \right) \geq 1+ \frac{1}{\lg^{\frac{\varepsilon}{2}} x} \\&amp;(b) \left( 1 + \frac{1}{b_i \lg^{1+\varepsilon} x} \right)^p \left( 1 - \frac{1}{\lg^{\frac{\varepsilon}{2}} \left( b_i x + \frac{x}{\lg^{1+\varepsilon} x}\right)} \right) \leq 1- \frac{1}{\lg^{\frac{\varepsilon}{2}} x} \\&amp;(c) \frac{1}{2} \left( 1 + \frac{1}{\lg^{\frac{\varepsilon}{2}} x}\right) \leq 1 \\&amp;(d) 2 \left( 1 - \frac{1}{\lg^{\frac{\varepsilon}{2}} x} \right) \geq 1\end{aligned}\]</span></p></li><li><p>存在 <span class="math display">\[\varepsilon &gt; 0\]</span> 使得对任意 <span class="math display">\[1 \leq i \leq k, x &gt; X_0\]</span>，均有 <span class="math display">\[|h_i(x)| \leq \frac{x}{\lg^{1+\varepsilon} x}\]</span></p></li><li><p><span class="math display">\[g(x)\]</span> 满足多项式增长条件</p></li></ol><p>若设 <span class="math display">\[p\]</span> 为方程 <span class="math display">\[\sum_\limits{i = 1}^k a_i b_i^p = 1\]</span> 的实数解，则 <span class="math display">\[\begin{aligned}T(x) &amp;= \Theta \left(x^p \left( 1 + \int_1^x \frac{g(u)}{u^{p+1}} du\right)\right)\end{aligned}\]</span></p></blockquote><p>该定理在Akra-Bazzi的基础上，进一步考虑了递归式参数中带余项的情况，因此适用面更广。与Akra-Bazzi类似，其正确性同样可以使用数学归纳法验证，不过篇幅较长，这里就不详细阐述了。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长公共子序列</title>
    <link href="/2020/11/20/algorithm/course-exp/algorithm-exp7/"/>
    <url>/2020/11/20/algorithm/course-exp/algorithm-exp7/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><ol type="1"><li><p>编写随机整数生成算法，生成0到9范围内的N个随机整数并输出；</p></li><li><p>编写计算最长公共子序列方法的代码；</p></li><li><p>随机生成两组范围为0到9的5、50、500、5000个随机整数，并求两组整数的最长公共子序列</p></li><li><p>随机生成一组范围为0到9的5000个随机整数和另一组范围为0到9的5、50、500、5000个随机整数，并求两组整数的最长公共子序列</p></li></ol><a id="more"></a><h2 id="实现代码">实现代码</h2><h3 id="随机数生成器">随机数生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout1</span><span class="hljs-params">(<span class="hljs-string">&quot;data1.txt&quot;</span>)</span></span>;<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout2</span><span class="hljs-params">(<span class="hljs-string">&quot;data2.txt&quot;</span>)</span></span>;<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">int</span> n1, n2;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n1&gt;&gt;n2;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++) fout1&lt;&lt;rand() % <span class="hljs-number">10</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n2; i++) fout2&lt;&lt;rand() % <span class="hljs-number">10</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    fout1.close();<br>    fout2.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列">最长公共子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> d[<span class="hljs-number">5005</span>][<span class="hljs-number">5005</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin1</span><span class="hljs-params">(<span class="hljs-string">&quot;data1.txt&quot;</span>)</span></span>;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin2</span><span class="hljs-params">(<span class="hljs-string">&quot;data2.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">5005</span>], b[<span class="hljs-number">5005</span>], r[<span class="hljs-number">5005</span>], n1 = <span class="hljs-number">0</span>, n2 = <span class="hljs-number">0</span>, p, q, cnt;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;原始序列1: &quot;</span>;<br>    <span class="hljs-keyword">while</span> (!fin1.eof())&#123;<br>        fin1&gt;&gt;a[n1 + <span class="hljs-number">1</span>];<br>        n1++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1 - <span class="hljs-number">1</span>; i++) <span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;原始序列2: &quot;</span>;<br>    <span class="hljs-keyword">while</span>(!fin2.eof())&#123;<br>        fin2&gt;&gt;b[n2 + <span class="hljs-number">1</span>];<br>        n2++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n2 - <span class="hljs-number">1</span>; i++) <span class="hljs-built_in">cout</span>&lt;&lt;b[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    n1--;<br>    n2--;<br>    start = clock();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n1; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n2; j++)&#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span>) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(a[i] == b[j]) d[i][j] = d[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> d[i][j] = max(d[i][j - <span class="hljs-number">1</span>], d[i - <span class="hljs-number">1</span>][j]);<br>            &#125;<br>        &#125;<br>    p = n1;<br>    q = n2;<br>    cnt = d[n1][n2] - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (p &gt; <span class="hljs-number">0</span> &amp;&amp; q &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(d[p][q] == (d[p - <span class="hljs-number">1</span>][q - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) &amp;&amp; a[p] == b[q])&#123;<br>            r[cnt] = a[p];<br>            cnt--;<br>            p = p - <span class="hljs-number">1</span>;<br>            q = q - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(d[p][q<span class="hljs-number">-1</span>] == d[p - <span class="hljs-number">1</span>][q])&#123;<br>            q = q - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[p][q] == d[p][q - <span class="hljs-number">1</span>])&#123;<br>            q = q - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            p = p - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    stop = clock();<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;最长公共子序列: &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; d[n1][n2]; i++) <span class="hljs-built_in">cout</span>&lt;&lt;r[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin1.close();<br>    fin2.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行效率">运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h2 id="总结">总结</h2><p>使用动态规划算法求两个长度分别为 <span class="math display">\[m\]</span> 和 <span class="math display">\[n\]</span> 的序列的公共子序列的时间复杂度为 <span class="math display">\[\Theta(mn)\]</span>，回溯打印公共子序列串的时间复杂度为 <span class="math display">\[\Theta(m+n)\]</span>，故总的时间复杂度为 <span class="math display">\[\Theta(mn)\]</span>。在实验中，当 <span class="math display">\[m=n\]</span> 时，算法的时间复杂度始终为 <span class="math display">\[\Theta(n^2)\]</span>，故在对数坐标下运行时间呈线性变化。而当 <span class="math display">\[m\]</span> 从远小于 <span class="math display">\[n\]</span> 逐渐增大到 <span class="math display">\[n\]</span> 时，算法的时间复杂度从 <span class="math display">\[\Theta(n)\]</span> 逐渐变化为 <span class="math display">\[\Theta(n^2)\]</span>，故在对数坐标下运行时间曲线的斜率逐渐增大。综上所述，实验结果与理论基本吻合。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2020/11/13/algorithm/course-exp/algorithm-exp6/"/>
    <url>/2020/11/13/algorithm/course-exp/algorithm-exp6/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><ol type="1"><li><p>编写随机整数生成算法，生成S到T范围内的N个随机整数并输出；</p></li><li><p>编写红黑树构建算法，中序遍历各节点，输出颜色和值；</p></li><li><p>随机生成 <span class="math display">\[10^2\]</span>、<span class="math display">\[10^3\]</span>、<span class="math display">\[10^4\]</span>、<span class="math display">\[10^5\]</span>、<span class="math display">\[10^6\]</span> 个<strong>不同的</strong>数，使用红黑树构建算法，并画图描述不同情况下的运行时间差异；</p></li></ol><a id="more"></a><h2 id="实现代码">实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> data;<br>    <span class="hljs-keyword">int</span> color; <span class="hljs-comment">//0 is black, 1 is red</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">parent</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">lchild</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">rchild</span>;</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lrotate</span><span class="hljs-params">(struct node *n)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">nr</span> = <span class="hljs-title">n</span>-&gt;<span class="hljs-title">rchild</span>;</span><br>    n-&gt;rchild = nr-&gt;lchild;<br>    <span class="hljs-keyword">if</span> (nr-&gt;lchild) nr-&gt;lchild-&gt;parent = n;<br>    nr-&gt;parent = n-&gt;parent;<br>    <span class="hljs-keyword">if</span>(n-&gt;parent) &#123;<br>        <span class="hljs-keyword">if</span> (n == n-&gt;parent-&gt;lchild) n-&gt;parent-&gt;lchild = nr;<br>        <span class="hljs-keyword">else</span> n-&gt;parent-&gt;rchild = nr;<br>    &#125;<br>    nr-&gt;lchild = n;<br>    n-&gt;parent = nr;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rrotate</span><span class="hljs-params">(struct node *n)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">nl</span> = <span class="hljs-title">n</span>-&gt;<span class="hljs-title">lchild</span>;</span><br>    n-&gt;lchild = nl-&gt;rchild;<br>    <span class="hljs-keyword">if</span> (nl-&gt;rchild) nl-&gt;rchild-&gt;parent = n;<br>    nl-&gt;parent = n-&gt;parent;<br>    <span class="hljs-keyword">if</span>(n-&gt;parent) &#123;<br>        <span class="hljs-keyword">if</span> (n == n-&gt;parent-&gt;lchild) n-&gt;parent-&gt;lchild = nl;<br>        <span class="hljs-keyword">else</span> n-&gt;parent-&gt;rchild = nl;<br>    &#125;<br>    nl-&gt;rchild = n;<br>    n-&gt;parent = nl;<br>&#125;<br><span class="hljs-function">struct node *<span class="hljs-title">fixup</span><span class="hljs-params">(struct node *n)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">t</span>;</span><br>    <span class="hljs-keyword">while</span>(n-&gt;parent &amp;&amp; n-&gt;parent-&gt;color == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(n-&gt;parent == n-&gt;parent-&gt;parent-&gt;lchild)&#123;<br>            t = n-&gt;parent-&gt;parent-&gt;rchild;<br>            <span class="hljs-keyword">if</span> (t &amp;&amp; t-&gt;color == <span class="hljs-number">1</span>)&#123;<br>                n-&gt;parent-&gt;color = <span class="hljs-number">0</span>;<br>                t-&gt;color = <span class="hljs-number">0</span>;<br>                n-&gt;parent-&gt;parent-&gt;color = <span class="hljs-number">1</span>;<br>                n = n-&gt;parent-&gt;parent;<br>                <span class="hljs-keyword">if</span>(!n-&gt;parent) n-&gt;color = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (n == n-&gt;parent-&gt;rchild) &#123;<br>                    n = n-&gt;parent;<br>                    lrotate(n);<br>                &#125;<br>                n-&gt;parent-&gt;color = <span class="hljs-number">0</span>;<br>                n-&gt;parent-&gt;parent-&gt;color = <span class="hljs-number">1</span>;<br>                rrotate(n-&gt;parent-&gt;parent);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            t = n-&gt;parent-&gt;parent-&gt;lchild;<br>            <span class="hljs-keyword">if</span> (t &amp;&amp; t-&gt;color == <span class="hljs-number">1</span>)&#123;<br>                n-&gt;parent-&gt;color = <span class="hljs-number">0</span>;<br>                t-&gt;color = <span class="hljs-number">0</span>;<br>                n-&gt;parent-&gt;parent-&gt;color = <span class="hljs-number">1</span>;<br>                n = n-&gt;parent-&gt;parent;<br>                <span class="hljs-keyword">if</span>(!n-&gt;parent) n-&gt;color = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (n == n-&gt;parent-&gt;lchild) &#123;<br>                    n = n-&gt;parent;<br>                    rrotate(n);<br>                &#125;<br>                n-&gt;parent-&gt;color = <span class="hljs-number">0</span>;<br>                n-&gt;parent-&gt;parent-&gt;color = <span class="hljs-number">1</span>;<br>                lrotate(n-&gt;parent-&gt;parent);<br>            &#125;<br>        &#125;<br>    &#125;<br>    t = n;<br>    <span class="hljs-keyword">while</span> (t-&gt;parent)&#123;<br>        t = t-&gt;parent;<br>    &#125;<br>    t-&gt;color = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-function">struct node *<span class="hljs-title">insert</span><span class="hljs-params">(struct node *root, struct node *n)</span></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">x</span>, *<span class="hljs-title">y</span>, *<span class="hljs-title">nroot</span>;</span><br>    x = root;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        y = x;<br>        <span class="hljs-keyword">if</span>(n-&gt;data &lt; x-&gt;data)&#123;<br>            x = x-&gt;lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            x = x-&gt;rchild;<br>        &#125;<br>    &#125;<br>    n-&gt;parent = y;<br>    <span class="hljs-keyword">if</span>(n-&gt;data &lt; y-&gt;data)&#123;<br>        y-&gt;lchild = n;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        y-&gt;rchild = n;<br>    &#125;<br>    n-&gt;color = <span class="hljs-number">1</span>;<br>    nroot = fixup(n);<br>    <span class="hljs-keyword">return</span> nroot;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(struct node *n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span>;<br>    traverse(n-&gt;lchild);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;n-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;n-&gt;color&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    traverse(n-&gt;rchild);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">1000005</span>], n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!fin.eof())&#123;<br>        fin&gt;&gt;a[n];<br>        n++;<br>    &#125;<br>    n--;<br>    start = clock();<br>    node *r = <span class="hljs-keyword">new</span> node&#123;a[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        node *n = <span class="hljs-keyword">new</span> node&#123;a[i], <span class="hljs-number">1</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>&#125;;<br>        r = insert(r, n);<br>    &#125;<br>    stop = clock();<br>    traverse(r);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total Time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-string">&quot;s&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行效率">运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h2 id="总结">总结</h2><p>对于一颗有 <span class="math display">\[n\]</span> 个结点的红黑树，可以用 <span class="math display">\[\mathcal{O}(\lg n)\]</span> 的时间向其中插入一个新结点，故构建一棵有 <span class="math display">\[n\]</span> 个结点红黑树的总运行时间为<span class="math display">\[\mathcal{O}(n \lg n)\]</span>。从图表中可以看出，在对数坐标下，红黑树构建算法随数据规模的增大呈线性增长，与理论基本吻合。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐波那契数的相关算法</title>
    <link href="/2020/10/30/algorithm/theory/fibonacci/"/>
    <url>/2020/10/30/algorithm/theory/fibonacci/</url>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列">斐波那契数列</h2><p>斐波那契数列由以下递推式定义： <span class="math display">\[\left\{\begin{aligned}&amp;F(0)=0 \\&amp;F(1)=1 \\&amp;F(n)=F(n-1)+F(n-2),n \geq 2\end{aligned}\right.\]</span> <a id="more"></a></p><p>下面我们来推导斐波那契数列的通项公式</p><p>设矩阵 <span class="math display">\[M=\begin{pmatrix} m_{11} &amp; m_{12} \\ m_{21} &amp; m_{22} \end{pmatrix}\]</span>，使得 <span class="math display">\[\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix} =M \begin{pmatrix} F_{n} \\ F_{n-1} \end{pmatrix}\]</span></p><p>故 <span class="math display">\[\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}=\begin{pmatrix}m_{11} &amp; m_{12} \\m_{21} &amp; m_{22}\end{pmatrix}\begin{pmatrix}F_{n} \\F_{n-1}\end{pmatrix}=\begin{pmatrix}m_{11}F_{n}+m_{12}F_{n-1} \\m_{21}F_{n}+m_{22}F_{n-1}\end{pmatrix}\]</span> 对比等式左右可得 <span class="math display">\[m_{11}=m_{12}=m_{21}=1,m_{22}=0\]</span>，即 <span class="math display">\[M=\begin{pmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\]</span></p><p>由此可知 <span class="math display">\[\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}=\begin{pmatrix}1 &amp; 1 \\1 &amp; 0\end{pmatrix}\begin{pmatrix}F_{n} \\F_{n-1}\end{pmatrix}\]</span> 对该矩阵等式做递推，可得 <span class="math display">\[\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}=\begin{pmatrix}1 &amp; 1 \\1 &amp; 0\end{pmatrix}^n\begin{pmatrix}F_{1} \\F_{0}\end{pmatrix}=\begin{pmatrix}1 &amp; 1 \\1 &amp; 0\end{pmatrix}^n\begin{pmatrix}1 \\0\end{pmatrix}\]</span> 易知 <span class="math display">\[\begin{pmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}\]</span> 的特征多项式 <span class="math display">\[f(\lambda) = \begin{vmatrix} \lambda - 1 &amp; -1 \\ -1 &amp; \lambda \end{vmatrix} = \lambda^2 - \lambda - 1\]</span></p><p>令 <span class="math display">\[f(\lambda) = 0\]</span>，可得该矩阵的特征值 <span class="math display">\[\lambda_1 = \frac{1 - \sqrt{5}}{2}, \lambda_2 = \frac{1 + \sqrt{5}}{2}\]</span></p><p>由此可知该矩阵可相似对角化</p><p>对于 <span class="math display">\[\lambda_1 = \frac{1-\sqrt{5}}{2}\]</span>，其对应的特征向量 <span class="math display">\[\alpha_1 = \left(\frac{1-\sqrt{5}}{2},1\right)\]</span></p><p>对于 <span class="math display">\[\lambda_2 = \frac{1+\sqrt{5}}{2}\]</span>，其对应的特征向量 <span class="math display">\[\alpha_2 = \left(\frac{1+\sqrt{5}}{2},1\right)\]</span></p><p>故若令 <span class="math display">\[P=\begin{pmatrix} \frac{1-\sqrt{5}}{2} &amp; \frac{1+\sqrt{5}}{2} \\ 1 &amp; 1 \end{pmatrix}\]</span>，则 <span class="math display">\[\begin{pmatrix}1 &amp; 1 \\1 &amp; 0\end{pmatrix}=P\begin{pmatrix}\frac{1-\sqrt{5}}{2} &amp; 0\\ 0 &amp; \frac{1+\sqrt{5}}{2}\end{pmatrix}P^{-1}\]</span> 于是 <span class="math display">\[\begin{aligned}\begin{pmatrix}F_{n+1} \\F_n\end{pmatrix}&amp;=P\begin{pmatrix}\frac{1-\sqrt{5}}{2} &amp; 0\\ 0 &amp; \frac{1+\sqrt{5}}{2}\end{pmatrix}^nP^{-1}\begin{pmatrix}1 \\0\end{pmatrix} \\&amp;=\begin{pmatrix}\frac{1-\sqrt{5}}{2} &amp; \frac{1+\sqrt{5}}{2} \\1 &amp; 1\end{pmatrix}\begin{pmatrix}\left(\frac{1-\sqrt{5}}{2}\right)^n &amp; 0\\ 0 &amp; \left(\frac{1+\sqrt{5}}{2}\right)^n\end{pmatrix}\begin{pmatrix}-\frac{1}{\sqrt{5}} &amp; \frac{5 + \sqrt{5}}{10} \\\frac{1}{\sqrt{5}} &amp; \frac{5 - \sqrt{5}}{10}\end{pmatrix}\begin{pmatrix}1 \\0\end{pmatrix} \\&amp;=\begin{pmatrix}\frac{1-\sqrt{5}}{2} &amp; \frac{1+\sqrt{5}}{2} \\1 &amp; 1\end{pmatrix}\begin{pmatrix}-\frac{1}{\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n \\\frac{1}{\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^n\end{pmatrix} \\&amp;=\begin{pmatrix}\frac{\sqrt{5}-1}{2\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n + \frac{\sqrt{5}+1}{2\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^n \\-\frac{1}{\sqrt{5}}\left(\frac{1-\sqrt{5}}{2}\right)^n + \frac{1}{\sqrt{5}}\left(\frac{1+\sqrt{5}}{2}\right)^n\end{pmatrix}\end{aligned}\]</span> 由此我们得到了斐波那契数列的通项公式 <span class="math display">\[F_n = \frac{1}{\sqrt{5}} \left[\left(\frac{1+\sqrt{5}}{2}\right)^n - \left(\frac{1-\sqrt{5}}{2}\right)^n \right]\]</span></p><h2 id="朴素递归算法">朴素递归算法</h2><p>朴素递归算法即为递推式定义的程序表达，采用递归的方法实现。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Fibonacci(n - <span class="hljs-number">1</span>) + Fibonacci(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>易得该算法时间复杂度的递推表达式为 <span class="math display">\[T(n)=T(n-1)+T(n-2)+\Theta(1)\]</span></p><p>观察递归树可以发现，所有叶子结点的和就是 <span class="math display">\[\Theta(F_n)\]</span> ，而所有内部节点的和为 <span class="math display">\[\Theta(F_n-1)\]</span></p><p>故朴素递归算法的时间复杂度 <span class="math display">\[\begin{aligned}T(n)&amp;=\Theta(F_n) + \Theta(F_n-1) \\&amp;=\Theta(F_n) \\&amp;=\Theta\left(\left(\frac{1+\sqrt{5}}{2}\right)^n\right) \\&amp;=\mathcal{O}(1.62^n)\end{aligned}\]</span></p><h2 id="自下而上算法">自下而上算法</h2><p>朴素递归算法的时间复杂度为指数级，这显然是难以接受的。观察发现朴素递归算法的主要问题是重复求解了许多子问题，其本质原因在于朴素递归算法是自上而下的求解子问题，而不同子问题中重叠的部分无法相互影响。故我们换一种思路，自下而上的求解，就可以很好的解决这一问题。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>  <span class="hljs-keyword">int</span> a[N]; <span class="hljs-comment">//N is the biggest possible value</span><br>  a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  a[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>    a[i] = a[i - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">2</span>];<br>  &#125;<br>  <span class="hljs-keyword">return</span> a[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>易知该算法的时间复杂度 <span class="math display">\[T(n)=n-1=\Theta(n)\]</span></p><h2 id="矩阵快速幂算法">矩阵快速幂算法</h2><p>自下而上算法已经将原本的指数级时间复杂度降低到了多项式级，我们希望能够进一步的将其降低到对数级别。自然的，我们首先想到的是利用其通项公式并通过快速幂的方法来求解。但斐波那契数列的通项公式中包含无理数，由于计算机的精度限制，计算结果可能并不正确，故这种方法显然是不可靠的。</p><p><strong>注：</strong>事实上，若不存在精度限制的问题，斐波那契数列还可以表示为 <span class="math display">\[F_n = \left[ \left(\frac{1+\sqrt{5}}{2}\right)^n \right]\]</span> （其中 <span class="math display">\[[x]\]</span> 表示取整到离 <span class="math display">\[x\]</span> 最近的整数）</p><p>于是问题转化为是否存在一个仅需在整数域内进行运算的斐波那契通项公式。回顾上面求解斐波那契数列通项公式的过程，注意到 <span class="math display">\[\begin{pmatrix} F_{n+1} \\ F_n \end{pmatrix} = \begin{pmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{pmatrix}^n \begin{pmatrix} 1 \\ 0 \end{pmatrix}\]</span>，故我们可以通过求解该矩阵来得到 <span class="math display">\[F_n\]</span> 的值。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">matrix</span>&#123;</span><br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>    matrix(<span class="hljs-keyword">int</span> a11, <span class="hljs-keyword">int</span> a12, <span class="hljs-keyword">int</span> a21, <span class="hljs-keyword">int</span> a22)&#123;<br>        a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = a11;<br>        a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = a12;<br>        a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = a21;<br>        a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = a22;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//This function can only handle 2*2 matrix multiplication</span><br><span class="hljs-function">matrix <span class="hljs-title">matrixMult</span><span class="hljs-params">(matrix matA, matrix matB)</span></span>&#123;<br>    <span class="hljs-function">matrix <span class="hljs-title">matR</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k =<span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; k++)<br>                matR.a[i][j] += matA.a[i][k] * matB.a[k][j];<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">matrix <span class="hljs-title">matrixPow</span><span class="hljs-params">(matrix mat, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> mat;<br>    <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>        matrix matT = matrixPow(mat, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> matrixMult(matT, matT);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        matrix matT1 = matrixPow(mat, (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        matrix matT2 = matrixMult(matT1, matT1);<br>        <span class="hljs-keyword">return</span> matrixMult(matT2, mat);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span>&#123;<br>        matrix matT(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        matrix matR = matrixPow(matT, n);<br>        <span class="hljs-keyword">return</span> matR.a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析该算法，发现其时间复杂度的递推表达式为 <span class="math display">\[T(n) = T\left(\frac{n}{2}\right) + \Theta(1)\]</span>。故由主定理可知该矩阵快速幂算法的时间复杂度为 <span class="math display">\[T(n) = \Theta(\lg n)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机化快速选择算法</title>
    <link href="/2020/10/23/algorithm/course-exp/algorithm-exp5/"/>
    <url>/2020/10/23/algorithm/course-exp/algorithm-exp5/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><ol type="1"><li>编写随机整数生成算法，生成S到T范围内的N个随机整数并输出；</li><li>编写随机选择算法和SELECT算法；</li><li>随机生成 <span class="math display">\[10^2、10^3、10^4、10^5、10^6\]</span> 个数，使用随机选择算法和SELECT算法找到第 <span class="math display">\[0.5N\]</span> 大的数输出，并画图描述不同情况下的运行时间差异；</li><li>随机生成 <span class="math display">\[10^6\]</span> 个数，使用随机选择算法和SELECT算法找到第 <span class="math display">\[0.2N, 0.4N, 0.6N, 0.8N\]</span> 大的数输出，并画图描述不同情况下的运行时间差异；</li></ol><a id="more"></a><h2 id="实现代码">实现代码</h2><h3 id="随机数生成器">随机数生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> s, t, n;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;s&gt;&gt;t&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) fout&lt;&lt;s + rand() % (t - s)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    fout.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="随机选择算法">随机选择算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1000005</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *m, <span class="hljs-keyword">int</span> *n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> tmp;<br>    tmp = *m;<br>    *m = *n;<br>    *n = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x = a[r];<br>    <span class="hljs-keyword">int</span> i = p<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = p;j &lt; r; j++)&#123;<br>        <span class="hljs-keyword">if</span>(a[j] &lt;= x)&#123;<br>            i = i + <span class="hljs-number">1</span>;<br>            swap(&amp;a[i], &amp;a[j]);<br>        &#125;<br>    &#125;<br>    swap(&amp;a[i+<span class="hljs-number">1</span>], &amp;a[r]);<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">random_partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> t = p + rand() % (r - p + <span class="hljs-number">1</span>);<br>    swap(&amp;a[t], &amp;a[r]);<br>    <span class="hljs-keyword">return</span> partition(p, r);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">random_select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p == r) <span class="hljs-keyword">return</span> a[p];<br>    <span class="hljs-keyword">int</span> pivot = random_partition(p, r);<br>    <span class="hljs-keyword">int</span> k = pivot - p + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(i == k) <span class="hljs-keyword">return</span> a[pivot];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; k) <span class="hljs-keyword">return</span> random_select(p, pivot - <span class="hljs-number">1</span>, i);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> random_select(pivot + <span class="hljs-number">1</span>, r, i - k);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> n, i;<br>    n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        fin&gt;&gt;a[n];<br>        n++;<br>    &#125;<br>    n--;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;i;<br>    start = clock();<br>    <span class="hljs-built_in">cout</span>&lt;&lt;random_select(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, i)&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    stop = clock();<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total Time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>) (stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="select算法">SELECT算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1000005</span>];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">I2D</span>&#123;</span><br>    <span class="hljs-keyword">int</span> index;<br>    <span class="hljs-keyword">int</span> value;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *m, <span class="hljs-keyword">int</span> *n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> tmp;<br>    tmp = *m;<br>    *m = *n;<br>    *n = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> pivot)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> x = a[pivot];<br>    <span class="hljs-keyword">int</span> i = p<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = p;j &lt;= r; j++)&#123;<br>        <span class="hljs-keyword">if</span>(a[j] &lt;= x)&#123;<br>            i = i + <span class="hljs-number">1</span>;<br>            swap(&amp;a[i], &amp;a[j]);<br>        &#125;<br>    &#125;<br>    swap(&amp;a[i], &amp;a[pivot]);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> key, j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = l; i &lt;= r; i++)&#123;<br>        key = a[i];<br>        j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j &gt;= l &amp;&amp; a[j] &gt; key)&#123;<br>            a[j + <span class="hljs-number">1</span>] = a[j];<br>            j--;<br>        &#125;<br>        a[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>&#125;<br><span class="hljs-function">I2D <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(r - p &lt; <span class="hljs-number">140</span>)&#123;<br>        insert_sort(p, r);<br>        I2D pack;<br>        pack.index = p + i - <span class="hljs-number">1</span>;<br>        pack.value = a[p + i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> pack;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt;= (r - p) / <span class="hljs-number">5</span>; u++)&#123;<br>        <span class="hljs-keyword">if</span>(p + u * <span class="hljs-number">5</span> + <span class="hljs-number">4</span> &gt; r)&#123;<br>            insert_sort(p + u * <span class="hljs-number">5</span>, r);<br>            <span class="hljs-keyword">int</span> mid = p + <span class="hljs-number">5</span> * u + (r - (p + <span class="hljs-number">5</span> * u)) / <span class="hljs-number">2</span>;<br>            swap(&amp;a[mid], &amp;a[p + u]);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            insert_sort(p + u * <span class="hljs-number">5</span>, p + u * <span class="hljs-number">5</span> + <span class="hljs-number">4</span>);<br>            <span class="hljs-keyword">int</span> mid = p + <span class="hljs-number">5</span> * u + <span class="hljs-number">2</span>;<br>            swap(&amp;a[mid], &amp;a[p + u]);<br>        &#125;<br>    &#125;<br>    I2D tmpPack = select(p, p + (r - p) / <span class="hljs-number">5</span>, ((r - p) / <span class="hljs-number">5</span> + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">int</span> tmp = tmpPack.index;<br>    <span class="hljs-keyword">int</span> pivot = partition(p, r, tmp);<br>    <span class="hljs-keyword">int</span> k = pivot - p + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(i == k) &#123;<br>        I2D subPack;<br>        subPack.index = pivot;<br>        subPack.value = a[pivot];<br>        <span class="hljs-keyword">return</span> subPack;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &lt; k) <span class="hljs-keyword">return</span> select(p, pivot - <span class="hljs-number">1</span>, i);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> select(pivot + <span class="hljs-number">1</span>, r, i - k);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> n, i;<br>    n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        fin&gt;&gt;a[n];<br>        n++;<br>    &#125;<br>    n--;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;i;<br>    start = clock();<br>    I2D result = select(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, i);<br>    <span class="hljs-built_in">cout</span>&lt;&lt;result.value&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    stop = clock();<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total Time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>) (stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行效率">运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h2 id="总结">总结</h2><p>从理论上看，随机选择算法（Rand-Select）的平均时间复杂度为 <span class="math display">\[\mathcal{O}(n)\]</span>，而在最坏情况下会降为 <span class="math display">\[\Theta(n^2)\]</span>；而选择算法（Select）在最坏情况下的时间复杂度也为<span class="math display">\[\mathcal{O}(n)\]</span>，优于随机选择算法。然而在实际运行时，随机选择算法直接通过随机数确定了pivot，而选择算法需要通过插入排序并递归取中位数的方式找出区间最优的pivot，对数据的预处理耗时较大，故选择算法的实际运行效率反而不如随机选择算法，这也与实验结果相吻合。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数排序</title>
    <link href="/2020/10/16/algorithm/course-exp/algorithm-exp4/"/>
    <url>/2020/10/16/algorithm/course-exp/algorithm-exp4/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><ol type="1"><li>随机生成 <span class="math display">\[1...M\]</span> 范围内的N个整数；</li><li>编写计数排序算法；</li><li>在相同 <span class="math display">\[M\]</span> 的条件下，<span class="math display">\[N\]</span> 分别等于 <span class="math display">\[0.1M, 0.2M, 0.5M, 1M\]</span> 时的运行时间；</li><li>在相同 <span class="math display">\[N\]</span> 的条件下，<span class="math display">\[M\]</span> 分别等于 <span class="math display">\[2N，5N，10N，20N\]</span> 时的运行时间。</li></ol><a id="more"></a><h2 id="实现代码">实现代码</h2><h3 id="随机数生成器">随机数生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> n, m;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) fout&lt;&lt;<span class="hljs-number">1</span> + rand() % (m - <span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    fout.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计数排序">计数排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; a;<br>    <span class="hljs-keyword">int</span> n, tmp, maxn, minn;<br>    maxn = <span class="hljs-number">-99999999</span>;<br>    minn = <span class="hljs-number">99999999</span>;<br>    <span class="hljs-keyword">while</span> (!fin.eof())&#123;<br>        fin&gt;&gt;tmp;<br>        <span class="hljs-keyword">if</span>(tmp &gt; maxn) maxn = tmp;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp &lt; minn) minn = tmp;<br>        a.push_back(tmp);<br>        n++;<br>    &#125;<br>    n--;<br>    vector&lt;int&gt; c(maxn - minn + 1, 0), r(n);<br>    start = clock();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size(); i++)&#123;<br>        c[a[i] - minn]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; c.size(); i++)&#123;<br>        c[i] = c[i<span class="hljs-number">-1</span>] + c[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.size(); i++)&#123;<br>        r[c[a[i] - minn] - <span class="hljs-number">1</span>] = a[i];<br>        c[a[i] - minn]--;<br>    &#125;<br>    stop = clock();<br>    <span class="hljs-comment">//for(int i = 0; i &lt; r.size(); i++) cout&lt;&lt;r[i]&lt;&lt;&quot; &quot;;</span><br>    <span class="hljs-comment">//cout&lt;&lt;endl;</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total time: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>) (stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="运行效率">运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h2 id="总结">总结</h2><p>计数排序的时间复杂度为 <span class="math display">\[O(n+k)\]</span>。实验中 <span class="math display">\[N\]</span> 和 <span class="math display">\[M\]</span> 的值分别影响 <span class="math display">\[n\]</span> 和 <span class="math display">\[k\]</span>，随着 <span class="math display">\[N\]</span> 和 <span class="math display">\[M\]</span> 的增大，运行时间呈线性增长。考虑到计算机在实际运行时的系统调度偏差，实验结果基本与理论分析吻合。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和式的求解方法</title>
    <link href="/2020/10/11/math-combination/sum-solve/"/>
    <url>/2020/10/11/math-combination/sum-solve/</url>
    
    <content type="html"><![CDATA[<h2 id="扰动法">扰动法</h2><p>扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。</p><a id="more"></a><p>令 <span class="math display">\[S_n = \sum_\limits{0 \leq k \leq n} a_k\]</span> <span class="math display">\[\begin{aligned}S_n + a_{n+1} &amp;= \sum_\limits{0 \leq k \leq n+1} a_k \\&amp;= a_0 + \sum_\limits{1 \leq k \leq n+1} a_k \\&amp;= a_0 + \sum_\limits{1 \leq k+1 \leq n+1} a_{k+1} \\&amp;= a_0 + \sum_\limits{0 \leq k \leq n} a_{k+1}\end{aligned}\]</span> 若能将 <span class="math display">\[\sum_\limits{0 \leq k \leq n} a_{k+1}\]</span> 写为 <span class="math display">\[S_n\]</span> 的表达式，即可求出该求和式的通项公式</p><blockquote><p><strong>Example1:</strong></p><p>求等比数列和 <span class="math display">\[S_n = \sum_\limits{0 \leq k \leq n} a q^k \ \ (q \neq 1)\]</span> 的通项公式</p><p><strong>解：</strong> 由上述公式可知 <span class="math display">\[\begin{aligned}S_n + a_{n+1} &amp;= a + \sum_\limits{0 \leq k \leq n} aq^{k+1} \\&amp;=a + q \sum_\limits{0 \leq k \leq n} aq^k \\&amp;=a + q S_n\end{aligned}\]</span> 从而 <span class="math inline">\((1-q)S_n = a - aq^{n+1}\)</span></p><p>故 <span class="math inline">\(S_n = \frac{a\left(1-q^{n+1} \right)}{1-q} \ \ (q \neq 1)\)</span></p><p><strong>Example2:</strong></p><p>求等比差数列和 <span class="math display">\[S_n = \sum_\limits{0 \leq k \leq n} k \cdot q^k \ \ (q \neq 1)\]</span> 的通项公式</p><p><strong>解：</strong> 由上述公式可知 <span class="math display">\[\begin{aligned}S_n + a_{n+1} &amp;= 0 + \sum_\limits{0 \leq k \leq n} (k+1) \cdot q^{k+1} \\&amp;=\sum_\limits{0 \leq k \leq n} k \cdot q^{k+1} + \sum_\limits{0 \leq k \leq n} q^{k+1} \\&amp;=q \sum_\limits{0 \leq k \leq n} k \cdot q^k + q \sum_\limits{0 \leq k \leq n} q^k \\&amp;=q S_n + q \cdot \frac{1-q^{n+1}}{1-q}\end{aligned}\]</span> 从而 <span class="math inline">\((1-q)S_n = \frac{q-q^{n+2}}{1-q} - (n+1) \cdot q^{n+1}\)</span></p><p>故 <span class="math display">\[\begin{aligned}S_n &amp;= \frac{q-q^{n+2}}{(1-q)^2} - \frac{(n+1) \cdot q^{n+1}}{1-q} \\&amp;= \frac{q-(n+1)q^{n+1} + nq^{n+2}}{(1-q)^2} \ \ (q \neq 1)\end{aligned}\]</span></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>Sequence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归式的解法</title>
    <link href="/2020/10/11/math-combination/recursion-solve/"/>
    <url>/2020/10/11/math-combination/recursion-solve/</url>
    
    <content type="html"><![CDATA[<h2 id="求和因子法">求和因子法</h2><p>对于形如 <span class="math display">\[a_n T_n = b_n T_{n-1} + c_n\]</span>，我们可以求出其通项公式，下面我们来推导这一公式。</p><p>我们考虑通过变量替换的方式将 <span class="math display">\[T_n\]</span> 前的 <span class="math display">\[a_n\]</span> 和 <span class="math display">\[b_n\]</span> 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 <span class="math display">\[b_n T_{n-1}\]</span> 能够通过 <span class="math display">\[a_n T_n\]</span> 表示出来（该表达式通常被称为求和因子）。设该表达式为 <span class="math display">\[s_n\]</span>，两边同乘以 <span class="math display">\[s_n\]</span>，即为 <span class="math display">\[s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n\]</span></p><a id="more"></a><p>注意到等式左边均为第 <span class="math inline">\(n\)</span> 项，而右边为 <span class="math display">\[T_{n-1}\]</span>，故考虑将右边第一项变为 <span class="math display">\[s_{n-1}a_{n-1}T_{n-1}\]</span>。要做到这一点，就是要让 <span class="math display">\[s_n b_n = s_{n-1} a_{n-1}\]</span>，也即 <span class="math display">\[s_n = s_{n-1} \cdot \frac{a_{n-1}}{b_n}\]</span>。做递推，得到 <span class="math display">\[s_n = \frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2} \cdot s_1\]</span>。故仅需取 <span class="math display">\[s_n = \frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2}\]</span> 或该式的常数倍即可。</p><p>现在，我们仅需令 <span class="math display">\[P_n = s_n a_n T_n\]</span>，即可将原式化简为 <span class="math display">\[P_n = P_{n-1} + s_n c_n\]</span></p><p>故 <span class="math display">\[P_n = P_0 + \sum_\limits{k=1}^n s_k c_k\]</span></p><p>故 <span class="math display">\[s_n a_n T_n = s_0 a_0 T_0 + \sum_\limits{k=1}^n s_kc_k = s_1b_1T_0 + \sum_\limits{k=1}^n s_kc_k\]</span></p><p>故 <span class="math display">\[T_n = \frac{1}{s_n a_n} \left( s_1b_1T_0 + \sum_\limits{k=1}^n s_kc_k \right)\]</span></p><blockquote><p>Example:</p><p>已知Hanoi问题满足以下递归表达式，试求出其通项公式 <span class="math display">\[\left\{\begin{aligned}&amp;T_0 = 0 \\&amp;T_n = 2T_{n-1} + 1\end{aligned}\right.\]</span> <strong>解：</strong> 由 <span class="math inline">\(a_n = 1, b_n = 2\)</span> 可知求和因子 <span class="math inline">\(s_n = \frac{1}{2^{n-1}}\)</span>。由于 <span class="math inline">\(s_n\)</span> 乘以常数倍不影响其效果 ，故为了方便起见令 <span class="math inline">\(s_n = \frac{1}{2^n}\)</span></p><p>两边同乘以 <span class="math display">\[s_n = \frac{1}{2^n}\]</span>，得到 <span class="math display">\[\frac{T_n}{2^n} = \frac{T_{n-1}}{2^{n-1}} + \frac{1}{2^n}\]</span></p><p>令<span class="math inline">\(P_n = \frac{T_n}{2^n}\)</span>，则 <span class="math display">\[\left\{\begin{aligned}&amp;P_n = P_{n-1} + \frac{1}{2^n} \\&amp;P_0 = 0\end{aligned}\right.\]</span> 故 <span class="math display">\[P_n = \sum_\limits{k=1}^n \frac{1}{2^k} = 1-\left(\frac{1}{2}\right)^n\]</span>，即 <span class="math display">\[\frac{T_n}{2^n} = 1-\left(\frac{1}{2}\right)^n\]</span></p><p>故 <span class="math display">\[T_n = 2^n - 1\]</span></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>Sequence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序时间复杂度分析</title>
    <link href="/2020/10/10/algorithm/theory/qsort-analyze/"/>
    <url>/2020/10/10/algorithm/theory/qsort-analyze/</url>
    
    <content type="html"><![CDATA[<h2 id="随机化快速排序">随机化快速排序</h2><p>随机化快速排序在快速排序的基础上，通过随机数选择一个数作为pivot，使得没有特定的输入数据可以使得该算法达到最坏情况。</p><p>下面我们来分析其平均时间复杂度。</p><a id="more"></a><p>设 <span class="math display">\[X_k\]</span> 为一个随机变量，使得对任意 <span class="math display">\[k=0,1,...,n-1\]</span>，有 <span class="math display">\[X_k = \left\{\begin{aligned}1 &amp;, &amp;if \ Partition \ generates \ (k:n-k-1) \ split \\0 &amp;, &amp;otherwise\end{aligned}\right.\]</span> 若随机数生成每个数的概率相同，则 <span class="math display">\[\begin{aligned}E[X_k] &amp;= 0 \cdot \Pr \{X_k = 0\} + 1 \cdot \Pr \{X_k = 1\} \\&amp;=\Pr\{X_k = 1\} \\&amp;=\frac{1}{n}\end{aligned}\]</span> 设 <span class="math display">\[T(n)\]</span> 为一个代表总运行时间的随机变量（假设所有的情况均为独立的）</p><p>即 <span class="math display">\[T(n) = \left\{\begin{aligned}T(0) + T(n-1) + \Theta(n) &amp;, &amp;if \ Partition \ generates \ (0:n-1) \ split \\T(1) + T(n-2) + \Theta(n) &amp;, &amp;if \ Partition \ generates \ (1:n-2) \ split \\...... \\T(n-1) + T(0) + \Theta(n) &amp;, &amp;if \ Partition \ generates \ (n-1:0) \ split\end{aligned}\right.\]</span> 通过引入 <span class="math display">\[X_k\]</span>，我们可以把 <span class="math display">\[T(n)\]</span> 改写为一个和式 <span class="math display">\[T(n) = \sum_\limits{k=0}^{n-1} X_k \left( T(k) + T(n-k-1) + \Theta(n) \right)\]</span> 故 <span class="math display">\[\begin{aligned}E[T(n)] &amp;= E \left[\sum_\limits{k=0}^{n-1} X_k \left( T(k) + T(n-k-1) + \Theta(n) \right) \right] \\&amp;=\sum_\limits{k=0}^{n-1} E \left[ X_k \left( T(k) + T(n-k-1) + \Theta(n) \right) \right] \\&amp;=\sum_\limits{k=0}^{n-1} E \left[ X_k \right] \cdot E\left[ \left( T(k) + T(n-k-1) + \Theta(n)\right) \right] \\&amp;=\frac{1}{n} \sum_\limits{k=0}^{n-1} E[T(k)] + \frac{1}{n} \sum_\limits{k=0}^{n-1} E[T(n-k-1)] + \frac{1}{n} \sum_\limits{k=0}^{n-1} E[\Theta(n)] \\&amp;=\frac{2}{n} \sum_\limits{k=0}^{n-1} E[T(k)] + \Theta(n)\end{aligned}\]</span> 由此我们得到了一个关于 <span class="math display">\[E[T(n)]\]</span> 的递推式。下面我们使用<strong>第二数学归纳法</strong>证明：当 <span class="math display">\[n \geq 3\]</span> 时，存在 <span class="math display">\[a&gt;0\]</span>，使得 <span class="math display">\[E[T(n)] \leq an \lg n\]</span></p><p>为了方便起见，我们首先对原式进行适当变形 <span class="math display">\[\begin{aligned}E[T(n)] &amp;=\frac{2}{n} \sum_\limits{k=0}^{n-1} E[T(k)] + \Theta(n) \\&amp;=\frac{2}{n}E[T(0)] + \frac{2}{n}E[T(1)] + \frac{2}{n} \sum_\limits{k=2}^{n-1} E[T(k)] + \Theta(n) \\&amp;=\frac{2}{n} \sum_\limits{k=2}^{n-1} E[T(k)] + \Theta(n)\end{aligned}\]</span> 随后，我们需要一个引理</p><blockquote><p>Lemma: <span class="math display">\[\sum_\limits{k=2}^{n-1} k \lg k \leq \frac{1}{2}n^2 \lg n - \frac{1}{8} n^2\]</span> 证明：令 <span class="math display">\[f(x) = x \lg x\]</span></p><p>则 <span class="math display">\[f&#39;(x) = \lg k + \frac{1}{\ln 2}\]</span></p><p>故当 <span class="math display">\[x \geq 2\]</span> 时 <span class="math display">\[f(x)&gt;0\]</span> 且 <span class="math display">\[f(x)\]</span> 单调递增</p><p>因此 <span class="math display">\[\begin{aligned}\sum_\limits{k=2}^{n-1} k \lg k &amp;\leq \int_2^n x \lg x dx \\&amp;=\frac{1}{2} \int_2^n \lg x d(x^2) \\&amp;=\frac{1}{2} \left(\left[x^2 \lg x\right]\Big|_2^n - \int_2^n x^2 \cdot \frac{1}{x \ln 2} dx\right) \\&amp;=\frac{1}{2} \left( n^2 \lg n - 4 - \frac{1}{2 \ln 2} \cdot \left[x^2\right]\Big|_2^n\right) \\&amp;=\frac{1}{2}n^2 \lg n - \frac{1}{4 \ln 2}n^2 -2 + \frac{1}{\ln 2} \\&amp;\leq \frac{1}{2}n^2 \lg n -\frac{1}{4\ln2}n^2 \\&amp;\leq \frac{1}{2}n^2 \lg n - \frac{1}{8}n^2\end{aligned}\]</span></p></blockquote><p>现在就可以对 <span class="math display">\[n\]</span> 进行归纳了</p><p>当 <span class="math display">\[n=3\]</span> 时，<span class="math display">\[E[T(3)]=\Theta(1)\]</span>，仅需取一足够大的 <span class="math display">\[a\]</span>，则结论显然成立</p><p>若对 <span class="math display">\[\forall k &lt; n\]</span>，存在 <span class="math display">\[a&gt;0\]</span> 使得 <span class="math display">\[E[T(n)] \leq ak \lg k\]</span> 成立</p><p>则 <span class="math display">\[\begin{aligned}E[T(n)] &amp;\leq \frac{2}{n} \sum_\limits{k=2}^{n-1} ak \lg k + \Theta(n) \\&amp;\leq \frac{2a}{n} \cdot \left( \frac{1}{2}n^2 \lg n - \frac{1}{8}n^2\right) + \Theta(n) \\&amp;=an \lg n - \frac{an}{4} + \Theta(n)\end{aligned}\]</span> 故仅需取一足够大的 <span class="math display">\[a\]</span> 使得 <span class="math display">\[\frac{an}{4}&gt; \Theta(n)\]</span>，即可使得 <span class="math display">\[E[T(n)] \leq an \lg n\]</span></p><p>因此 <span class="math display">\[E[T(n)] \leq an \lg n\]</span> 对 <span class="math display">\[\forall n \geq 3\]</span> 均成立</p><p>由此可知 <span class="math display">\[E[T(n)] = \mathcal{O}(n \lg n)\]</span></p><p>同理可得 <span class="math display">\[E[T(n)] = \Omega(n\lg n)\]</span></p><p>故 <span class="math display">\[E[T(n)] = \Theta(n \lg n)\]</span></p><p>事实上，原始的快速排序中Partition的操作次数为 <span class="math display">\[n+1\]</span> 次，故总运行时间的期望还可以进一步写成以下递推式 <span class="math display">\[\left\{\begin{aligned}&amp;E[T(0)] = 0 \\&amp;E[T(n)] = \frac{2}{n}\sum_\limits{k = 0}^{n-1} E[T(k)] + n+1 \ \ (n \geq 1)\end{aligned}\right.\]</span> 下面我们来尝试推导该递推式的封闭解</p><p>首先将原式化简为整式，得到 <span class="math display">\[n \cdot E[T(n)] = 2 \sum_\limits{k=0}^{n-1} E[T(k)] + n^2+n\]</span></p><p>注意到等式右边有一个连续的求和式（即从 <span class="math display">\[E[T(0)]\]</span> 到 <span class="math display">\[E[T(n-1)]\]</span> 中没有缺项），故考虑做<strong>差项</strong>消去该求和式。 <span class="math display">\[\left\{\begin{aligned}&amp;n \cdot E[T(n)] = 2 \sum_\limits{k=0}^{n-1} E[T(k)] + n^2+n \\&amp;(n-1) \cdot E[T(n-1)] = 2 \sum_\limits{k=0}^{n-2} E[T(k)] + (n-1)^2+(n-1)\end{aligned}\right.\]</span> 两式相减，得到 <span class="math inline">\(n \cdot E[T(n)] - (n-1) \cdot E[T(n-1)] = 2n + 2 \cdot E[T(n-1)]\)</span></p><p>化简得到 <span class="math display">\[n \cdot E[T(n)] = (n+1) \cdot E[T(n-1)] + 2n\]</span></p><p>接下来我们考虑将 <span class="math display">\[E[T(n)]\]</span> 和 <span class="math display">\[E[T(n-1)]\]</span> 前的系数消去以找出通项公式。</p><p>两边同时乘以 <span class="math display">\[\frac{2}{n(n+1)}\]</span> ，得到 <span class="math display">\[\frac{2}{n+1} \cdot E[T(n)] = \frac{2}{n} \cdot E[T(n-1)] + \frac{4}{n+1}\]</span></p><p>令 <span class="math display">\[S_n = \frac{2}{n+1} \cdot E[T(n)]\]</span>，于是原递归式化简为 <span class="math display">\[\left\{\begin{aligned}&amp; S_0 = 0 \\&amp; S_n = S_{n-1} + \frac{4}{n+1}\end{aligned}\right.\]</span> 我们可以快速写出该递归式的通项公式 <span class="math display">\[S_n = 4\sum_\limits{k=2}^{n+1} \frac{1}{k}\]</span></p><p>即 <span class="math inline">\(\frac{2}{n+1} \cdot E[T(n)] = 4\sum_\limits{k=2}^{n+1} \frac{1}{k}\)</span></p><p>化简即得 <span class="math inline">\(E[T(n)] = 2(n+1)\sum_\limits{k=2}^{n+1} \frac{1}{k}\)</span></p><p>引入调和级数符号 <span class="math inline">\(H_n = 1 + \frac{1}{2} + \frac{1}{3} + ... + \frac{1}{n}\)</span></p><p>注意到 <span class="math inline">\(\sum_\limits{k=2}^{n+1} \frac{1}{k} = H_n - 1 + \frac{1}{n+1}\)</span></p><p>故我们得到了原递推式的封闭解 <span class="math display">\[E[T(n)] = 2(n+1)H_n - 2n\]</span></p><p>又由 <span class="math inline">\(H_n = \ln n + \gamma + \mathcal{O}\left(\frac{1}{n} \right)\)</span></p><p>故可得 <span class="math display">\[\begin{aligned}E[T(n)] &amp;= 2(n+1)\left(\ln n + \gamma + \mathcal{O} \left(\frac{1}{n} \right)\right) - 2n \\&amp;= 2n \ln n + 2(\gamma - 1)n + 2\ln n + 2\gamma + \mathcal{O}(1) + \mathcal{O}\left(\frac{1}{n}\right) \\&amp;= \Theta \left( n \ln n \right) \\&amp;= \Theta \left( n \lg n\right)\end{aligned}\]</span> 由此我们得到了快速排序的平均时间复杂度为 <span class="math inline">\(\Theta (n \lg n)\)</span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优先队列</title>
    <link href="/2020/10/09/algorithm/course-exp/algorithm-exp3/"/>
    <url>/2020/10/09/algorithm/course-exp/algorithm-exp3/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><ol type="1"><li>利用堆实现优先级队列；</li><li>按照顺序插入<span class="math display">\[1,3,5,7,9,2,4,6,8,10,11,13,15,12,14\]</span>，构建优先级队列，打印出整个数组的内容；</li><li>按照顺序插入<span class="math display">\[9,7,10,12,5,4,2,1,15,14,3,7,8,6,11,13\]</span>，构建优先级队列，打印出整个数组的内容，并且体会不同输入顺序的情况之下数组内元素排序的差异；</li><li>随机生成 <span class="math display">\[1000, 10000, 100000, 1000000\]</span> 个数，分别构建优先级队列，画图描述不同情况下的运行时间差异。</li></ol><a id="more"></a><h2 id="实现代码">实现代码</h2><h3 id="随机数生成器">随机数生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">int</span> n;<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) fout&lt;&lt;rand()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    fout.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉堆优先队列">二叉堆优先队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1000005</span>], cur;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">siftUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> parent, tmp;<br>    parent = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(index != <span class="hljs-number">0</span> &amp;&amp; a[index] &gt; a[parent])&#123;<br>        tmp = a[parent];<br>        a[parent] = a[index];<br>        a[index] = tmp;<br>        index = parent;<br>        parent = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> lchild, rchild, tmp, tcur;<br>    lchild = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    rchild = (index + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(rchild &lt;= cur &amp;&amp; (a[index] &lt; a[lchild] || a[index] &lt; a[rchild]))&#123;<br>        tcur = a[lchild] &gt; a[rchild] ? lchild : rchild;<br>        tmp = a[tcur];<br>        a[tcur] = a[index];<br>        a[index] = tmp;<br>        index = tcur;<br>        lchild = tcur * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        rchild = (tcur + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(lchild &lt;= cur &amp;&amp; a[index] &lt; a[lchild])&#123;<br>        tmp = a[lchild];<br>        a[lchild] = a[index];<br>        a[index] = tmp;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>&#123;<br>    cur++;<br>    a[cur] = data;<br>    siftUp(cur);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">popMax</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> r = a[<span class="hljs-number">0</span>];<br>    a[<span class="hljs-number">0</span>] = a[cur];<br>    cur--;<br>    siftDown(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> tcur;<br>    tcur = (cur - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">while</span>(tcur &gt;= <span class="hljs-number">0</span>)&#123;<br>        siftDown(tcur);<br>        tcur--;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        fin&gt;&gt;a[cur];<br>        cur++;<br>    &#125;<br>    cur--;<br>    start = clock();<br>    heapify();<br>    stop = clock();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur; i++) <span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Total time: &quot;</span>&lt;&lt;((<span class="hljs-keyword">double</span>) (stop - start)) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-built_in">endl</span>;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行效率">运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><h2 id="总结">总结</h2><p>对 <span class="math display">\[1,3,5,7,9,2,4,6,8,10,11,13,15,12,14\]</span> 构建优先级队列的结果为：<span class="math display">\[15,11,14,8,10,13,12,6,7,3,9,5,2,1\]</span></p><p>对 <span class="math display">\[9,7,10,12,5,4,2,1,15,14,3,7,8,6,11,13\]</span> 构建优先级队列的结果为：<span class="math display">\[15,14,11,13,9,8,10,7,12,5,3,7,4,6,2,1\]</span></p><p>若将顺序改为 <span class="math display">\[10,5,6,7,12,4,2,14,15,1,3,7,13,9,11,8\]</span>，则构建优先级队列的结果为：<span class="math display">\[15,14,13,10,12,7,11,8,7,1,3,6,4,9,2,5\]</span></p><p>经实测表明，随着数据规模的增大，运行时间逐步增加，但在数据规模为 <span class="math display">\[10^6\]</span> 以内时运行时间均小于0.1秒，这与堆实现优先级队列的插入时间复杂度为 <span class="math display">\[\mathcal{O}(\lg n)\]</span> 基本相符。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解计算机系统》笔记整理（一）</title>
    <link href="/2020/10/07/computer-system/csapp-01/"/>
    <url>/2020/10/07/computer-system/csapp-01/</url>
    
    <content type="html"><![CDATA[<h1 id="chapter-2信息的表示和处理">Chapter 2：信息的表示和处理</h1><h2 id="基本概念">基本概念</h2><h3 id="进制转换">进制转换</h3><h4 id="进位计数制">进位计数制</h4><p><strong>定义：</strong>设一个 <span class="math inline">\(m\)</span> 进制下<span class="math inline">\(w\)</span> 位的位向量表示为 <span class="math display">\[[a_{w-1}, a_{w-2}, ..., a_0]\]</span>，则其表示的数为 <span class="math inline">\(\sum_\limits{i=0}^{w-1} a_im^i\)</span></p><h4 id="m-进制-rightarrow-十进制"><span class="math inline">\(m\)</span> 进制 <span class="math inline">\(\rightarrow\)</span> 十进制</h4><blockquote><p>设一个 <span class="math inline">\(w\)</span> 位 <span class="math inline">\(m\)</span> 进制整数的位相量表示为 <span class="math display">\[\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ]\]</span> ，定义函数 <span class="math inline">\(M2D(\vec{x}) = \sum_\limits{i=0}^{w-1} x_i m^i\)</span>，则其对应的十进制数 <span class="math inline">\(n = M2D(\vec{x})\)</span></p></blockquote><a id="more"></a><p><strong>证明：</strong>由进位计数制的定义可直接得到结论</p><blockquote><p>Example:</p><p>将 <span class="math inline">\(3\)</span> 进制数 <span class="math inline">\(12011\)</span> 转为十进制数</p><p>解： 令 <span class="math inline">\(\vec{x} = [1,2,0,1,1], m = 3\)</span> <span class="math display">\[\begin{align}\therefore n = M2D(\vec{x}) &amp;= 1 \cdot 3^4 + 2 \cdot 3^3 + 1 \cdot 3^1 +1 \cdot 3^0 \\ &amp;= 81+54+3+1 \\ &amp;= 139 \end{align}\]</span> 故 <span class="math display">\[12011_3 = 139_{10}\]</span></p></blockquote><h4 id="十进制-rightarrow-m-进制">十进制 <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(m\)</span> 进制</h4><blockquote><p>设一个十进制整数为 <span class="math inline">\(n\)</span>，定义序列 <span class="math display">\[\begin{align}&amp;p_0 = \lfloor \frac{n}{m} \rfloor, \ r_0 = n \ \ mod \ \ m \\&amp;p_1 = \lfloor \frac{p_0}{m}\rfloor, \ r_1 = p_0 \ \ mod \ \ m \\&amp;... \\&amp;p_{s-1} = \lfloor \frac{p_{s-2}}{m}\rfloor = 0, \ r_{s-1} = p_{s-2} \ \ mod \ \ m \\\end{align}\]</span> 则其对应的 <span class="math inline">\(m\)</span> 进制数的位向量表示为 <span class="math display">\[\vec{x} = [r_{s-1}, r_{s-2}, ..., r_0]\]</span></p></blockquote><p><strong>证明：</strong>设 <span class="math inline">\(n\)</span> 在 <span class="math inline">\(m\)</span> 进制下的位相量表示为 <span class="math display">\[[r_{s-1}, r_{s-2}, ..., r_0]\]</span></p><p>则由定义可知，<span class="math display">\[n = r_{s-1} \cdot m^{s-1} + r_{s-2} \cdot m^{s-2} + ...+ r_0\]</span></p><p>故 <span class="math display">\[n = m \cdot \left( r_{s-1} \cdot m^{s-2} + r_{s-2} \cdot m^{s-3} + ... + r_1 \right) + r_0\]</span></p><p>故 <span class="math inline">\(r_0 = n \ \ mod \ \ m\)</span></p><p>又由 <span class="math display">\[\begin{align}p_0 = \lfloor \frac{n}{m} \rfloor &amp;= r_{s-1} \cdot m^{s-2} + r_{s-2} \cdot m^{s-3} + ... + r_1 \\&amp;= m \cdot \left( r_{s-1} \cdot m^{s-3} + r_{s-2} \cdot m^{s-4} + ... + r_2 \right) + r_1\end{align}\]</span> 故 <span class="math inline">\(r_1 = p_0 \ \ mod \ \ m\)</span></p><p>以此类推，<span class="math display">\[r_{i} = p_{i-1} \ \ mod \ \ m \ (i=s-2, ..., 1)\]</span></p><p>故结论成立</p><blockquote><p>Example:</p><p>将十进制数 <span class="math inline">\(508\)</span> 转为八进制数</p><p>解： <span class="math display">\[\begin{align}508 &amp;= 63 * 8 + 4 \\63 &amp;= 7 * 8 + 7 \\7 &amp;= 0 * 8 + 7\end{align}\]</span> 故 <span class="math inline">\(508_{10} = 774_8\)</span></p></blockquote><h3 id="信息的存储">信息的存储</h3><h4 id="字长word-size">字长（Word Size）</h4><p>在计算机中，<strong>字（Word）</strong>是用来表示一次性处理数据的固定长度。字的位数称为<strong>字长（Word Size）</strong>。字长是计算机系统中的一个重要指标，字长的大小决定了<strong>虚拟地址空间的最大大小</strong>。</p><p>对于一个字长为 <span class="math inline">\(w\)</span> 的机器来说，其虚拟地址的范围为 <span class="math inline">\(0\)</span> ～ <span class="math inline">\(2^w-1\)</span>，即可以存储 <span class="math inline">\(2^w\)</span> 个字节</p><blockquote><p>Example:</p><p>字长为32的机器的虚拟地址范围为 <span class="math inline">\(0\)</span> ～ <span class="math inline">\(2^{32}-1\)</span>，可以存储 <span class="math inline">\(2^{32}\)</span> 个字节</p></blockquote><h4 id="小端序little-endian和大端序big-endian">小端序（Little Endian）和大端序（Big Endian）</h4><p>超过一个字节的数据在计算机中有两种排列顺序：小端序（Little Endian）和大端序（Big Endian）。</p><p>小端序：将较低的有效字节放在<strong>较小</strong>的内存地址中。</p><p>大端序：将较低的有效字节放在<strong>较大</strong>的内存地址中。</p><blockquote><p>Example:</p><p>原始数据：12 34 56 78</p><p>小端序存储：12 34 56 78</p><p>大端序存储：78 56 34 12</p></blockquote><p><strong>注：</strong>使用ASCII码存储的字符数据在任何系统上都能得到相同的结果，不受端序的影响。</p><h3 id="基本运算">基本运算</h3><h4 id="位级运算">位级运算</h4><p>计算机中有以下四种基本位级运算：<strong>按位与（&amp;）</strong>，<strong>按位或（|）</strong>，<strong>按位非（~）</strong>，<strong>按位异或（^）</strong>，其规则与布尔代数中的规则一致。</p><blockquote><p>Example:</p><p>101100 &amp; 100110 = 100100</p><p>101100 | 100110 = 101110</p><p>~101100 = 010011</p><p>101100 ^ 100110 = 001010</p></blockquote><h4 id="逻辑运算">逻辑运算</h4><p>计算机中提供了以下三种逻辑运算：<strong>且（&amp;&amp;）</strong>，<strong>或（||）</strong>，<strong>非（!）</strong>，其规则与命题逻辑中的规则一致。</p><p><strong>注：</strong>C语言中的逻辑运算有<strong>提早终止（Early Termination）</strong>的机制，即当两个表达式做逻辑运算时，若前一个表达式已经能确定最终结果，则不再计算后一个表达式。</p><blockquote><p>Example:</p><p>(1+1=2) &amp; (3=3) = 1</p><p>(1-1=0) || (1=2) = 1</p><p>!(2*5=10) = 0</p><p>!0x3F = 0</p></blockquote><h4 id="位移运算">位移运算</h4><p>计算机中提供了三种位移操作：左移（&lt;&lt;），逻辑右移（&gt;&gt;），算术右移（&gt;&gt;）</p><p><span class="math inline">\(x\)</span> 左移 <span class="math inline">\(k\)</span> 位：将 <span class="math inline">\(x\)</span> 的最高 <span class="math inline">\(k\)</span> 位丢弃并在最低位后补充 <span class="math inline">\(k\)</span> 个零，相当于 <span class="math inline">\(x \cdot 2^k\)</span></p><p><span class="math inline">\(x\)</span> 逻辑右移 <span class="math inline">\(k\)</span> 位：将 <span class="math inline">\(x\)</span> 的最低 <span class="math inline">\(k\)</span> 位丢弃并在最高位前补充 <span class="math inline">\(k\)</span> 个零，相当于 <span class="math inline">\(\lfloor \frac{x}{2^k} \rfloor\)</span></p><p>算术右移 <span class="math inline">\(k\)</span> 位：将 <span class="math inline">\(x\)</span> 的最低 <span class="math inline">\(k\)</span> 位丢弃并在最高位前补充 <span class="math inline">\(k\)</span> 个最高位值</p><h3 id="整数的存储与运算">整数的存储与运算</h3><h4 id="无符号整数">无符号整数</h4><p>二进制数码不表示符号信息的整数称为无符号整数，其代码的数字与常规的进位计数制规则一致。即若定义 <span class="math display">\[B2U_w(\vec{x}) = \sum_\limits{i=0}^{w-1}x_i 2^i\]</span>，则一个 <span class="math inline">\(w\)</span> 位的二进制位相量 <span class="math inline">\(\vec{x}\)</span> 所对应的十进制数 <span class="math inline">\(n = B2U_w(\vec{x})\)</span></p><p>由定义可知，一个 <span class="math inline">\(w\)</span> 位的二进制位相量 <span class="math inline">\(\vec{x}\)</span> 可表示的整数范围为 <span class="math inline">\(0\)</span> ～ <span class="math inline">\(2^w-1\)</span></p><h4 id="有符号整数">有符号整数</h4><p>有符号整数是采用补码进行存储的整数。补码是对二进制的一种新的解读方式，其严格的定义如下：若定义 <span class="math display">\[B2T_w(\vec{x}) = -x_{w-1} 2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i\]</span>，则一个 <span class="math inline">\(w\)</span> 位的二进制位相量 <span class="math inline">\(\vec{x}\)</span> 所对应的十进制数 <span class="math inline">\(n = B2T_w(\vec{x})\)</span>。通俗来说，补码将原本 <span class="math inline">\(0\)</span> ～ <span class="math inline">\(2^w-1\)</span> 中 <span class="math inline">\(2^{w-1}\)</span> ～ <span class="math inline">\(2^{w} - 1\)</span> 的部分重新解读为负数，从而使得其可以表示负数。从取模的角度来看， 对于一个 <span class="math inline">\(0\)</span> ～ <span class="math inline">\(2^{w-1} - 1\)</span> 中的数 <span class="math inline">\(n\)</span> 和一个 <span class="math inline">\(2^{w-1}\)</span> ～ <span class="math inline">\(2^{w} - 1\)</span> 中的数 <span class="math inline">\(m\)</span>，<span class="math inline">\((n + m) \ \ mod \ \ 2^w = n - (2^w - m)\)</span>，故这样定义是合适的。且容易看出其与无符号整数间的转换关系为 <span class="math display">\[U2T(x) = \left\{\begin{aligned}&amp;x &amp;, &amp;0 \leq x \leq 2^{w-1} - 1 \\&amp;x - 2^w &amp;, &amp;2^{w-1} \leq x \leq 2^w - 1\end{aligned}\right.\]</span></p><p><span class="math display">\[T2U(x) = \left\{\begin{aligned}&amp;x &amp;, &amp; 0 \leq x \leq 2^{w-1}-1 \\&amp;x + 2^w &amp;, &amp; -2^{w-1} \leq x \leq -1\end{aligned}\right.\]</span></p><p><strong>证明：</strong>设二进制位向量 <span class="math inline">\(\vec{x}\)</span></p><p>当 <span class="math display">\[0 \leq B2U_w(\vec{x}) \leq 2^{w-1} - 1\]</span> 时</p><p><span class="math display">\[x_{w-1} = 0\]</span></p><p>此时 <span class="math display">\[B2T_w(\vec{x}) = \sum_\limits{i=0}^{w-2}x_i 2^i = B2U_w(\vec{x})\]</span></p><p>故 <span class="math display">\[U2T_w(x) = x\]</span></p><p>当 <span class="math display">\[2^{w-1} \leq x \leq 2^w - 1\]</span> 时</p><p><span class="math display">\[x_{w-1} = 1\]</span></p><p>此时 <span class="math display">\[\left\{\begin{aligned}B2T_w(\vec{x}) &amp;= -2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i \\B2U_w(\vec{x}) &amp;= 2^{w-1} + \sum_\limits{i=0}^{w-2}x_i 2^i\end{aligned}\right.\]</span></p><p>故 <span class="math display">\[B2T_w(\vec{x}) = B2U_w(\vec{x}) - 2^w\]</span></p><p>故 <span class="math display">\[U2T_w(\vec{x}) = x - 2^w\]</span></p><p><span class="math display">\[T2U(x)\]</span>的情况同理可证</p><p><strong>注：</strong>无符号或有符号整数仅为二进制解读为十进制时的不同解读方式，由于计算机在二进制层面进行运算，故计算机在进行底层运算时并不区分这两种解读方式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Lab实验记录</title>
    <link href="/2020/10/02/computer-system/csapp-datalab/"/>
    <url>/2020/10/02/computer-system/csapp-datalab/</url>
    
    <content type="html"><![CDATA[<p>Data Lab要求我们在有一系列运算限制的情况下实现某些运算操作，从而尽可能的开发位运算的作用。这个Lab中的绝大部分内容的技巧性都比较强，可以阅读<strong>《算法心得：高效算法的奥秘》</strong>一书作为参考。</p><a id="more"></a><h2 id="概述">概述</h2><p>在Lab中的<strong>bits.c</strong>文件内描述了一系列规则和我们需要实现的函数。具体来说，我们需要实现以下几个函数：</p><ul><li><strong>bitAnd</strong>：按位与</li><li><strong>getByte</strong>：从一个二进制整数中提取某个Byte（8位）</li><li><strong>logicalShift</strong>：逻辑右移</li><li><strong>bitCount</strong>：计算一个二进制整数中1的位数</li><li><strong>bang</strong>：逻辑取反</li><li><strong>tmin</strong>：最小的补码能表示的int型整数</li><li><strong>fitsBits</strong>：判断某个整数能否用n位补码表示</li><li><strong>divpwr2</strong>：计算 <span class="math display">\[\frac{x}{2^n}\]</span> 并向0取整</li><li><strong>negate</strong>：取相反数</li><li><strong>isPositive</strong>：判断某个数是否为正数</li><li><strong>isLessOrEqual</strong>：判断x是否小于等于y</li><li><strong>ilog2</strong>：计算 <span class="math display">\[\lfloor \log_2 x \rfloor\]</span></li><li><strong>float_neg</strong>：在float型表示下取相反数</li><li><strong>float_i2f</strong>：将int型表示转为float型表示</li><li><strong>float_twice</strong>：在float型表示下计算 <span class="math display">\[2*x\]</span></li></ul><p>对于上面这些函数，我们一般只能使用以下几种运算操作：</p><p><strong>逻辑取反（!），按位取反（~），按位与（&amp;），按位异或（^），按位或（|），加法（+），左移（&lt;&lt;），算数右移（&gt;&gt;）</strong></p><p>在此基础之上，其中某些函数还有进一步的限制要求：</p><ul><li>bitAnd：只允许使用<strong>按位取反（~）</strong>和<strong>按位或（|）</strong>操作</li><li>bang：不允许使用<strong>逻辑取反（!）</strong>操作</li><li>float_neg/float_i2f/float_twice：允许使用一切<strong>整数操作</strong>、<strong>逻辑与（&amp;&amp;）</strong>、<strong>逻辑或（||）</strong>、<strong>if语句</strong>及<strong>while语句</strong></li></ul><p>Lab中提供了两种工具来帮助我们检查实现是否正确：</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> ./dlc -e bits.c <span class="hljs-comment"># 检查函数实现中操作是否符合要求</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"> ./driver.pl <span class="hljs-comment"># 检查函数实现是否正确</span></span><br></code></pre></td></tr></table></figure><h2 id="具体实现">具体实现</h2><h3 id="bitand">bitAnd</h3><p>由<strong>De Morgan律</strong>可知 <span class="math display">\[\neg (P \land Q) = (\neg P) \lor (\neg Q)\]</span></p><p>故 <span class="math display">\[P \land Q = \neg ((\neg P) \lor (\neg Q))\]</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ~(~x | ~y);<br>&#125;<br></code></pre></td></tr></table></figure><p>一行代码搞定。</p><h3 id="getbyte">getByte</h3><p>采用掩码的思想，要提取某个Byte的数值并屏蔽其他位的值，可以将目标位移动到最小的8位并将其和0xFF做按位与运算。观察输入的参数，要提取 <span class="math display">\[x\]</span> 中的第 <span class="math display">\[n\]</span> 个Byte，就要将 <span class="math display">\[x\]</span> 向右移动 <span class="math display">\[8*n\]</span> 位。使用位运算操作的话，也即x&gt;&gt;(n&lt;&lt;3)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (x&gt;&gt;(n&lt;&lt;<span class="hljs-number">3</span>)) &amp; <span class="hljs-number">0xFF</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以一行搞定。</p><h3 id="logicalshift">logicalShift</h3><p>算数右移和逻辑右移的区别在于，算数右移会在高位填充最高位的值，而逻辑右移则不会，因此一个基本的思路就是使用算数右移后屏蔽掉高位的值，于是问题便转化为如何构造掩码。</p><p>我们的掩码要保证原数最高位之前均为0，最高位之后均为1。而利用算数右移会填充最高位的特性，我们可以将0x1移动到最高位，随后算数右移到目标位置，再取反即可满足要求，问题也迎刃而解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> (x&gt;&gt;n)&amp;(~((<span class="hljs-number">0x01</span>&lt;&lt;<span class="hljs-number">31</span>)&gt;&gt;n&lt;&lt;<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bitcount">bitCount</h3><p>利用位运算统计一个字中1的个数是一个技巧性十分强的算法。它的主要思想是<strong>分治法（Divide And Conquer）</strong>，将统计整个字中1的个数的问题转化为多个统计更小区间内1的个数的问题。具体来说，一个32位的整数中，我们可以将其划分为两个16位的区间，进而划分为4个8位的区间，再划分为8个4位的区间，最后划分为16个2位的区间，因此我们仅需要统计每两位中1的个数，再将结果逐步合并即可得到整个数中1的个数。</p><p>对于统计每2位中1的个数，我们同样可以采用掩码的思想，先对两位中第一位和0x1做与运算，再将整个数右移一位与0x1做与运算，将两个结果相加即可统计出这两位中1的个数。</p><p>此外，由于题目中规定不能使用超过0xFF的十六进制数，我们需要通过多步位移的方法来构造出我们想要的的掩码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> cnt;<br><span class="hljs-keyword">int</span> maskt1 = (<span class="hljs-number">0x55</span>) | (<span class="hljs-number">0x55</span>&lt;&lt;<span class="hljs-number">8</span>);<br><span class="hljs-keyword">int</span> maskt2 = (<span class="hljs-number">0x33</span>) | (<span class="hljs-number">0x33</span>&lt;&lt;<span class="hljs-number">8</span>);<br><span class="hljs-keyword">int</span> maskt3 = (<span class="hljs-number">0x0F</span>) | (<span class="hljs-number">0x0F</span>&lt;&lt;<span class="hljs-number">8</span>);<br><span class="hljs-keyword">int</span> mask1 = (maskt1) | (maskt1&lt;&lt;<span class="hljs-number">16</span>);<br><span class="hljs-keyword">int</span> mask2 = (maskt2) | (maskt2&lt;&lt;<span class="hljs-number">16</span>);<br><span class="hljs-keyword">int</span> mask3 = (maskt3) | (maskt3&lt;&lt;<span class="hljs-number">16</span>);<br><span class="hljs-keyword">int</span> mask4 = (<span class="hljs-number">0xFF</span>) | (<span class="hljs-number">0xFF</span>&lt;&lt;<span class="hljs-number">16</span>);<br><span class="hljs-keyword">int</span> mask5 = (<span class="hljs-number">0xFF</span>) | (<span class="hljs-number">0xFF</span>&lt;&lt;<span class="hljs-number">8</span>);<br>cnt = (x &amp; mask1) + ((x&gt;&gt;<span class="hljs-number">1</span>) &amp; mask1);<br>cnt = (cnt &amp; mask2) + ((cnt&gt;&gt;<span class="hljs-number">2</span>) &amp; mask2);<br>cnt = (cnt &amp; mask3) + ((cnt&gt;&gt;<span class="hljs-number">4</span>) &amp; mask3);<br>cnt = (cnt &amp; mask4) + ((cnt&gt;&gt;<span class="hljs-number">8</span>) &amp; mask4);<br>cnt = (cnt &amp; mask5) + ((cnt&gt;&gt;<span class="hljs-number">16</span>) &amp; mask5);<br><span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="negate">negate</h3><p>在补码表示中，对一个二进制表示下 <span class="math display">\[n\]</span> 位的整数 <span class="math display">\[x\]</span> 取相反数相当于做运算 <span class="math display">\[2^n-x\]</span>，而 <span class="math display">\[(2^n-1)-x\]</span> 相当于对x按位取反，因此总的位运算表示即为~x+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bang">bang</h3><p>逻辑取反操作即是要让0变为1，除0以外的任何数变为0，因此我们需要找到一个把0和其他数分开的位运算特性。利用补码表示中负数的最高位始终为1的特性，我们可以发现让一个数和它在补码下的相反数做按位或运算时，如果这个数不为0，那么它的最高位始终为1，而由于0的补码还是0，因此最高位为0。于是利用上一题的结论，我们就能得到最终的运算操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> ((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tmin">tmin</h3><p>在模的剩余系下，最靠近中间的数即为离边界距离最远的数。利用这一特性可知补码表示下最小的负数最高位为1，其余全为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0x1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fitsbits">fitsBits</h3><p>如果一个数能用n为补码表示，那么取它的后n位做符号扩展到原来的长度后值应与原来一样。利用逻辑右移的特性，我们只需要将x与x&lt;&lt;(32 - n)&gt;&gt;(32 - n)相比较即可。利用位运算取相反数的结论，以及异或运算的性质 <span class="math display">\[x \oplus x = 0\]</span>，即可得到最终的运算操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> shift = <span class="hljs-number">32</span> + ~n + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> !(x^((x&lt;&lt;shift)&gt;&gt;shift));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="divpwr2">divpwr2</h3><p>要计算 <span class="math display">\[\frac{x}{2^n}\]</span> 并向0取整，因此我们需要分类讨论。当 <span class="math display">\[x \geq 0\]</span> 时，这一操作相当于x&gt;&gt;n；而当 <span class="math display">\[x&lt;0\]</span> 时，若直接对原数右移n位，相当于 <span class="math display">\[\lfloor \frac{x}{2^n} \rfloor\]</span>，并不满足向0取整的要求。而对于整数，有如下定理成立：</p><blockquote><p>对于整数 <span class="math display">\[x\]</span> 和 <span class="math display">\[y(y&gt;0)\]</span>，有 <span class="math display">\[\lceil \frac{x}{y} \rceil = \lfloor \frac{x+y-1}{y} \rfloor\]</span></p></blockquote><p>由此可知对于负数，我们只需将其加上一个偏置 <span class="math display">\[2^n -1\]</span>，即可将结果变为向上取整。因此当 <span class="math display">\[x&lt;0\]</span> 时的操作为 <span class="math display">\[(x+(1&lt;&lt;n)-1)&gt;&gt;n\]</span>。</p><p>现在我们要通过位运算将这两种情况整合到一起。通过观察可以发现，我们只需要让某个运算在 <span class="math display">\[x \geq 0\]</span> 时的结果为0，在 <span class="math display">\[x &lt; 0\]</span> 时的结果为(1&lt;&lt;n)-1即可。同样的，我们可以使用掩码的思想来做到这一点。结合补码的性质及算数右移的性质，我们可以发现只需要将x右移31位即可得到掩码。由此最终的运算操作也迎刃而解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> tn = ~((~<span class="hljs-number">0</span>)&lt;&lt;n);<br>    <span class="hljs-keyword">int</span> tx = (~((x&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x01</span>)) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> (x + (tx &amp; tn)) &gt;&gt; n;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ispositive">isPositive</h3><p>根据题意，我们要让大于0的数运算结果等于1，0和小于0的数运算结果等于0。根据补码的性质，对于除0以外的其他数，我们只需判断最高位是否为1即可；而对于0，我们可以将其单独讨论。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> tx = (x&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x01</span>;<br><span class="hljs-keyword">return</span> !(tx | !x);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="islessorequal">isLessOrEqual</h3><p>当两数异号时，如果直接相减可能会导致结果溢出，但此时我们仅需判断其中一个数的正负即可得知结果，因此无需做减法运算；而当两个数同号时，可以保证相减不会溢出，因此我们只需相减判断符号即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> negx = ~x + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> addx = negx + y;<br>  <span class="hljs-keyword">int</span> sign = addx&gt;&gt;<span class="hljs-number">31</span>&amp;<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>  <span class="hljs-keyword">int</span> xleft = x &amp; left;<br>  <span class="hljs-keyword">int</span> yleft = y &amp; left;<br>  <span class="hljs-keyword">int</span> <span class="hljs-keyword">xor</span> = xleft ^ yleft;<br>  <span class="hljs-keyword">xor</span> = (<span class="hljs-keyword">xor</span> &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> ((!<span class="hljs-keyword">xor</span>)&amp;(!sign))|(<span class="hljs-keyword">xor</span>&amp;(xleft&gt;&gt;<span class="hljs-number">31</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ilog2">ilog2</h3><p>根据二进制的性质，我们只需要找到最高1的位置即可。仿照前面统计1的个数的思想，我们可以使用二分法来解决这一问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> t1, t2, t3;<br>t3 = x;<br>t2 = (!!(t3&gt;&gt;<span class="hljs-number">16</span>))&lt;&lt;<span class="hljs-number">4</span>;<br>t3 = t3&gt;&gt;t2;<br>t1 = (!!(t3&gt;&gt;<span class="hljs-number">8</span>))&lt;&lt;<span class="hljs-number">3</span>;<br>t3 = t3&gt;&gt;t1;<br>t2 = t2 | t1;<br>t1 = (!!(t3&gt;&gt;<span class="hljs-number">4</span>))&lt;&lt;<span class="hljs-number">2</span>;<br>t3 = t3&gt;&gt;t1;<br>t2 = t2 | t1;<br>t1 = (!!(t3&gt;&gt;<span class="hljs-number">2</span>))&lt;&lt;<span class="hljs-number">1</span>;<br>t3 = t3&gt;&gt;t1;<br>t2 = t2 | t1;<br><span class="hljs-keyword">return</span> (t2 | (t3&gt;&gt;<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="float_neg">float_neg</h3><p>在IEEE标准下，float型的格式为1位符号位，8位指数位和23位尾数位。因此我们首先要判断输入的数能否表示为一个float型小数。具体的，我们只需要将其符号位去除（左移），随后将其与0xFF000000比较即可。若大于这个数，则表明其不能表示为float型小数；若小于等于这个数，只需要改变其符号位即可得到结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> x = <span class="hljs-number">0x80000000</span>;<br><span class="hljs-keyword">unsigned</span> c = <span class="hljs-number">0xFF000000</span>;<br><span class="hljs-keyword">unsigned</span> tuf = uf&lt;&lt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>((c &amp; tuf) == c)&#123;<br><span class="hljs-keyword">if</span>(tuf != c) <span class="hljs-keyword">return</span> uf;<br>&#125;<br><span class="hljs-keyword">return</span> uf ^ x;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="float_i2f">float_i2f</h3><p>根据IEEE标准中float型的规则，我们需要先计算出符号尾及指数位的数值。随后，我们仅需利用位移操作将符号位、指数位、尾数位移动到相应的位置，再根据舍入的规则做一次微调即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> ax, sign, flag, tmp, shift, cur;<br>ax = x;<br>sign = x &amp; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>);<br><span class="hljs-keyword">if</span>(sign) ax = -x;<br>shift = ax;<br><span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>cur = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>tmp = shift;<br>shift = shift&lt;&lt;<span class="hljs-number">1</span>;<br>cur++;<br><span class="hljs-keyword">if</span>(tmp &amp; <span class="hljs-number">0x80000000</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>((shift &amp; <span class="hljs-number">0x01FF</span>) &gt; <span class="hljs-number">0x0100</span>) flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((shift &amp; <span class="hljs-number">0x03FF</span>) == <span class="hljs-number">0x0300</span>) flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> flag = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> sign + ((<span class="hljs-number">159</span> - cur)&lt;&lt;<span class="hljs-number">23</span>) + (shift&gt;&gt;<span class="hljs-number">9</span>) + flag;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="float_twice">float_twice</h3><p>在二进制科学技术法下，对某个数x乘以2就相对于将其阶数加一。因此若原数阶码不为0且不为255，则直接将阶码加一即可。若阶码等于0，表明其为非规范化数，因此直接将尾数位左移一位即可。由于非规范化数与规范化数之间有一个平滑过渡关系，因此即使左移一位后尾数位的最高位移动至了阶码位，该操作仍然是合法的。当原数阶码为255时，表明其为 <span class="math display">\[\infty\]</span> 或 <span class="math display">\[NaN\]</span>，不能进行算术运算，直接返回即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((uf &amp; <span class="hljs-number">0x7F800000</span>) == <span class="hljs-number">0</span>)<br>uf = ((uf &amp; <span class="hljs-number">0x007FFFFF</span>) &lt;&lt; <span class="hljs-number">1</span>) | (uf &amp; <span class="hljs-number">0x80000000</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((uf &amp; <span class="hljs-number">0x7F800000</span>) != <span class="hljs-number">0x7F800000</span>)<br>uf = uf + <span class="hljs-number">0x800000</span>;<br><span class="hljs-keyword">return</span> uf;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Computer-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strassen矩阵乘法</title>
    <link href="/2020/09/25/algorithm/course-exp/algorithm-exp2/"/>
    <url>/2020/09/25/algorithm/course-exp/algorithm-exp2/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><ol type="1"><li>设计一个随机数矩阵生成器，输入参数包括 <span class="math display">\[N, s, t\]</span>；可随机生成一个大小为 <span class="math display">\[N \times N\]</span>、数值范围在 <span class="math display">\[[s, t]\]</span> 之间的矩阵。</li><li>编程实现普通的矩阵乘法；</li><li>编程实现<strong>Strassen’s Algorithm</strong>；</li><li>在不同数据规模情况下（数据规模 <span class="math display">\[N=2^4, 2^8, 2^9, 2^{10}, 2^{11}\]</span>）下，两种算法的运行时间各是多少；</li><li>修改<strong>Strassen’s Algorithm</strong>，使之适应矩阵规模 <span class="math display">\[N\]</span> 不是 <span class="math display">\[2\]</span> 的幂的情况；</li><li>改进后的算法与<strong>2</strong>中的算法在相同数据规模下进行比较。</li></ol><a id="more"></a><h2 id="实现代码">实现代码</h2><p><strong>（给后来者的一些Note：请大家尽可能用相对高级的语法特性实现这一算法（如STL中的vector结构），不要像我这样用原始指针重复造轮子orz！！！）</strong></p><h3 id="矩阵生成器">矩阵生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> n, s, t;  <br>    srand(time(<span class="hljs-number">0</span>));  <br>    <span class="hljs-function">ofstream <span class="hljs-title">fout1</span><span class="hljs-params">(<span class="hljs-string">&quot;data1.txt&quot;</span>)</span></span>;  <br>    <span class="hljs-function">ofstream <span class="hljs-title">fout2</span><span class="hljs-params">(<span class="hljs-string">&quot;data2.txt&quot;</span>)</span></span>;  <br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;t;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;  <br>            fout1 &lt;&lt; s + rand() % (t - s)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;  <br>            fout2 &lt;&lt; s + rand() % (t - s)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;  <br>        &#125;  <br>        fout1&lt;&lt;<span class="hljs-built_in">endl</span>;  <br>        fout2&lt;&lt;<span class="hljs-built_in">endl</span>;  <br>    &#125;  <br>    fout1.close();  <br>    fout2.close();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="朴素矩阵乘法">朴素矩阵乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;  </span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  <br><span class="hljs-keyword">int</span> m1[<span class="hljs-number">2048</span>][<span class="hljs-number">2048</span>], m2[<span class="hljs-number">2048</span>][<span class="hljs-number">2048</span>], tm1[<span class="hljs-number">2048</span> * <span class="hljs-number">2048</span>], tm2[<span class="hljs-number">2048</span> * <span class="hljs-number">2048</span>];  <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    <span class="hljs-keyword">int</span> cnt, n, tsum;  <br>    <span class="hljs-function">ifstream <span class="hljs-title">fin1</span><span class="hljs-params">(<span class="hljs-string">&quot;data1.txt&quot;</span>)</span></span>;  <br>    <span class="hljs-function">ifstream <span class="hljs-title">fin2</span><span class="hljs-params">(<span class="hljs-string">&quot;data2.txt&quot;</span>)</span></span>;  <br>    <span class="hljs-keyword">while</span> (!fin1.eof())&#123;  <br>        fin1&gt;&gt;tm1[cnt];  <br>        fin2&gt;&gt;tm2[cnt];  <br>        cnt++;  <br>    &#125;  <br>    cnt--;  <br>    n = <span class="hljs-built_in">sqrt</span>(cnt);  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;  <br>            m1[i][j] = tm1[i * n + j];  <br>            m2[i][j] = tm2[i * n + j];  <br>        &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;  <br>            tsum = <span class="hljs-number">0</span>;  <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)&#123;  <br>                tsum += m1[i][k] * m2[k][j];  <br>            &#125;  <br>            <span class="hljs-built_in">cout</span>&lt;&lt;tsum&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;  <br>        &#125;  <br>        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;  <br>    &#125;  <br>    fin1.close();  <br>    fin2.close();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="strassen矩阵乘法">Strassen矩阵乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span> &#123;</span><br><span class="hljs-keyword">int</span> row, column;<br><span class="hljs-keyword">int</span>** m;<br><br>Matrix(<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;<br>row = r;<br>column = c;<br>m = (<span class="hljs-keyword">int</span>**) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*r);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++)<br>m[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * c);<br>&#125;<br><br>Matrix(<span class="hljs-keyword">const</span> Matrix&amp; mat) &#123;<br>row = mat.row;<br>column = mat.column;<br>m = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * mat.row);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat.row; i++)<br>m[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * mat.column);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; j++)<br>m[i][j] = mat.m[i][j];<br>&#125;<br><br>Matrix&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> Matrix&amp; mat) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;mat) &#123;<br>row = mat.row;<br>column = mat.column;<br>m = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * mat.row);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat.row; i++)<br>m[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * mat.column);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; j++)<br>m[i][j] = mat.m[i][j];<br>&#125;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>~Matrix() &#123;<br><span class="hljs-keyword">if</span> (m != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br><span class="hljs-keyword">delete</span>[] m[i];<br>&#125;<br><span class="hljs-keyword">delete</span>[] m;<br>&#125;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-keyword">int</span> tm1[<span class="hljs-number">2048</span> * <span class="hljs-number">2048</span>], tm2[<span class="hljs-number">2048</span> * <span class="hljs-number">2048</span>], cntp;<br><br><span class="hljs-function">Matrix <span class="hljs-title">matAdd</span><span class="hljs-params">(Matrix* matA, Matrix* matB)</span> </span>&#123;<br>Matrix matR = Matrix((*matA).row, (*matA).column);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (*matA).row; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (*matA).column; j++) &#123;<br>matR.m[i][j] = (*matA).m[i][j] + (*matB).m[i][j];<br>&#125;<br><span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matSub</span><span class="hljs-params">(Matrix* matA, Matrix* matB)</span> </span>&#123;<br>Matrix matR = Matrix((*matA).row, (*matA).column);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (*matA).row; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (*matA).column; j++) &#123;<br>matR.m[i][j] = (*matA).m[i][j] - (*matB).m[i][j];<br>&#125;<br><span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matSplit</span><span class="hljs-params">(Matrix mat, <span class="hljs-keyword">int</span> rowStart, <span class="hljs-keyword">int</span> columnStart, <span class="hljs-keyword">int</span> rowEnd, <span class="hljs-keyword">int</span> columnEnd)</span> </span>&#123;<br>Matrix matR = Matrix(rowEnd - rowStart + <span class="hljs-number">1</span>, columnEnd - columnStart + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= rowEnd - rowStart; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= columnEnd - columnStart; j++) &#123;<br>matR.m[i][j] = mat.m[rowStart + i][columnStart + j];<br>&#125;<br><span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matCombine</span><span class="hljs-params">(Matrix mat1, Matrix mat2, Matrix mat3, Matrix mat4)</span> </span>&#123;<br>Matrix matR = Matrix(mat1.row + mat3.row, mat1.column + mat2.column);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat1.row; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat1.column; j++)<br>matR.m[i][j] = mat1.m[i][j];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat2.row; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat2.column; j++)<br>matR.m[i][mat1.column + j] = mat2.m[i][j];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat3.row; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat3.column; j++)<br>matR.m[mat1.row + i][j] = mat3.m[i][j];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat4.row; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat4.column; j++)<br>matR.m[mat1.row + i][mat1.column + j] = mat4.m[i][j];<br><span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matProduct</span><span class="hljs-params">(Matrix* matA, Matrix* matB)</span> </span>&#123;<br><span class="hljs-keyword">if</span> ((*matA).row == <span class="hljs-number">1</span> &amp;&amp; (*matA).column == <span class="hljs-number">1</span> &amp;&amp; (*matB).row == <span class="hljs-number">1</span> &amp;&amp; (*matB).column == <span class="hljs-number">1</span>) &#123;<br>Matrix matR = Matrix(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>matR.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (*matA).m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * (*matB).m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-keyword">int</span> midR = (*matA).row / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> midC = (*matA).column / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>Matrix a11 = matSplit((*matA), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, midR, midC);<br>Matrix a12 = matSplit((*matA), <span class="hljs-number">0</span>, midC + <span class="hljs-number">1</span>, midR, (*matA).column - <span class="hljs-number">1</span>);<br>Matrix a21 = matSplit((*matA), midR + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (*matA).row - <span class="hljs-number">1</span>, midC);<br>Matrix a22 = matSplit((*matA), midR + <span class="hljs-number">1</span>, midC + <span class="hljs-number">1</span>, (*matA).row - <span class="hljs-number">1</span>, (*matA).column - <span class="hljs-number">1</span>);<br>Matrix b11 = matSplit((*matB), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, midR, midC);<br>Matrix b12 = matSplit((*matB), <span class="hljs-number">0</span>, midC + <span class="hljs-number">1</span>, midR, (*matA).column - <span class="hljs-number">1</span>);<br>Matrix b21 = matSplit((*matB), midR + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (*matA).row - <span class="hljs-number">1</span>, midC);<br>Matrix b22 = matSplit((*matB), midR + <span class="hljs-number">1</span>, midC + <span class="hljs-number">1</span>, (*matA).row - <span class="hljs-number">1</span>, (*matA).column - <span class="hljs-number">1</span>);<br>Matrix tmp1 = matAdd(&amp;a11, &amp;a22);<br>Matrix tmp2 = matAdd(&amp;b11, &amp;b22);<br>Matrix tmp3 = matAdd(&amp;a21, &amp;a22);<br>Matrix tmp4 = matSub(&amp;b12, &amp;b22);<br>Matrix tmp5 = matSub(&amp;b21, &amp;b11);<br>Matrix tmp6 = matAdd(&amp;a11, &amp;a12);<br>Matrix tmp7 = matSub(&amp;a21, &amp;a11);<br>Matrix tmp8 = matAdd(&amp;b11, &amp;b12);<br>Matrix tmp9 = matSub(&amp;a12, &amp;a22);<br>Matrix tmp10 = matAdd(&amp;b21, &amp;b22);<br>Matrix m1 = matProduct(&amp;tmp1, &amp;tmp2);<br>Matrix m2 = matProduct(&amp;tmp3, &amp;b11);<br>Matrix m3 = matProduct(&amp;a11, &amp;tmp4);<br>Matrix m4 = matProduct(&amp;a22, &amp;tmp5);<br>Matrix m5 = matProduct(&amp;tmp6, &amp;b22);<br>Matrix m6 = matProduct(&amp;tmp7, &amp;tmp8);<br>Matrix m7 = matProduct(&amp;tmp9, &amp;tmp10);<br>Matrix mtmp1 = matAdd(&amp;m1, &amp;m4);<br>Matrix mtmp2 = matSub(&amp;mtmp1, &amp;m5);<br>Matrix mtmp3 = matSub(&amp;m1, &amp;m2);<br>Matrix mtmp4 = matAdd(&amp;mtmp3, &amp;m3);<br>Matrix c11 = matAdd(&amp;mtmp2, &amp;m7);<br>Matrix c12 = matAdd(&amp;m3, &amp;m5);<br>Matrix c21 = matAdd(&amp;m2, &amp;m4);<br>Matrix c22 = matAdd(&amp;mtmp4, &amp;m6);<br><span class="hljs-comment">//cntp++;</span><br><span class="hljs-comment">//cout &lt;&lt; cntp &lt;&lt; endl;</span><br><span class="hljs-keyword">return</span> matCombine(c11, c12, c21, c22);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, n;<br><span class="hljs-keyword">clock_t</span> start, stop;<br><span class="hljs-function">ifstream <span class="hljs-title">fin1</span><span class="hljs-params">(<span class="hljs-string">&quot;data1.txt&quot;</span>)</span></span>;<br><span class="hljs-function">ifstream <span class="hljs-title">fin2</span><span class="hljs-params">(<span class="hljs-string">&quot;data2.txt&quot;</span>)</span></span>;<br><span class="hljs-keyword">while</span> (!fin1.eof() &amp;&amp; !fin2.eof()) &#123;<br>fin1 &gt;&gt; tm1[cnt];<br>fin2 &gt;&gt; tm2[cnt];<br>cnt++;<br>&#125;<br>cnt--;<br>n = <span class="hljs-built_in">sqrt</span>(cnt);<br>Matrix m1 = Matrix(n, n);<br>Matrix m2 = Matrix(n, n);<br>Matrix mr = Matrix(n, n);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>m1.m[i][j] = tm1[i * n + j];<br>m2.m[i][j] = tm2[i * n + j];<br>&#125;<br>&#125;<br>cntp = <span class="hljs-number">0</span>;<br>start = clock();<br>mr = matProduct(&amp;m1, &amp;m2);<br>stop = clock();<br><span class="hljs-comment">//for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="hljs-comment">//for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="hljs-comment">//cout &lt;&lt; mr.m[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//cout &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Time Cost: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-string">&quot;s&quot;</span>&lt;&lt; <span class="hljs-built_in">endl</span>;<br>fin1.close();<br>fin2.close();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩展的strassen矩阵乘法">扩展的Strassen矩阵乘法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span> &#123;</span><br>    <span class="hljs-keyword">int</span> row, column;<br>    <span class="hljs-keyword">int</span>** m;<br><br>    Matrix(<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;<br>        row = r;<br>        column = c;<br>        m = (<span class="hljs-keyword">int</span>**) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*r);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++)<br>            m[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * c);<br>    &#125;<br><br>    Matrix(<span class="hljs-keyword">const</span> Matrix&amp; mat) &#123;<br>        row = mat.row;<br>        column = mat.column;<br>        m = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * mat.row);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat.row; i++)<br>            m[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * mat.column);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; j++)<br>                m[i][j] = mat.m[i][j];<br>    &#125;<br><br>    Matrix&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> Matrix&amp; mat) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;mat) &#123;<br>            row = mat.row;<br>            column = mat.column;<br>            m = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * mat.row);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat.row; i++)<br>                m[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * mat.column);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; j++)<br>                    m[i][j] = mat.m[i][j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~Matrix() &#123;<br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>                <span class="hljs-keyword">delete</span>[] m[i];<br>            &#125;<br>            <span class="hljs-keyword">delete</span>[] m;<br>        &#125;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">int</span> tm1[<span class="hljs-number">2048</span> * <span class="hljs-number">2048</span>], tm2[<span class="hljs-number">2048</span> * <span class="hljs-number">2048</span>], cntp;<br><br><span class="hljs-function">Matrix <span class="hljs-title">matExtend</span><span class="hljs-params">(Matrix* mat)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>, exn;<br>    <span class="hljs-keyword">int</span> n = (*mat).row;<br>    <span class="hljs-keyword">while</span>(n)&#123;<br>        pos++;<br>        n = n&gt;&gt;<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(((*mat).row &amp; ((*mat).row - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) exn = (*mat).row;<br>    <span class="hljs-keyword">else</span> exn = <span class="hljs-number">1</span>&lt;&lt;pos;<br>    Matrix matR = Matrix(exn, exn);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (*mat).row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (*mat).column; j++)<br>            matR.m[i][j] = (*mat).m[i][j];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = (*mat).row; i &lt; exn; i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = (*mat).column; j &lt; exn; j++)<br>            matR.m[i][j] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matAdd</span><span class="hljs-params">(Matrix* matA, Matrix* matB)</span> </span>&#123;<br>    Matrix matR = Matrix((*matA).row, (*matA).column);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (*matA).row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (*matA).column; j++) &#123;<br>            matR.m[i][j] = (*matA).m[i][j] + (*matB).m[i][j];<br>        &#125;<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matSub</span><span class="hljs-params">(Matrix* matA, Matrix* matB)</span> </span>&#123;<br>    Matrix matR = Matrix((*matA).row, (*matA).column);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (*matA).row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (*matA).column; j++) &#123;<br>            matR.m[i][j] = (*matA).m[i][j] - (*matB).m[i][j];<br>        &#125;<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matSplit</span><span class="hljs-params">(Matrix mat, <span class="hljs-keyword">int</span> rowStart, <span class="hljs-keyword">int</span> columnStart, <span class="hljs-keyword">int</span> rowEnd, <span class="hljs-keyword">int</span> columnEnd)</span> </span>&#123;<br>    Matrix matR = Matrix(rowEnd - rowStart + <span class="hljs-number">1</span>, columnEnd - columnStart + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= rowEnd - rowStart; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= columnEnd - columnStart; j++) &#123;<br>            matR.m[i][j] = mat.m[rowStart + i][columnStart + j];<br>        &#125;<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matCombine</span><span class="hljs-params">(Matrix mat1, Matrix mat2, Matrix mat3, Matrix mat4)</span> </span>&#123;<br>    Matrix matR = Matrix(mat1.row + mat3.row, mat1.column + mat2.column);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat1.row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat1.column; j++)<br>            matR.m[i][j] = mat1.m[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat2.row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat2.column; j++)<br>            matR.m[i][mat1.column + j] = mat2.m[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat3.row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat3.column; j++)<br>            matR.m[mat1.row + i][j] = mat3.m[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat4.row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat4.column; j++)<br>            matR.m[mat1.row + i][mat1.column + j] = mat4.m[i][j];<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matProduct</span><span class="hljs-params">(Matrix* matA, Matrix* matB)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((*matA).row == <span class="hljs-number">1</span> &amp;&amp; (*matA).column == <span class="hljs-number">1</span> &amp;&amp; (*matB).row == <span class="hljs-number">1</span> &amp;&amp; (*matB).column == <span class="hljs-number">1</span>) &#123;<br>        Matrix matR = Matrix(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        matR.m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = (*matA).m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * (*matB).m[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span> matR;<br>    &#125;<br>    <span class="hljs-keyword">int</span> midR = (*matA).row / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> midC = (*matA).column / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>    Matrix a11 = matSplit((*matA), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, midR, midC);<br>    Matrix a12 = matSplit((*matA), <span class="hljs-number">0</span>, midC + <span class="hljs-number">1</span>, midR, (*matA).column - <span class="hljs-number">1</span>);<br>    Matrix a21 = matSplit((*matA), midR + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (*matA).row - <span class="hljs-number">1</span>, midC);<br>    Matrix a22 = matSplit((*matA), midR + <span class="hljs-number">1</span>, midC + <span class="hljs-number">1</span>, (*matA).row - <span class="hljs-number">1</span>, (*matA).column - <span class="hljs-number">1</span>);<br>    Matrix b11 = matSplit((*matB), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, midR, midC);<br>    Matrix b12 = matSplit((*matB), <span class="hljs-number">0</span>, midC + <span class="hljs-number">1</span>, midR, (*matA).column - <span class="hljs-number">1</span>);<br>    Matrix b21 = matSplit((*matB), midR + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (*matA).row - <span class="hljs-number">1</span>, midC);<br>    Matrix b22 = matSplit((*matB), midR + <span class="hljs-number">1</span>, midC + <span class="hljs-number">1</span>, (*matA).row - <span class="hljs-number">1</span>, (*matA).column - <span class="hljs-number">1</span>);<br>    Matrix tmp1 = matAdd(&amp;a11, &amp;a22);<br>    Matrix tmp2 = matAdd(&amp;b11, &amp;b22);<br>    Matrix tmp3 = matAdd(&amp;a21, &amp;a22);<br>    Matrix tmp4 = matSub(&amp;b12, &amp;b22);<br>    Matrix tmp5 = matSub(&amp;b21, &amp;b11);<br>    Matrix tmp6 = matAdd(&amp;a11, &amp;a12);<br>    Matrix tmp7 = matSub(&amp;a21, &amp;a11);<br>    Matrix tmp8 = matAdd(&amp;b11, &amp;b12);<br>    Matrix tmp9 = matSub(&amp;a12, &amp;a22);<br>    Matrix tmp10 = matAdd(&amp;b21, &amp;b22);<br>    Matrix m1 = matProduct(&amp;tmp1, &amp;tmp2);<br>    Matrix m2 = matProduct(&amp;tmp3, &amp;b11);<br>    Matrix m3 = matProduct(&amp;a11, &amp;tmp4);<br>    Matrix m4 = matProduct(&amp;a22, &amp;tmp5);<br>    Matrix m5 = matProduct(&amp;tmp6, &amp;b22);<br>    Matrix m6 = matProduct(&amp;tmp7, &amp;tmp8);<br>    Matrix m7 = matProduct(&amp;tmp9, &amp;tmp10);<br>    Matrix mtmp1 = matAdd(&amp;m1, &amp;m4);<br>    Matrix mtmp2 = matSub(&amp;mtmp1, &amp;m5);<br>    Matrix mtmp3 = matSub(&amp;m1, &amp;m2);<br>    Matrix mtmp4 = matAdd(&amp;mtmp3, &amp;m3);<br>    Matrix c11 = matAdd(&amp;mtmp2, &amp;m7);<br>    Matrix c12 = matAdd(&amp;m3, &amp;m5);<br>    Matrix c21 = matAdd(&amp;m2, &amp;m4);<br>    Matrix c22 = matAdd(&amp;mtmp4, &amp;m6);<br>    <span class="hljs-comment">//cntp++;</span><br>    <span class="hljs-comment">//cout &lt;&lt; cntp &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> matCombine(c11, c12, c21, c22);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, n;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin1</span><span class="hljs-params">(<span class="hljs-string">&quot;data1.txt&quot;</span>)</span></span>;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin2</span><span class="hljs-params">(<span class="hljs-string">&quot;data2.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (!fin1.eof() &amp;&amp; !fin2.eof()) &#123;<br>        fin1 &gt;&gt; tm1[cnt];<br>        fin2 &gt;&gt; tm2[cnt];<br>        cnt++;<br>    &#125;<br>    cnt--;<br>    n = <span class="hljs-built_in">sqrt</span>(cnt);<br>    Matrix m1 = Matrix(n, n);<br>    Matrix m2 = Matrix(n, n);<br>    Matrix mr = Matrix(n, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            m1.m[i][j] = tm1[i * n + j];<br>            m2.m[i][j] = tm2[i * n + j];<br>        &#125;<br>    &#125;<br>    cntp = <span class="hljs-number">0</span>;<br>    start = clock();<br>    Matrix m1e = matExtend(&amp;m1);<br>    Matrix m2e = matExtend(&amp;m2);<br>    mr = matProduct(&amp;m1e, &amp;m2e);<br>    stop = clock();<br>    <span class="hljs-comment">//for (int i = 0; i &lt; n; i++) &#123;</span><br>    <span class="hljs-comment">//for (int j = 0; j &lt; n; j++) &#123;</span><br>    <span class="hljs-comment">//cout &lt;&lt; mr.m[i][j] &lt;&lt; &quot; &quot;;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">//cout &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Time Cost: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-string">&quot;s&quot;</span>&lt;&lt; <span class="hljs-built_in">endl</span>;<br>    fin1.close();<br>    fin2.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strassen矩阵乘法剪枝优化">Strassen矩阵乘法（剪枝优化）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span> &#123;</span><br>    <span class="hljs-keyword">int</span> row, column;<br>    <span class="hljs-keyword">int</span>** m;<br><br>    Matrix(<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;<br>        row = r;<br>        column = c;<br>        m = (<span class="hljs-keyword">int</span>**) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*)*r);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++)<br>            m[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * c);<br>    &#125;<br><br>    Matrix(<span class="hljs-keyword">const</span> Matrix&amp; mat) &#123;<br>        row = mat.row;<br>        column = mat.column;<br>        m = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * mat.row);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat.row; i++)<br>            m[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * mat.column);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; j++)<br>                m[i][j] = mat.m[i][j];<br>    &#125;<br><br>    Matrix&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> Matrix&amp; mat) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;mat) &#123;<br>            row = mat.row;<br>            column = mat.column;<br>            m = (<span class="hljs-keyword">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>*) * mat.row);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat.row; i++)<br>                m[i] = (<span class="hljs-keyword">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) * mat.column);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; column; j++)<br>                    m[i][j] = mat.m[i][j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    ~Matrix() &#123;<br>        <span class="hljs-keyword">if</span> (m != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>                <span class="hljs-keyword">delete</span>[] m[i];<br>            &#125;<br>            <span class="hljs-keyword">delete</span>[] m;<br>        &#125;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">int</span> tm1[<span class="hljs-number">2048</span> * <span class="hljs-number">2048</span>], tm2[<span class="hljs-number">2048</span> * <span class="hljs-number">2048</span>], cntp;<br><br><span class="hljs-function">Matrix <span class="hljs-title">matAdd</span><span class="hljs-params">(Matrix* matA, Matrix* matB)</span> </span>&#123;<br>    Matrix matR = Matrix((*matA).row, (*matA).column);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (*matA).row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (*matA).column; j++) &#123;<br>            matR.m[i][j] = (*matA).m[i][j] + (*matB).m[i][j];<br>        &#125;<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matSub</span><span class="hljs-params">(Matrix* matA, Matrix* matB)</span> </span>&#123;<br>    Matrix matR = Matrix((*matA).row, (*matA).column);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (*matA).row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; (*matA).column; j++) &#123;<br>            matR.m[i][j] = (*matA).m[i][j] - (*matB).m[i][j];<br>        &#125;<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matSplit</span><span class="hljs-params">(Matrix mat, <span class="hljs-keyword">int</span> rowStart, <span class="hljs-keyword">int</span> columnStart, <span class="hljs-keyword">int</span> rowEnd, <span class="hljs-keyword">int</span> columnEnd)</span> </span>&#123;<br>    Matrix matR = Matrix(rowEnd - rowStart + <span class="hljs-number">1</span>, columnEnd - columnStart + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= rowEnd - rowStart; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= columnEnd - columnStart; j++) &#123;<br>            matR.m[i][j] = mat.m[rowStart + i][columnStart + j];<br>        &#125;<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matCombine</span><span class="hljs-params">(Matrix mat1, Matrix mat2, Matrix mat3, Matrix mat4)</span> </span>&#123;<br>    Matrix matR = Matrix(mat1.row + mat3.row, mat1.column + mat2.column);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat1.row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat1.column; j++)<br>            matR.m[i][j] = mat1.m[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat2.row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat2.column; j++)<br>            matR.m[i][mat1.column + j] = mat2.m[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat3.row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat3.column; j++)<br>            matR.m[mat1.row + i][j] = mat3.m[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat4.row; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; mat4.column; j++)<br>            matR.m[mat1.row + i][mat1.column + j] = mat4.m[i][j];<br>    <span class="hljs-keyword">return</span> matR;<br>&#125;<br><span class="hljs-function">Matrix <span class="hljs-title">matProduct</span><span class="hljs-params">(Matrix* matA, Matrix* matB, <span class="hljs-keyword">int</span> leafcut)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> ((*matA).row &lt;= leafcut &amp;&amp; (*matA).column &lt;= leafcut &amp;&amp; (*matB).row &lt;= leafcut &amp;&amp; (*matB).column &lt;= leafcut) &#123;<br>        Matrix matR = Matrix(leafcut, leafcut);<br>        <span class="hljs-keyword">int</span> tsum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; leafcut; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; leafcut; j++) &#123;<br>                tsum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; leafcut; k++) &#123;<br>                    matR.m[i][j] += (*matA).m[i][k] * (*matB).m[k][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matR;<br>    &#125;<br>    <span class="hljs-keyword">int</span> midR = (*matA).row / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> midC = (*matA).column / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>    Matrix a11 = matSplit((*matA), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, midR, midC);<br>    Matrix a12 = matSplit((*matA), <span class="hljs-number">0</span>, midC + <span class="hljs-number">1</span>, midR, (*matA).column - <span class="hljs-number">1</span>);<br>    Matrix a21 = matSplit((*matA), midR + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (*matA).row - <span class="hljs-number">1</span>, midC);<br>    Matrix a22 = matSplit((*matA), midR + <span class="hljs-number">1</span>, midC + <span class="hljs-number">1</span>, (*matA).row - <span class="hljs-number">1</span>, (*matA).column - <span class="hljs-number">1</span>);<br>    Matrix b11 = matSplit((*matB), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, midR, midC);<br>    Matrix b12 = matSplit((*matB), <span class="hljs-number">0</span>, midC + <span class="hljs-number">1</span>, midR, (*matA).column - <span class="hljs-number">1</span>);<br>    Matrix b21 = matSplit((*matB), midR + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, (*matA).row - <span class="hljs-number">1</span>, midC);<br>    Matrix b22 = matSplit((*matB), midR + <span class="hljs-number">1</span>, midC + <span class="hljs-number">1</span>, (*matA).row - <span class="hljs-number">1</span>, (*matA).column - <span class="hljs-number">1</span>);<br>    Matrix tmp1 = matAdd(&amp;a11, &amp;a22);<br>    Matrix tmp2 = matAdd(&amp;b11, &amp;b22);<br>    Matrix tmp3 = matAdd(&amp;a21, &amp;a22);<br>    Matrix tmp4 = matSub(&amp;b12, &amp;b22);<br>    Matrix tmp5 = matSub(&amp;b21, &amp;b11);<br>    Matrix tmp6 = matAdd(&amp;a11, &amp;a12);<br>    Matrix tmp7 = matSub(&amp;a21, &amp;a11);<br>    Matrix tmp8 = matAdd(&amp;b11, &amp;b12);<br>    Matrix tmp9 = matSub(&amp;a12, &amp;a22);<br>    Matrix tmp10 = matAdd(&amp;b21, &amp;b22);<br>    Matrix m1 = matProduct(&amp;tmp1, &amp;tmp2, leafcut);<br>    Matrix m2 = matProduct(&amp;tmp3, &amp;b11, leafcut);<br>    Matrix m3 = matProduct(&amp;a11, &amp;tmp4, leafcut);<br>    Matrix m4 = matProduct(&amp;a22, &amp;tmp5, leafcut);<br>    Matrix m5 = matProduct(&amp;tmp6, &amp;b22, leafcut);<br>    Matrix m6 = matProduct(&amp;tmp7, &amp;tmp8, leafcut);<br>    Matrix m7 = matProduct(&amp;tmp9, &amp;tmp10, leafcut);<br>    Matrix mtmp1 = matAdd(&amp;m1, &amp;m4);<br>    Matrix mtmp2 = matSub(&amp;mtmp1, &amp;m5);<br>    Matrix mtmp3 = matSub(&amp;m1, &amp;m2);<br>    Matrix mtmp4 = matAdd(&amp;mtmp3, &amp;m3);<br>    Matrix c11 = matAdd(&amp;mtmp2, &amp;m7);<br>    Matrix c12 = matAdd(&amp;m3, &amp;m5);<br>    Matrix c21 = matAdd(&amp;m2, &amp;m4);<br>    Matrix c22 = matAdd(&amp;mtmp4, &amp;m6);<br>    <span class="hljs-comment">//cntp++;</span><br>    <span class="hljs-comment">//cout &lt;&lt; cntp &lt;&lt; endl;</span><br>    <span class="hljs-keyword">return</span> matCombine(c11, c12, c21, c22);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, n;<br>    <span class="hljs-keyword">clock_t</span> start, stop;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin1</span><span class="hljs-params">(<span class="hljs-string">&quot;data1.txt&quot;</span>)</span></span>;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin2</span><span class="hljs-params">(<span class="hljs-string">&quot;data2.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">while</span> (!fin1.eof() &amp;&amp; !fin2.eof()) &#123;<br>        fin1 &gt;&gt; tm1[cnt];<br>        fin2 &gt;&gt; tm2[cnt];<br>        cnt++;<br>    &#125;<br>    cnt--;<br>    n = <span class="hljs-built_in">sqrt</span>(cnt);<br>    Matrix m1 = Matrix(n, n);<br>    Matrix m2 = Matrix(n, n);<br>    Matrix mr = Matrix(n, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            m1.m[i][j] = tm1[i * n + j];<br>            m2.m[i][j] = tm2[i * n + j];<br>        &#125;<br>    &#125;<br>    cntp = <span class="hljs-number">0</span>;<br>    start = clock();<br>    mr = matProduct(&amp;m1, &amp;m2, <span class="hljs-number">16</span>);<br>    stop = clock();<br>    <span class="hljs-comment">//for (int i = 0; i &lt; n; i++) &#123;</span><br>    <span class="hljs-comment">// for (int j = 0; j &lt; n; j++) &#123;</span><br>    <span class="hljs-comment">//    cout &lt;&lt; mr.m[i][j] &lt;&lt; &quot; &quot;;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Time Cost: &quot;</span>&lt;&lt;(<span class="hljs-keyword">double</span>)(stop - start) / CLOCKS_PER_SEC&lt;&lt;<span class="hljs-string">&quot;s&quot;</span>&lt;&lt; <span class="hljs-built_in">endl</span>;<br>    fin1.close();<br>    fin2.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行效率">运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><figure><img src="3.png" alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><h2 id="总结">总结</h2><p>从理论上看，Strassen算法的时间复杂度为<span class="math display">\[\mathcal{O}(n^{\lg 7})\]</span>，相比朴素矩阵乘法 <span class="math display">\[\mathcal{O}(n^3)\]</span> 的复杂度略快，但由于其在规模较小时的常数很大，相比朴素矩阵乘法优势并不明显。此外，由于使用Strassen算法需要动态申请大量的临时空间，而申请、访问和删除这些辅助空间的代价远大于运算本身的代价（使用Visual Studio性能检测工具分析程序可以发现仅创建和删除这些临时空间的耗时就占了整个程序运行时间的70%左右），因此从实际测试结果来看Strassen算法甚至还远慢于朴素矩阵乘法。</p><figure><img src="analysis-vscode.png" alt="analysis-vscode" /><figcaption aria-hidden="true">analysis-vscode</figcaption></figure><p>为了避免常数和内存交互时间对测试结果造成影响，我们可以对原算法进行适当的剪枝（Leaf-Cut）优化，即当矩阵规模缩小到一个固定值后改用朴素矩阵乘法继续处理该矩阵。经实测表明，当剪枝范围为16～64之间时，性能瓶颈得到了极大的缓解，且随着数据规模的增大，改进后的算法相比纯朴素矩阵乘法逐渐出现显著的性能优势，与理论计算值基本吻合。 对于矩阵大小不为2的幂次时，可以先将原矩阵扩展至最邻近的2的幂次大小（扩展部分全部用0补齐），随后即可使用Strassen算法进行分治计算。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB使用指南</title>
    <link href="/2020/09/19/computer-system/gdb-guide/"/>
    <url>/2020/09/19/computer-system/gdb-guide/</url>
    
    <content type="html"><![CDATA[<h1 id="gdb使用指南">GDB使用指南</h1><p>GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。</p><p>GDB官网：<a href="http://www.gnu.org/software/gdb/">GDB: The GNU Project Debugger</a></p><a id="more"></a><h2 id="gdb和lldb">GDB和LLDB</h2><p>LLDB是一款开源的具有REPL（Read-Evaluation-Print-Loop）特征的调试工具，相比GDB在部分场景下更加先进和高效。Xcode自4.3版本后默认内置了LLDB，因此<strong>macOS用户可以直接使用LLDB对程序进行调试</strong>。（当然macOS同样也可以安装GDB调试工具）</p><p>GDB与LLDB命令对照表：<a href="https://lldb.llvm.org/use/map.html">GDB to LLDB command map</a></p><h2 id="windows下安装gcc和gdb">WINDOWS下安装GCC和GDB</h2><p>MinGW（Minimalist GNU For Windows）是Windows下的一个小型GNU工具集。新版MinGW中集成了GCC和GDB的相关工具，因此只需安装MinGW即可使用GCC和GDB。</p><h3 id="下载mingw及gcc包">下载MinGW及GCC包</h3><p>首先前往MinGW官方网站：<a href="http://www.mingw.org">MinGW</a> 并在Download界面下载MinGW管理工具。</p><figure><img src="mingw-1.png" alt="mingw-2" /><figcaption aria-hidden="true">mingw-2</figcaption></figure><figure><img src="mingw-2.png" alt="mingw-2" /><figcaption aria-hidden="true">mingw-2</figcaption></figure><p>安装MinGW管理工具并打开。</p><figure><img src="mingw-3.JPG" alt="mingw-3" /><figcaption aria-hidden="true">mingw-3</figcaption></figure><p>选择所需的工具集，点击左上角的<strong>Installation-&gt;Apply Changes</strong>即可安装。（由于受国内网络环境影响，可能会出现下载失败的情况，可以多尝试几次或使用其他网络连接方式下载）。若使用C/C++进行开发，通常仅需安装<strong>mingw32-base-bin</strong>及<strong>mingw32-gcc-g++-bin</strong>即可。</p><h3 id="配置系统环境变量">配置系统环境变量</h3><p>安装完成后，我们需要配置系统环境变量使得其可以在CMD中执行。</p><p><strong>右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量</strong>，在系统变量框中找到<strong>Path</strong>变量，选择编辑，在最后新增一行填入**你的MinGW安装路径*，确定退出。</p><figure><img src="mingw-4.JPG" alt="mingw-4" /><figcaption aria-hidden="true">mingw-4</figcaption></figure><p>打开CMD，输入<strong>gcc -v</strong>及<strong>gdb -v</strong>，若显示相关版本信息，表明环境变量配置成功。</p><figure><img src="mingw-5.JPG" alt="mingw-5" /><figcaption aria-hidden="true">mingw-5</figcaption></figure><h2 id="在其他ide中调用gdb">在其他IDE中调用GDB</h2><h3 id="clion">CLion</h3><p>CLion本身已经集成了十分完善的可视化调试工具，但如果想在CLion中使用GDB或LLDB调试程序同样十分方便。</p><p>使用通常的方法在需要的地方打上断点启动调试，在下方的Debug窗口中就可以看到GDB/LLDB窗口，在其中输入命令即可。</p><figure><img src="clion-1.png" alt="clion-1" /><figcaption aria-hidden="true">clion-1</figcaption></figure><h3 id="visual-studio-code">Visual Studio Code</h3><p>VSCode本身并不自带GCC和GDB的相关功能，因此<strong>使用VSCode进行调试同样需要额外安装GDB/LLDB调试工具</strong>。不过，VSCode提供了一个可视化的C/C++调试插件，相比命令行调试会直观很多。该插件可直接在插件商店里搜索并安装。</p><figure><img src="vscode-1.png" alt="vscode-1" /><figcaption aria-hidden="true">vscode-1</figcaption></figure><p>和其他大型IDE类似，VSCode将一个目录视为一个项目，因此在创建项目时，你需要指定一个空的文件夹来存放项目文件<strong>（这也是一些人装了辅助插件却被提示要手动配置调试文件的一大重要原因）</strong>。在第一次运行程序时，选择<strong>Run-&gt;Start Debugging</strong>，在弹出的选项框中选择一个要使用的调试环境及编译环境，VSCode就会自动在当前的项目目录下创建相应的配置文件。（当然也可以手动指定配置文件，具体配置方法可参考VSCode官方文档）</p><figure><img src="vscode-2.png" alt="vscode-2" /><figcaption aria-hidden="true">vscode-2</figcaption></figure><figure><img src="vscode-3.png" alt="vscode-3" /><figcaption aria-hidden="true">vscode-3</figcaption></figure><p>随后即可在调试界面中看到相关的调试信息。你也可以在下方的Debug Console中输入相关的GDB/LLDB命令来进行进一步的调试。</p><figure><img src="vscode-4.png" alt="vscode-4" /><figcaption aria-hidden="true">vscode-4</figcaption></figure><h2 id="gdb的基本使用">GDB的基本使用</h2><h3 id="启动调试">启动调试</h3><p>若要使用GDB来调试程序，需要在使用GCC编译源文件的时候打开-g选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">gcc -g [源文件名] -o [目标文件名]<br></code></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -g test.c -o test<br></code></pre></td></tr></table></figure></blockquote><p><strong>若不打开调试选项，则在调试时无法添加断点。</strong></p><p>使用gdb打开生成的可执行文件即可开始调试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">gdb [目标文件名]<br></code></pre></td></tr></table></figure><p>GDB还可以关联正在运行的程序进行调试。我们可以通过ps命令查询目标进程的PID，随后进入GDB使用attach命令关联进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef|grep [进程名]<br>gdb<br>(gdb) attach [PID]<br></code></pre></td></tr></table></figure><p>Linux用户在这一过程过可能会遇到权限不足的情况。解决方法：切换至root用户，进入<strong>/etc/stsctl.d/10-ptrace.conf</strong>中将<code>kernel.yama.ptrace_scpoe = 1</code>改为<code>kernel.yama.ptrace_scpoe = 0</code>即可。</p><h3 id="添加断点">添加断点</h3><p>通常在调试过程中，我们需要在程序的某个位置添加断点，并让程序运行到这一位置时自动暂停以分析程序当前的运行状态。在GDB环境下，我们可以通过break命令来快速添加断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break [源文件名称]:[行号] #执行到某一行时中断<br>(gdb) break [函数名] #执行到某个函数时中断<br></code></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break test.c:5<br>(gdb) break main<br></code></pre></td></tr></table></figure></blockquote><p>有时我们希望程序在特定条件下中断，这个时候我们可以使用break+if或condition语句来设置条件断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break [中断位置] if 触发条件<br></code></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break test.c:10 if a==5<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break [中断位置]<br>(gdb) condition [断点号] [触发条件]<br></code></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) break test.c:10<br>(gdb) condition 1 a==5<br></code></pre></td></tr></table></figure></blockquote><p>我们可以使用info指令查看已设置断点的断点号及相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) info breakpoints<br></code></pre></td></tr></table></figure><p>通过clear和delete命令可以删除已创建的断点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) clear [目标文件名]:[行号] #删除某一行处的断点<br>(gdb) clear [函数名] #删除某个函数处的断点<br>(gdb) delete #删除所有断点<br>(gdb) delete [断点号] #删除某一特定断点<br></code></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) clear test:5<br>(gdb) delete 1<br></code></pre></td></tr></table></figure></blockquote><h3 id="运行程序">运行程序</h3><p>对于不需要向main函数传递参数的程序，可以直接使用run指令开始运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) run<br></code></pre></td></tr></table></figure><p>对于需要向main函数传递参数的程序，可以使用set args指令或直接在run后跟参数的方式运行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set args [参数]<br>(gdb) run<br></code></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) set args para1 para2 para3<br>(gdb) run<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) run [参数]<br></code></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) run para1 para2 para3<br></code></pre></td></tr></table></figure></blockquote><p>程序运行后，会一直运行至第一个断点处并暂停。若没有设置断点，则效果等同于直接运行程序。</p><p>当程序中断后，GDB提供了以下几种继续运行的指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) next #单步执行（不进入函数内部，等同于Clion中的Step Over）<br>(gdb) step #单步进入（进入函数内部，等同于Clion的Step Into）<br>(gdb) continue #继续执行至下一个断点处<br>(gdb) until [行号] #继续执行直至某一行<br>(gdb) finish #运行至程序结尾<br></code></pre></td></tr></table></figure><h3 id="查看变量及内存">查看变量及内存</h3><p>在程序中断时，GDB提供了一系列指令来查看当前变量及内存中的各种信息。</p><p>通过print指令可以打印变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) print &#x27;[源文件名/函数名]&#x27;::[变量名/表达式]<br></code></pre></td></tr></table></figure><blockquote><p>Example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) print &#x27;main&#x27;::a<br>(gdb) print &#x27;test.c&#x27;::b<br>(gdb) print &#x27;main&#x27;::*p<br></code></pre></td></tr></table></figure></blockquote><p>通过display命令可以使得每次程序中断时自动打印某个变量或表达式的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) display [变量名/表达式]<br></code></pre></td></tr></table></figure><p>此外，我们还可以通过watch指令追踪某一变量，使其值发生改变时中断程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) watch [变量名]<br></code></pre></td></tr></table></figure><p>通过backtrace指令可以查看函数调用栈的存储情况及相关信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) backtrace<br></code></pre></td></tr></table></figure><p>更多其他命令的详细用法，可以通过help指令查询</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) help [命令]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Language</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序、归并排序及冒泡排序</title>
    <link href="/2020/09/18/algorithm/course-exp/algorithm-exp1/"/>
    <url>/2020/09/18/algorithm/course-exp/algorithm-exp1/</url>
    
    <content type="html"><![CDATA[<h2 id="内容与设计思想">内容与设计思想</h2><ol type="1"><li>设计一个数据生成器，输入参数包括 <span class="math display">\[N, s, t, T\]</span>；可随机生成一个大小为<span class="math display">\[N\]</span>、数值范围在 <span class="math display">\[[s, t]\]</span> 之间、类型为 <span class="math display">\[T\]</span> 的数据集合；<span class="math display">\[T\]</span> 包括三种类型（顺序递增、顺序递减、随机取值）</li><li>编程实现<strong>Merge sort</strong>算法和<strong>Insertion sort</strong>算法。</li><li>对于<strong>顺序递增</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<span class="math display">\[10^2, 10^3, 10^4, 10^5, 10^6\]</span>）下，两种算法的运行时间各是多少？</li><li>对于<strong>顺序递减</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<span class="math display">\[10^2, 10^3, 10^4, 10^5, 10^6\]</span>）下，两种算法的运行时间各是多少？</li><li>对于<strong>随机取值</strong>类型的数据集合而言，在不同数据规模情况下（数据规模为<span class="math display">\[10^2, 10^3, 10^4, 10^5, 10^6\]</span>）下，两种算法的运行时间各是多少？</li><li>编程实现<strong>Bubble sort</strong>算法，并与上面两个算法进行对比。</li></ol><a id="more"></a><h2 id="实现代码">实现代码</h2><h3 id="随机数生成器">随机数生成器</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b &lt; a;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n,s,t,type,a[<span class="hljs-number">1000000</span>];<br>    srand(time(<span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;s&gt;&gt;t&gt;&gt;type;<br>    <span class="hljs-function">ofstream <span class="hljs-title">fout</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        a[i] = s + rand() % (t - s);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>)&#123;<br>        sort(a, a + n);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">2</span>)&#123;<br>        sort(a, a + n, cmp);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>; w &lt; n; w++)&#123;<br>        fout&lt;&lt;a[w]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    fout.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序">插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">1000000</span>], n, key, j;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        fin&gt;&gt;a[n];<br>        n++;<br>    &#125;<br>    n--;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        key = a[i];<br>        j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; a[j] &gt; key)&#123;<br>            a[j + <span class="hljs-number">1</span>] = a[j];<br>            j--;<br>        &#125;<br>        a[j + <span class="hljs-number">1</span>] = key;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>; w &lt; n; w++)&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;a[w]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1000000</span>], t[<span class="hljs-number">1000000</span>], n;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (right - left &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">int</span> mid = left + (right - left &gt;&gt; <span class="hljs-number">1</span>);<br>    merge(left, mid);<br>    merge(mid, right);<br>    <span class="hljs-keyword">int</span> p = left, q = mid, cur = left;<br>    <span class="hljs-keyword">while</span> (cur &lt; right) &#123;<br>        <span class="hljs-keyword">if</span> (p &gt;= mid || (q &lt; right &amp;&amp; a[p] &gt; a[q]))<br>            t[cur++] = a[q++];<br>        <span class="hljs-keyword">else</span><br>            t[cur++] = a[p++];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt; right; i++) a[i] = t[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!fin.eof()) &#123;<br>        fin &gt;&gt; a[n];<br>        n++;<br>    &#125;<br>    n--;<br>    merge(<span class="hljs-number">0</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>; w &lt; n; w++) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; a[w] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冒泡排序">冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a[<span class="hljs-number">1000000</span>], n, temp;<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function">ifstream <span class="hljs-title">fin</span><span class="hljs-params">(<span class="hljs-string">&quot;data.txt&quot;</span>)</span></span>;<br>    n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(!fin.eof())&#123;<br>        fin&gt;&gt;a[n];<br>        n++;<br>    &#125;<br>    n--;<br>    <span class="hljs-keyword">while</span>(flag)&#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] &gt; a[i + <span class="hljs-number">1</span>])&#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                temp = a[i];<br>                a[i] = a[i + <span class="hljs-number">1</span>];<br>                a[i + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>; w &lt; n; w++) <span class="hljs-built_in">cout</span>&lt;&lt;a[w]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>  fin.close();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行效率">运行效率</h2><p>时间记录使用了C++自带的clock()函数，通过在程序开头和结尾分别调用clock()函数并将两值相减，即可得到程序运行时间。结果如下：</p><figure><img src="1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><figure><img src="3.png" alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><h2 id="总结">总结</h2><p>从上面的图表中可以发现，当数据集合为已经排序好（顺序递增）的集合时，插入排序和冒泡排序的运行效率高于归并排序。但当数据集合为顺序递减或随机取值时，归并排序的运行效率要明显高于插入排序和冒泡排序。且随着数据规模的增大，归并排序所需的运行时间增长较为缓慢，而插入排序和冒泡排序的运行时间迅速增长，且冒泡排序的增长幅度要高于插入排序。通过理论计算可以得知插入排序的最好时间复杂度为 <span class="math display">\[\mathcal{O}(n)\]</span>，平均和最坏时间复杂度均为 <span class="math display">\[\mathcal{O}(n^2)\]</span>；归并排序的最好，平均，最坏时间复杂度均为 <span class="math display">\[\mathcal{O}(n \lg n)\]</span>；冒泡排序的最好时间复杂度为 <span class="math display">\[\mathcal{O}(n)\]</span>，平均和最坏时间复杂度均为 <span class="math display">\[\mathcal{O}(n^2)\]</span>，这与实验结果基本吻合。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer-Science</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实数的严格定义</title>
    <link href="/2020/08/26/math-analysis/real-number/"/>
    <url>/2020/08/26/math-analysis/real-number/</url>
    
    <content type="html"><![CDATA[<p>对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 <span class="math inline">\(1,2,3,4,...\)</span>，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。</p>]]></content>
    
    
    <categories>
      
      <category>分析学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>Analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代数概念整理：映射</title>
    <link href="/2020/07/31/math-algebra/algebra-projection/"/>
    <url>/2020/07/31/math-algebra/algebra-projection/</url>
    
    <content type="html"><![CDATA[<h1 id="定义">定义</h1><ol type="1"><li><p>设 <span class="math inline">\(X,Y\)</span> 为两个集合，<span class="math inline">\(f\)</span> 为某种使得 <span class="math inline">\(X\)</span> 中的每一个元素都对应于 <span class="math inline">\(Y\)</span> 中某个元素的规则，则称 <span class="math inline">\(f\)</span> 为 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(Y\)</span> 的一个<strong>映射</strong>，记为 <span class="math inline">\(f:X \to Y\)</span> ， <span class="math inline">\(X\)</span> 称为 <span class="math inline">\(f\)</span> 的<strong>定义域</strong>， <span class="math inline">\(Y\)</span> 称为 <span class="math inline">\(f\)</span> 的<strong>陪域</strong></p></li><li><p>设 <span class="math inline">\(f:X \to Y\)</span> 为一映射，则 <span class="math inline">\(X\)</span> 中的元素 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(f\)</span> 下对应的 <span class="math inline">\(Y\)</span> 中的元素 <span class="math inline">\(b\)</span> 称为 <span class="math inline">\(a\)</span> 的<strong>象</strong>，记为 <span class="math inline">\(f(a)\)</span> ； <span class="math inline">\(a\)</span> 称为 <span class="math inline">\(b\)</span> 的<strong>原象</strong>，记为 <span class="math inline">\(f^{-1}(b)\)</span> ；集合 <span class="math inline">\(\{f(x) \big| x \in X\}\)</span> 称为 <span class="math inline">\(f\)</span> 的<strong>值域</strong>或 <span class="math inline">\(f\)</span> 的<strong>象</strong>，记为<span class="math inline">\(f(X)\)</span> 或 <span class="math inline">\(Imf\)</span></p></li><li><p>设 <span class="math inline">\(f:X \to Y\)</span> 为一映射，若 <span class="math inline">\(\forall x_1 \neq x_2 \in X, f(x_1) \neq f(x_2)\)</span> ，则称 <span class="math inline">\(f\)</span> 为一个<strong>单射</strong></p></li><li><p>设 <span class="math inline">\(f:X \to Y\)</span> 为一映射，若 <span class="math inline">\(\forall y \in Y, \exists x \in X\)</span> ，使得 <span class="math inline">\(f(x)=y\)</span> ，即 <span class="math inline">\(Imf=Y\)</span> ，则称 <span class="math inline">\(f\)</span> 为一个<strong>满射</strong></p><a id="more"></a></li><li><p>设 <span class="math inline">\(f:X \to Y\)</span> 为一映射，若 <span class="math inline">\(f\)</span> 即是<strong>单射</strong>又是<strong>满射</strong>，则称 <span class="math inline">\(f\)</span> 为一个<strong>双射</strong></p></li><li><p>设 <span class="math inline">\(f: X \to Y\)</span> 为一映射，若 <span class="math inline">\(Y=X\)</span> ，且 <span class="math inline">\(\forall x \in X, f(x) = x\)</span> ，则称 <span class="math inline">\(f\)</span> 为一个<strong>恒等映射</strong>，记为 <span class="math inline">\(Id_X\)</span> 或 <span class="math inline">\(e_X\)</span></p></li><li><p>设 <span class="math inline">\(f: A \to C, g: B \to D\)</span> 为两个映射，若 <span class="math inline">\(A = B,C=D\)</span> ，且 <span class="math inline">\(\forall x \in A, f(x)=g(x)\)</span> ，则称映射 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> <strong>相等</strong></p></li><li><p>设 <span class="math inline">\(f: X \to Y, g: Y \to Z\)</span> 为两个映射，则由法则 <span class="math inline">\((g \circ f)(x) = g(f(x))\)</span> 定义的映射称为 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 的<strong>合成</strong>，记为 <span class="math inline">\(g \circ f: X \to Z\)</span> 或 <span class="math inline">\(gf: X \to Z\)</span></p></li><li><p>设 <span class="math inline">\(f:X \to Y,g: Y \to X\)</span> 为两个映射，若 <span class="math inline">\(g \circ f = e_X\)</span> ，则称 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(f\)</span> 的<strong>左逆</strong>， <span class="math inline">\(f\)</span> 为 <span class="math inline">\(g\)</span> 的<strong>右逆</strong>；若 <span class="math inline">\(g \circ f = e_X,f \circ g = e_Y\)</span> ,则称 <span class="math inline">\(g\)</span> 为 <span class="math inline">\(f\)</span> 的<strong>双边逆</strong>或<strong>逆</strong></p></li></ol><h1 id="基本性质">基本性质</h1><p><strong>1、（映射的合成律）</strong> 设 <span class="math inline">\(f: X \to Y, g: Y \to Z, h: Z \to W\)</span> 为三个映射，则 <span class="math inline">\(h(gf)=(hg)f\)</span></p><p><strong>证明：</strong> 对于 $ h(gf) $ ，<span class="math inline">\((X \to Y \to Z) \to W=X \to W\)</span> ；对于 <span class="math inline">\((hg)f\)</span> ，<span class="math inline">\(X \to (Y \to Z \to W)=X \to W\)</span></p><p><span class="math inline">\(\therefore\)</span> <span class="math inline">\(h(gf)\)</span> 与 <span class="math inline">\((hg)f\)</span> 的定义域及陪域相同</p><p><span class="math inline">\(\forall x \in X\)</span> ，由<strong>定义8</strong>可知</p><p><span class="math inline">\((h(gf))(x)=h((gf)(x))=h(g(f(x)))=(hg)(f(x))=((hg)f)(x)\)</span></p><p><span class="math inline">\(\therefore\)</span> 由<strong>定义7</strong>可知，<span class="math inline">\(h(gf)=(hg)f\)</span></p>]]></content>
    
    
    <categories>
      
      <category>代数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>Algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代数概念整理：集合</title>
    <link href="/2020/07/30/math-algebra/algebra-set/"/>
    <url>/2020/07/30/math-algebra/algebra-set/</url>
    
    <content type="html"><![CDATA[<h1 id="定义">定义</h1><ol type="1"><li><p>若 <span class="math inline">\(a\)</span> 为 <span class="math inline">\(S\)</span> 中的一个元素，则称 <span class="math inline">\(a\)</span> <strong>包含于</strong> <span class="math inline">\(S\)</span> ，记为 <span class="math inline">\(a \in S\)</span> ；若 <span class="math inline">\(a\)</span> 不为 <span class="math inline">\(S\)</span> 中的任一元素，则称 <span class="math inline">\(a\)</span> <strong>不包含于</strong> <span class="math inline">\(S\)</span> ，记为 <span class="math inline">\(a \notin S\)</span></p></li><li><p>设 <span class="math inline">\(S,T\)</span> 为两个集合，若 <span class="math inline">\(\forall a \in S\)</span> ，成立 <span class="math inline">\(a \in T\)</span> ，则称 <span class="math inline">\(S\)</span> 是 <span class="math inline">\(T\)</span> 的一个<strong>子集</strong>，记为 <span class="math inline">\(S \subset T\)</span></p></li><li><p>设 <span class="math inline">\(S,T\)</span> 为两个集合，若 <span class="math inline">\(S \subset T, T \subset S\)</span> ，则称 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> <strong>相等</strong>，记为 <span class="math inline">\(S=T\)</span></p></li><li><p>设 <span class="math inline">\(S,T\)</span> 为两个集合，将集合 <span class="math inline">\(\{ x \big| x \in S \land x \in T \}\)</span> 称为 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 的<strong>交集</strong>，记为 <span class="math inline">\(S \cap T\)</span> ；将集合 <span class="math inline">\(\{ x \big| x \in S \lor x \in T \}\)</span> 称为 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 的<strong>并集</strong>，记为 <span class="math inline">\(S \cup T\)</span></p><a id="more"></a></li><li><p>设 <span class="math inline">\(S,T\)</span> 为两个集合，将集合 <span class="math inline">\(\{ x \big| x \in S \land x \notin T \}\)</span> 称为 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 的<strong>差集</strong>，记为 <span class="math inline">\(S \setminus T\)</span></p></li><li><p>设 <span class="math inline">\(S,T\)</span> 为两个集合，若 <span class="math inline">\(T \subset S\)</span> ，则将集合 <span class="math inline">\(S \setminus T\)</span> 称为 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(S\)</span> 中的的<strong>补集</strong>，记为 <span class="math inline">\(\complement_S{T}\)</span></p></li><li><p>设 <span class="math inline">\(S,T\)</span> 为两个集合，则将集合 <span class="math inline">\(\{(x,y) \big| x \in S, y \in T\}\)</span> 称为 <span class="math inline">\(S\)</span> 与 <span class="math inline">\(T\)</span> 的<strong>笛卡尔积</strong> ，记为 <span class="math inline">\(S \times T\)</span> ；将 <span class="math inline">\(\underbrace{X \times X \times ... \times X}_{k个}\)</span> 简记为 <span class="math inline">\(X^k\)</span></p></li><li><p>设 <span class="math inline">\(S\)</span> 为一个集合，则将 <span class="math inline">\(S\)</span> 中元素的个数记为 <span class="math inline">\(S\)</span> 的<strong>基数</strong>，记为 <span class="math inline">\(|S|\)</span></p></li></ol><h1 id="基本性质">基本性质</h1><p><strong>1、（集合分配律）</strong>设 <span class="math inline">\(R,S,T\)</span> 为三个集合，则</p><p><strong>①</strong> <span class="math inline">\(R \cap (S \cup T)=(R \cap S) \cup (R \cap T)\)</span></p><p><strong>②</strong> <span class="math inline">\(R \cup (S \cap T) = (R \cup S) \cap (R \cup T)\)</span></p><p><strong>证明：①</strong> <span class="math inline">\(\forall x \in R \cap (S \cup T)\)</span></p><p><span class="math inline">\(\therefore x \in R\)</span> 且 <span class="math inline">\(x \in S \cup T\)</span></p><p><span class="math inline">\(\therefore\)</span> （ <span class="math inline">\(x \in R\)</span> 且 <span class="math inline">\(x \in S\)</span> ） 或 （ <span class="math inline">\(x \in R 且 x \in T\)</span> ）</p><p>$ x (R S) (R T)$</p><p><span class="math inline">\(\therefore\)</span> 由<strong>定义2</strong>可知， <span class="math inline">\(R \cap (S \cup T)\subset (R \cap S) \cup (R \cap T)\)</span></p><p>反之， <span class="math inline">\(\forall x \in (R \cap S) \cup (R \cap T)\)</span></p><p><span class="math inline">\(\therefore\)</span> <span class="math inline">\(x \in R \cap S\)</span> 或 <span class="math inline">\(x \in R \cap T\)</span></p><p><span class="math inline">\(\therefore x \in R\)</span> 且（ <span class="math inline">\(x \in S\)</span> 或 <span class="math inline">\(x \in T\)</span> ）</p><p><span class="math inline">\(\therefore\)</span> 由<strong>定义2</strong>可知，<span class="math inline">\((R \cap S) \cup (R \cap T) \subset R \cap (S \cup T)\)</span></p><p><span class="math inline">\(\therefore\)</span> 由<strong>定义3</strong>可知， <span class="math inline">\(R \cap (S \cup T)=(R \cap S) \cup (R \cap T)\)</span></p><p><strong>② 同理即可证得结论</strong></p><p><strong>2、</strong> 设 <span class="math inline">\(X,Y\)</span> 为两个集合，且 <span class="math inline">\(|X|=n,|Y|=m\)</span> ，则</p><p><strong>①</strong> <span class="math inline">\(|X \times Y|=n \cdot m\)</span></p><p><strong>②</strong> <span class="math inline">\(|X \cup Y|=n +m-|X \cap Y|\)</span></p>]]></content>
    
    
    <categories>
      
      <category>代数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mathematics</tag>
      
      <tag>Algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
