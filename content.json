{"meta":{"title":"GONGGONGJOHN's Blog","subtitle":"","description":"This is the private blog site of gonggongjohn","author":"GONGGONGJOHN","url":"http://gonggongjohn.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"《深入理解计算机系统》笔记整理（一）","slug":"csapp-01","date":"2020-10-07T14:31:17.000Z","updated":"2020-10-07T16:37:24.078Z","comments":true,"path":"2020/10/07/csapp-01/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/10/07/csapp-01/","excerpt":"","text":"Chapter 2：信息的表示和处理进制转换进位计数制定义：设一个 $m$ 进制下$w$ 位的位向量表示为 [a_{w-1}, a_{w-2}, ..., a_0]，则其表示的数为 $\\sum_\\limits{i=0}^{w-1} a_im^i$ $m$ 进制 $\\rightarrow$ 十进制设一个 $w$ 位 $m$ 进制整数的位相量表示为 \\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ] ，定义函数 $M2D(\\vec{x}) = \\sum_\\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\\vec{x})$ 证明：由进位计数制的定义可直接得到结论 Example: 将 $3$ 进制数 $12011$ 转为十进制数 解： 令 $\\vec{x} = [1,2,0,1,1], m = 3$ \\begin{align} \\therefore n = M2D(\\vec{x}) &= 1 \\cdot 3^4 + 2 \\cdot 3^3 + 1 \\cdot 3^1 +1 \\cdot 3^0 \\\\ &= 81+54+3+1 \\\\ &= 139 \\end{align} 十进制 $\\rightarrow$ $m$ 进制设一个十进制整数为 $n$，定义序列 \\begin{align} &p_0 = \\lfloor \\frac{n}{m} \\rfloor, \\ r_0 = n \\ \\ mod \\ \\ m \\\\ &p_1 = \\lfloor \\frac{p_0}{m}\\rfloor, \\ r_1 = p_0 \\ \\ mod \\ \\ m \\\\ &... \\\\ &p_{s-1} = \\lfloor \\frac{p_{s-2}}{m}\\rfloor = 0, \\ r_{s-1} = p_{s-2} \\ \\ mod \\ \\ m \\\\ \\end{align}则其对应的 $m$ 进制数的位向量表示为 \\vec{x} = [r_{s-1}, r_{s-2}, ..., r_0] 证明：设 $n$ 在 $m$ 进制下的位相量表示为 [r_{s-1}, r_{s-2}, ..., r_0] 则由定义可知，n = r_{s-1} \\cdot m^{s-1} + r_{s-2} \\cdot m^{s-2} + ...+ r_0 故 n = m \\cdot \\left( r_{s-1} \\cdot m^{s-2} + r_{s-2} \\cdot m^{s-3} + ... + r_1 \\right) + r_0 $\\therefore$ 由余数的定义可知，$r_0 = n \\ \\ mod \\ \\ m$ 又由 \\begin{align} p_0 = \\lfloor \\frac{n}{m} \\rfloor &= r_{s-1} \\cdot m^{s-2} + r_{s-2} \\cdot m^{s-3} + ... + r_1 \\\\ &= m \\cdot \\left( r_{s-1} \\cdot m^{s-3} + r_{s-2} \\cdot m^{s-4} + ... + r_2 \\right) + r_1 \\end{align}故 $r_1 = p_0 \\ \\ mod \\ \\ m$ 以此类推，r_{i} = p_{i-1} \\ \\ mod \\ \\ m \\ (i=s-2, ..., 1) 故结论成立 二进制无符号整数设一个数的二进制向量表示为 \\vec{x} = [x_{w-1}, x_{w-2},..., x_0]，则它的十进制表示为 B2U_w(x) = \\sum_\\limits{i = 0}^{w-1} x_i 2^i","categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.github.io/blog/tags/Computer-Science/"},{"name":"CSAPP","slug":"CSAPP","permalink":"http://gonggongjohn.github.io/blog/tags/CSAPP/"}]},{"title":"GDB使用指南","slug":"gdb-guide","date":"2020-09-19T04:24:40.000Z","updated":"2020-09-28T08:06:30.878Z","comments":true,"path":"2020/09/19/gdb-guide/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/09/19/gdb-guide/","excerpt":"GDB使用指南GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。 GDB官网：GDB: The GNU Project Debugger","text":"GDB使用指南GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。 GDB官网：GDB: The GNU Project Debugger GDB和LLDBLLDB是一款开源的具有REPL（Read-Evaluation-Print-Loop）特征的调试工具，相比GDB在部分场景下更加先进和高效。Xcode自4.3版本后默认内置了LLDB，因此macOS用户可以直接使用LLDB对程序进行调试。（当然macOS同样也可以安装GDB调试工具） GDB与LLDB命令对照表：GDB to LLDB command map WINDOWS下安装GCC和GDBMinGW（Minimalist GNU For Windows）是Windows下的一个小型GNU工具集。新版MinGW中集成了GCC和GDB的相关工具，因此只需安装MinGW即可使用GCC和GDB。 下载MinGW及GCC包首先前往MinGW官方网站：MinGW 并在Download界面下载MinGW管理工具。 安装MinGW管理工具并打开。 选择所需的工具集，点击左上角的Installation-&gt;Apply Changes即可安装。（由于受国内网络环境影响，可能会出现下载失败的情况，可以多尝试几次或使用其他网络连接方式下载）。若使用C/C++进行开发，通常仅需安装mingw32-base-bin及mingw32-gcc-g++-bin即可。 配置系统环境变量安装完成后，我们需要配置系统环境变量使得其可以在CMD中执行。 右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量，在系统变量框中找到Path变量，选择编辑，在最后新增一行填入你的MinGW安装路径\\bin，确定退出。 打开CMD，输入gcc -v及gdb -v，若显示相关版本信息，表明环境变量配置成功。 在其他IDE中调用GDBCLionCLion本身已经集成了十分完善的可视化调试工具，但如果想在CLion中使用GDB或LLDB调试程序同样十分方便。 使用通常的方法在需要的地方打上断点启动调试，在下方的Debug窗口中就可以看到GDB/LLDB窗口，在其中输入命令即可。 Visual Studio CodeVSCode本身并不自带GCC和GDB的相关功能，因此使用VSCode进行调试同样需要额外安装GDB/LLDB调试工具。不过，VSCode提供了一个可视化的C/C++调试插件，相比命令行调试会直观很多。该插件可直接在插件商店里搜索并安装。 和其他大型IDE类似，VSCode将一个目录视为一个项目，因此在创建项目时，你需要指定一个空的文件夹来存放项目文件（这也是一些人装了辅助插件却被提示要手动配置调试文件的一大重要原因）。在第一次运行程序时，选择Run-&gt;Start Debugging，在弹出的选项框中选择一个要使用的调试环境及编译环境，VSCode就会自动在当前的项目目录下创建相应的配置文件。（当然也可以手动指定配置文件，具体配置方法可参考VSCode官方文档） 随后即可在调试界面中看到相关的调试信息。你也可以在下方的Debug Console中输入相关的GDB/LLDB命令来进行进一步的调试。 GDB的基本使用启动调试若要使用GDB来调试程序，需要在使用GCC编译源文件的时候打开-g选项。 1gcc -g [源文件名] -o [目标文件名] Example: 1gcc -g test.c -o test 若不打开调试选项，则在调试时无法添加断点。 使用gdb打开生成的可执行文件即可开始调试。 1gdb [目标文件名] GDB还可以关联正在运行的程序进行调试。我们可以通过ps命令查询目标进程的PID，随后进入GDB使用attach命令关联进程。 123ps -ef|grep [进程名]gdb(gdb) attach [PID] Linux用户在这一过程过可能会遇到权限不足的情况。解决方法：切换至root用户，进入/etc/stsctl.d/10-ptrace.conf中将kernel.yama.ptrace_scpoe = 1改为kernel.yama.ptrace_scpoe = 0即可。 添加断点通常在调试过程中，我们需要在程序的某个位置添加断点，并让程序运行到这一位置时自动暂停以分析程序当前的运行状态。在GDB环境下，我们可以通过break命令来快速添加断点。 12(gdb) break [源文件名称]:[行号] #执行到某一行时中断(gdb) break [函数名] #执行到某个函数时中断 Example: 12(gdb) break test.c:5(gdb) break main 有时我们希望程序在特定条件下中断，这个时候我们可以使用break+if或condition语句来设置条件断点。 1(gdb) break [中断位置] if 触发条件 Example: 1(gdb) break test.c:10 if a==5 12(gdb) break [中断位置](gdb) condition [断点号] [触发条件] Example: 12(gdb) break test.c:10(gdb) condition 1 a==5 我们可以使用info指令查看已设置断点的断点号及相关信息 1(gdb) info breakpoints 通过clear和delete命令可以删除已创建的断点。 1234(gdb) clear [目标文件名]:[行号] #删除某一行处的断点(gdb) clear [函数名] #删除某个函数处的断点(gdb) delete #删除所有断点(gdb) delete [断点号] #删除某一特定断点 Example: 12(gdb) clear test:5(gdb) delete 1 运行程序对于不需要向main函数传递参数的程序，可以直接使用run指令开始运行程序。 1(gdb) run 对于需要向main函数传递参数的程序，可以使用set args指令或直接在run后跟参数的方式运行程序。 12(gdb) set args [参数](gdb) run Example: 12(gdb) set args para1 para2 para3(gdb) run 1(gdb) run [参数] Example: 1(gdb) run para1 para2 para3 程序运行后，会一直运行至第一个断点处并暂停。若没有设置断点，则效果等同于直接运行程序。 当程序中断后，GDB提供了以下几种继续运行的指令。 12345(gdb) next #单步执行（不进入函数内部，等同于Clion中的Step Over）(gdb) step #单步进入（进入函数内部，等同于Clion的Step Into）(gdb) continue #继续执行至下一个断点处(gdb) until [行号] #继续执行直至某一行(gdb) finish #运行至程序结尾 查看变量及内存在程序中断时，GDB提供了一系列指令来查看当前变量及内存中的各种信息。 通过print指令可以打印变量或表达式的值 1(gdb) print &#x27;[源文件名/函数名]&#x27;::[变量名/表达式] Example: 123(gdb) print &#x27;main&#x27;::a(gdb) print &#x27;test.c&#x27;::b(gdb) print &#x27;main&#x27;::*p 通过display命令可以使得每次程序中断时自动打印某个变量或表达式的值 1(gdb) display [变量名/表达式] 此外，我们还可以通过watch指令追踪某一变量，使其值发生改变时中断程序 1(gdb) watch [变量名] 通过backtrace指令可以查看函数调用栈的存储情况及相关信息。 1(gdb) backtrace 更多其他命令的详细用法，可以通过help指令查询 1(gdb) help [命令]","categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.github.io/blog/tags/Computer-Science/"},{"name":"Language","slug":"Language","permalink":"http://gonggongjohn.github.io/blog/tags/Language/"}]},{"title":"实数的严格定义","slug":"analysis-real-number","date":"2020-08-26T11:03:01.000Z","updated":"2020-08-27T02:39:10.000Z","comments":true,"path":"2020/08/26/analysis-real-number/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/08/26/analysis-real-number/","excerpt":"","text":"对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Analysis","slug":"Analysis","permalink":"http://gonggongjohn.github.io/blog/tags/Analysis/"}]},{"title":"代数概念整理：映射","slug":"algebra-projection","date":"2020-07-31T07:00:00.000Z","updated":"2020-09-23T02:33:28.611Z","comments":true,"path":"2020/07/31/algebra-projection/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/07/31/algebra-projection/","excerpt":"定义 设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个映射，记为 $f:X \\to Y$ ， $X$ 称为 $f$ 的定义域， $Y$ 称为 $f$ 的陪域 设 $f:X \\to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的象，记为 $f(a)$ ； $a$ 称为 $b$ 的原象，记为 $f^{-1}(b)$ ；集合 ${f(x) \\big| x \\in X}$ 称为 $f$ 的值域或 $f$ 的象，记为$f(X)$ 或 $Imf$ 设 $f:X \\to Y$ 为一映射，若 $\\forall x_1 \\neq x_2 \\in X, f(x_1) \\neq f(x_2)$ ，则称 $f$ 为一个单射 设 $f:X \\to Y$ 为一映射，若 $\\forall y \\in Y, \\exists x \\in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个满射","text":"定义 设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个映射，记为 $f:X \\to Y$ ， $X$ 称为 $f$ 的定义域， $Y$ 称为 $f$ 的陪域 设 $f:X \\to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的象，记为 $f(a)$ ； $a$ 称为 $b$ 的原象，记为 $f^{-1}(b)$ ；集合 ${f(x) \\big| x \\in X}$ 称为 $f$ 的值域或 $f$ 的象，记为$f(X)$ 或 $Imf$ 设 $f:X \\to Y$ 为一映射，若 $\\forall x_1 \\neq x_2 \\in X, f(x_1) \\neq f(x_2)$ ，则称 $f$ 为一个单射 设 $f:X \\to Y$ 为一映射，若 $\\forall y \\in Y, \\exists x \\in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个满射 设 $f:X \\to Y$ 为一映射，若 $f$ 即是单射又是满射，则称 $f$ 为一个双射 设 $f: X \\to Y$ 为一映射，若 $Y=X$ ，且 $\\forall x \\in X, f(x) = x$ ，则称 $f$ 为一个恒等映射，记为 $Id_X$ 或 $e_X$ 设 $f: A \\to C, g: B \\to D$ 为两个映射，若 $A = B,C=D$ ，且 $\\forall x \\in A, f(x)=g(x)$ ，则称映射 $f$ 与 $g$ 相等 设 $f: X \\to Y, g: Y \\to Z$ 为两个映射，则由法则 $(g \\circ f)(x) = g(f(x))$ 定义的映射称为 $f$ 与 $g$ 的合成，记为 $g \\circ f: X \\to Z$ 或 $gf: X \\to Z$ 设 $f:X \\to Y,g: Y \\to X$ 为两个映射，若 $g \\circ f = e_X$ ，则称 $g$ 为 $f$ 的左逆， $f$ 为 $g$ 的右逆；若 $g \\circ f = e_X,f \\circ g = e_Y$ ,则称 $g$ 为 $f$ 的双边逆或逆 基本性质1、（映射的合成律） 设 $f: X \\to Y, g: Y \\to Z, h: Z \\to W$ 为三个映射，则 $h(gf)=(hg)f$ 证明： 对于 $ h(gf) $ ，$(X \\to Y \\to Z) \\to W=X \\to W$ ；对于 $(hg)f$ ，$X \\to (Y \\to Z \\to W)=X \\to W$ $\\therefore$ $h(gf)$ 与 $(hg)f$ 的定义域及陪域相同 $\\forall x \\in X$ ，由定义8可知 $(h(gf))(x)=h((gf)(x))=h(g(f(x)))=(hg)(f(x))=((hg)f)(x)$ $\\therefore$ 由定义7可知，$h(gf)=(hg)f$","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Algebra","slug":"Algebra","permalink":"http://gonggongjohn.github.io/blog/tags/Algebra/"}]},{"title":"代数概念整理：集合","slug":"algebra-set","date":"2020-07-30T07:31:34.000Z","updated":"2020-09-23T02:33:11.219Z","comments":true,"path":"2020/07/30/algebra-set/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/07/30/algebra-set/","excerpt":"定义 若 $a$ 为 $S$ 中的一个元素，则称 $a$ 包含于 $S$ ，记为 $a \\in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ 不包含于 $S$ ，记为 $a \\notin S$ 设 $S,T$ 为两个集合，若 $\\forall a \\in S$ ，成立 $a \\in T$ ，则称 $S$ 是 $T$ 的一个子集，记为 $S \\subset T$ 设 $S,T$ 为两个集合，若 $S \\subset T, T \\subset S$ ，则称 $S$ 与 $T$ 相等，记为 $S=T$ 设 $S,T$ 为两个集合，将集合 ${ x \\big| x \\in S \\land x \\in T }$ 称为 $S$ 与 $T$ 的交集，记为 $S \\cap T$ ；将集合 ${ x \\big| x \\in S \\lor x \\in T }$ 称为 $S$ 与 $T$ 的并集，记为 $S \\cup T$","text":"定义 若 $a$ 为 $S$ 中的一个元素，则称 $a$ 包含于 $S$ ，记为 $a \\in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ 不包含于 $S$ ，记为 $a \\notin S$ 设 $S,T$ 为两个集合，若 $\\forall a \\in S$ ，成立 $a \\in T$ ，则称 $S$ 是 $T$ 的一个子集，记为 $S \\subset T$ 设 $S,T$ 为两个集合，若 $S \\subset T, T \\subset S$ ，则称 $S$ 与 $T$ 相等，记为 $S=T$ 设 $S,T$ 为两个集合，将集合 ${ x \\big| x \\in S \\land x \\in T }$ 称为 $S$ 与 $T$ 的交集，记为 $S \\cap T$ ；将集合 ${ x \\big| x \\in S \\lor x \\in T }$ 称为 $S$ 与 $T$ 的并集，记为 $S \\cup T$ 设 $S,T$ 为两个集合，将集合 ${ x \\big| x \\in S \\land x \\notin T }$ 称为 $S$ 与 $T$ 的差集，记为 $S \\setminus T$ 设 $S,T$ 为两个集合，若 $T \\subset S$ ，则将集合 $S \\setminus T$ 称为 $T$ 在 $S$ 中的的补集，记为 $\\complement_S{T}$ 设 $S,T$ 为两个集合，则将集合 ${(x,y) \\big| x \\in S, y \\in T}$ 称为 $S$ 与 $T$ 的笛卡尔积 ，记为 $S \\times T$ ；将 $\\underbrace{X \\times X \\times … \\times X}_{k个}$ 简记为 $X^k$ 设 $S$ 为一个集合，则将 $S$ 中元素的个数记为 $S$ 的基数，记为 $|S|$ 基本性质1、（集合分配律）设 $R,S,T$ 为三个集合，则 ① $R \\cap (S \\cup T)=(R \\cap S) \\cup (R \\cap T)$ ② $R \\cup (S \\cap T) = (R \\cup S) \\cap (R \\cup T)$ 证明：① $\\forall x \\in R \\cap (S \\cup T)$ $\\therefore x \\in R$ 且 $x \\in S \\cup T$ $\\therefore$ （ $x \\in R$ 且 $x \\in S$ ） 或 （ $x \\in R 且 x \\in T$ ） $ \\therefore x \\in (R \\cap S) \\cup (R \\cap T)$ $\\therefore$ 由定义2可知， $R \\cap (S \\cup T)\\subset (R \\cap S) \\cup (R \\cap T)$ 反之， $\\forall x \\in (R \\cap S) \\cup (R \\cap T)$ $\\therefore$ $x \\in R \\cap S$ 或 $x \\in R \\cap T$ $\\therefore x \\in R$ 且（ $x \\in S$ 或 $x \\in T$ ） $\\therefore$ 由定义2可知，$(R \\cap S) \\cup (R \\cap T) \\subset R \\cap (S \\cup T)$ $\\therefore$ 由定义3可知， $R \\cap (S \\cup T)=(R \\cap S) \\cup (R \\cap T)$ ② 同理即可证得结论 2、 设 $X,Y$ 为两个集合，且 $|X|=n,|Y|=m$ ，则 ① $|X \\times Y|=n \\cdot m$ ② $|X \\cup Y|=n +m-|X \\cap Y|$","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Algebra","slug":"Algebra","permalink":"http://gonggongjohn.github.io/blog/tags/Algebra/"}]}],"categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.github.io/blog/tags/Computer-Science/"},{"name":"CSAPP","slug":"CSAPP","permalink":"http://gonggongjohn.github.io/blog/tags/CSAPP/"},{"name":"Language","slug":"Language","permalink":"http://gonggongjohn.github.io/blog/tags/Language/"},{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Analysis","slug":"Analysis","permalink":"http://gonggongjohn.github.io/blog/tags/Analysis/"},{"name":"Algebra","slug":"Algebra","permalink":"http://gonggongjohn.github.io/blog/tags/Algebra/"}]}