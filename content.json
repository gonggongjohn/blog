{"meta":{"title":"GONGGONGJOHN's Blog","subtitle":"","description":"A sophomore student major in Data Science.","author":"GONGGONGJOHN","url":"http://gonggongjohn.me","root":"/"},"pages":[{"title":"categories","date":"2021-01-21T07:04:43.000Z","updated":"2021-01-21T07:06:55.172Z","comments":true,"path":"categories/index.html","permalink":"http://gonggongjohn.me/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2021-01-21T06:39:15.000Z","updated":"2021-01-21T06:58:05.434Z","comments":true,"path":"about/index.html","permalink":"http://gonggongjohn.me/about/index.html","excerpt":"","text":"I’m currently a sophomore undergraduate student major in Data Science &amp; Engineering. This blog is kind of an academic record of things I have learned or explored in Computer Science and Mathematics. Major courses I took in the past one and a half years: Mathematical Analysis I (Fall 2019) Mathematical Analysis II (Spring 2020) Advanced Algebra &amp; Analytic Geometry I (Fall 2019) Advanced Algebra &amp; Analytic Geometry II (Spring 2020) Computer Systems &amp; Cloud Computing (Fall 2020) Algorithm Design &amp; Analysis (Fall 2020) Professional English (Fall 2020) Introduction to Data Science and Engineering (Fall 2020) Cloud Computing Applications and Development (Fall 2020) Several courses I’m working on currently: Probability and Mathematical Statistics Discrete Mathematics Abstract Algebra &amp; Matrix Analysis Machine Learning"}],"posts":[{"title":"实数集不可数的证明","slug":"real-number-uncountability","date":"2021-02-27T14:37:37.000Z","updated":"2021-02-27T14:38:48.142Z","comments":true,"path":"2021/02/27/real-number-uncountability/","link":"","permalink":"http://gonggongjohn.me/2021/02/27/real-number-uncountability/","excerpt":"实数集是不可数集这一结论的证明是近代集合论研究的一大重要标志。随着近代分析学的发展，这一结论可以从许多不同的角度推导而出。这些方法融合了许多重要的分析思想及数学技巧，在此进行一个简单的整理和总结。","text":"实数集是不可数集这一结论的证明是近代集合论研究的一大重要标志。随着近代分析学的发展，这一结论可以从许多不同的角度推导而出。这些方法融合了许多重要的分析思想及数学技巧，在此进行一个简单的整理和总结。 Theorem: 实数集 \\mathbb{R} 不可数 对角线法若 \\mathbb{R} 可数，则区间 [0,1] \\subset \\mathbb{R} 必然可数 因此必然可以使用十进制表示法将 [0,1] 中的每一个数一一列出： r_1 = 0.d_{11} d_{12} d_{13} d_{14} ... \\\\ r_2 = 0.d_{21} d_{22} d_{23} d_{24} ... \\\\ r_3 = 0.d_{31} d_{32} d_{33} d_{34} ... \\\\ r_4 = 0.d_{41} d_{42} d_{43} d_{44} ... \\\\ ...其中 d_{ij} \\in \\{0, 1, 2, ..., 9\\} 现构造一新的实数 r = 0.d_1 d_2 d_3 d_4 ...，使得 d_i = \\left\\{ \\begin{aligned} 4, \\ if \\ d_{ii} \\neq 4 \\\\ 5, \\ if \\ d_{ii} = 4 \\end{aligned} \\right.显然 r \\in [0, 1] 而由于对任意 i \\in \\mathbb{N}^+，r 与 r_i 的第 i 位数字均不相同，因此 r \\neq r_i 由此我们构造出了一个未被列出的实数，这与 [0,1] 中的每一个数均可被列出矛盾 故 [0,1] 为不可数集，进而可知 \\mathbb{R} 为不可数集。 区间套法 Lemma: 若 \\{[a_n, b_n]\\} 形成一闭区间套，则存在唯一的实数 \\xi 属于所有的闭区间 [a_n, b_n]，且 \\xi = \\lim_\\limits{n \\to \\infty} a_n = \\lim_\\limits{n \\to \\infty} b_n 若 \\mathbb{R} 可数，则区间 [0,1] \\subset \\mathbb{R} 必然可数 因此我们可将 [0,1] 写为一数列 r_1, r_2, ...,r_n,... 现将 [0,1] 三等分，则必存在某个区间 [a_1, b_1] \\subset [0,1]，使得 r_1 \\notin [a_1, b_1] 接着继续将 [a_1, b_1] 三等分，则必存在某一子区间 [a_2, b_2] \\subset [a_1, b_1]，使得 r_2 \\notin [a_2, b_2] 如此进行下去，可得一闭区间套 \\{[a_n, b_n]\\}，且满足对任意 i \\in \\mathbb{N^+}，有 r_i \\notin [a_i, b_i] 故由闭区间套定理可知，存在 \\xi \\in \\mathbb{R}，使得对任意 n \\in \\mathbb{N^+}，有 \\xi \\in [a_n, b_n] 于是存在 \\xi \\in [0,1]，使得对任意 i \\in \\mathbb{R}^+，有 \\xi \\neq r_i，与 [0,1] 中每一个数均可被列出矛盾 故 [0,1] 为不可数集，进而可知 \\mathbb{R} 为不可数集。 外测度法对于 \\mathbb{R} 上的任意闭区间 I=[a,b]，其体积 V(I)=b-a 故由外测度定义 m(S) = \\inf \\{ \\sum_{i=1}^\\infty V(I_i) \\big| S \\subset \\bigcup_{i \\in \\mathbb{N}} I_i \\}可知 m(I) = b-a 而对任意可数集 S，m(S) = 0 因此 \\mathbb{R} 不可数 Baire纲定理 Lemma: 设 (X, d) 是一个完备的度量空间，则 若 (F_n)_{n=0}^\\infty 是一列无处稠密的闭集，则它的并的内部是空的 若 (O_n))_{n=0}^\\infty 是一列在 X 中稠密的开集，则它的交在也 X 中稠密 Baire纲定理指出，一个完备的度量空间不能写成可数个无处稠密的集合的并 由于 \\mathbb{R} 是完备的，且在其上有自然度量 d(x,y) = |x-y|，因此其为一个完备的度量空间 若 \\mathbb{R} 可数，则其可以表示为可数个单点集的并，而单点集的闭包即为它本身，也即是无处稠密的 这与Baire纲定理矛盾，因此 \\mathbb{R} 必不可数","categories":[{"name":"分析学","slug":"分析学","permalink":"http://gonggongjohn.me/categories/%E5%88%86%E6%9E%90%E5%AD%A6/"}],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.me/tags/Mathematics/"},{"name":"Analysis","slug":"Analysis","permalink":"http://gonggongjohn.me/tags/Analysis/"}]},{"title":"Data Lab实验记录","slug":"csapp-datalab","date":"2021-01-30T14:15:21.000Z","updated":"2021-02-01T06:30:16.415Z","comments":true,"path":"2021/01/30/csapp-datalab/","link":"","permalink":"http://gonggongjohn.me/2021/01/30/csapp-datalab/","excerpt":"Data Lab要求我们在有一系列运算限制的情况下实现某些运算操作，从而尽可能的开发位运算的作用。这个Lab中的绝大部分内容的技巧性都比较强，可以阅读《算法心得：高效算法的奥秘》一书作为参考。","text":"Data Lab要求我们在有一系列运算限制的情况下实现某些运算操作，从而尽可能的开发位运算的作用。这个Lab中的绝大部分内容的技巧性都比较强，可以阅读《算法心得：高效算法的奥秘》一书作为参考。 概述在Lab中的bits.c文件内描述了一系列规则和我们需要实现的函数。具体来说，我们需要实现以下几个函数： bitAnd：按位与 getByte：从一个二进制整数中提取某个Byte（8位） logicalShift：逻辑右移 bitCount：计算一个二进制整数中1的位数 bang：逻辑取反 tmin：最小的补码能表示的int型整数 fitsBits：判断某个整数能否用n位补码表示 divpwr2：计算 \\frac{x}{2^n} 并向0取整 negate：取相反数 isPositive：判断某个数是否为正数 isLessOrEqual：判断x是否小于等于y ilog2：计算 \\lfloor \\log_2 x \\rfloor float_neg：在float型表示下取相反数 float_i2f：将int型表示转为float型表示 float_twice：在float型表示下计算 2*x 对于上面这些函数，我们一般只能使用以下几种运算操作： 逻辑取反（!），按位取反（~），按位与（&amp;），按位异或（^），按位或（|），加法（+），左移（&lt;&lt;），算数右移（&gt;&gt;） 在此基础之上，其中某些函数还有进一步的限制要求： bitAnd：只允许使用按位取反（~）和按位或（|）操作 bang：不允许使用逻辑取反（!）操作 float_neg/float_i2f/float_twice：允许使用一切整数操作、逻辑与（&amp;&amp;）、逻辑或（||）、if语句及while语句 Lab中提供了两种工具来帮助我们检查实现是否正确： 12&gt; ./dlc -e bits.c # 检查函数实现中操作是否符合要求&gt; ./driver.pl # 检查函数实现是否正确 具体实现bitAnd由De Morgan律可知 \\neg (P \\land Q) = (\\neg P) \\lor (\\neg Q) 故 P \\land Q = \\neg ((\\neg P) \\lor (\\neg Q)) 123int bitAnd(int x, int y) &#123; return ~(~x | ~y);&#125; 一行代码搞定。 getByte采用掩码的思想，要提取某个Byte的数值并屏蔽其他位的值，可以将目标位移动到最小的8位并将其和0xFF做按位与运算。观察输入的参数，要提取 x 中的第 n 个Byte，就要将 x 向右移动 8*n 位。使用位运算操作的话，也即x&gt;&gt;(n&lt;&lt;3)。 123int getByte(int x, int n) &#123; return (x&gt;&gt;(n&lt;&lt;3)) &amp; 0xFF;&#125; 同样可以一行搞定。 logicalShift算数右移和逻辑右移的区别在于，算数右移会在高位填充最高位的值，而逻辑右移则不会，因此一个基本的思路就是使用算数右移后屏蔽掉高位的值，于是问题便转化为如何构造掩码。 我们的掩码要保证原数最高位之前均为0，最高位之后均为1。而利用算数右移会填充最高位的特性，我们可以将0x1移动到最高位，随后算数右移到目标位置，再取反即可满足要求，问题也迎刃而解。 123int logicalShift(int x, int n) &#123; return (x&gt;&gt;n)&amp;(~((0x01&lt;&lt;31)&gt;&gt;n&lt;&lt;1));&#125; bitCount利用位运算统计一个字中1的个数是一个技巧性十分强的算法。它的主要思想是分治法（Divide And Conquer），将统计整个字中1的个数的问题转化为多个统计更小区间内1的个数的问题。具体来说，一个32位的整数中，我们可以将其划分为两个16位的区间，进而划分为4个8位的区间，再划分为8个4位的区间，最后划分为16个2位的区间，因此我们仅需要统计每两位中1的个数，再将结果逐步合并即可得到整个数中1的个数。 对于统计每2位中1的个数，我们同样可以采用掩码的思想，先对两位中第一位和0x1做与运算，再将整个数右移一位与0x1做与运算，将两个结果相加即可统计出这两位中1的个数。 此外，由于题目中规定不能使用超过0xFF的十六进制数，我们需要通过多步位移的方法来构造出我们想要的的掩码。 1234567891011121314151617int bitCount(int x) &#123; int cnt; int maskt1 = (0x55) | (0x55&lt;&lt;8); int maskt2 = (0x33) | (0x33&lt;&lt;8); int maskt3 = (0x0F) | (0x0F&lt;&lt;8); int mask1 = (maskt1) | (maskt1&lt;&lt;16); int mask2 = (maskt2) | (maskt2&lt;&lt;16); int mask3 = (maskt3) | (maskt3&lt;&lt;16); int mask4 = (0xFF) | (0xFF&lt;&lt;16); int mask5 = (0xFF) | (0xFF&lt;&lt;8); cnt = (x &amp; mask1) + ((x&gt;&gt;1) &amp; mask1); cnt = (cnt &amp; mask2) + ((cnt&gt;&gt;2) &amp; mask2); cnt = (cnt &amp; mask3) + ((cnt&gt;&gt;4) &amp; mask3); cnt = (cnt &amp; mask4) + ((cnt&gt;&gt;8) &amp; mask4); cnt = (cnt &amp; mask5) + ((cnt&gt;&gt;16) &amp; mask5); return cnt;&#125; negate在补码表示中，对一个二进制表示下 n 位的整数 x 取相反数相当于做运算 2^n-x，而 (2^n-1)-x 相当于对x按位取反，因此总的位运算表示即为~x+1 123int negate(int x) &#123; return ~x+1;&#125; bang逻辑取反操作即是要让0变为1，除0以外的任何数变为0，因此我们需要找到一个把0和其他数分开的位运算特性。利用补码表示中负数的最高位始终为1的特性，我们可以发现让一个数和它在补码下的相反数做按位或运算时，如果这个数不为0，那么它的最高位始终为1，而由于0的补码还是0，因此最高位为0。于是利用上一题的结论，我们就能得到最终的运算操作。 123int bang(int x) &#123; return ((x|(~x+1))&gt;&gt;31)+1;&#125; tmin在模的剩余系下，最靠近中间的数即为离边界距离最远的数。利用这一特性可知补码表示下最小的负数最高位为1，其余全为0。 123int tmin(void) &#123; return 0x1&lt;&lt;31;&#125; fitsBits如果一个数能用n为补码表示，那么取它的后n位做符号扩展到原来的长度后值应与原来一样。利用逻辑右移的特性，我们只需要将x与x&lt;&lt;(32 - n)&gt;&gt;(32 - n)相比较即可。利用位运算取相反数的结论，以及异或运算的性质 x \\oplus x = 0，即可得到最终的运算操作。 1234int fitsBits(int x, int n) &#123; int shift = 32 + ~n + 1; return !(x^((x&lt;&lt;shift)&gt;&gt;shift));&#125; divpwr2要计算 \\frac{x}{2^n} 并向0取整，因此我们需要分类讨论。当 x \\geq 0 时，这一操作相当于x&gt;&gt;n；而当 x0)，有 \\lceil \\frac{x}{y} \\rceil = \\lfloor \\frac{x+y-1}{y} \\rfloor 由此可知对于负数，我们只需将其加上一个偏置 2^n -1，即可将结果变为向上取整。因此当 x","categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://gonggongjohn.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"Computer-System","slug":"Computer-System","permalink":"http://gonggongjohn.me/tags/Computer-System/"}]},{"title":"Malloc Lab实验记录","slug":"csapp-malloclab","date":"2021-01-30T14:15:13.000Z","updated":"2021-01-31T10:13:55.469Z","comments":true,"path":"2021/01/30/csapp-malloclab/","link":"","permalink":"http://gonggongjohn.me/2021/01/30/csapp-malloclab/","excerpt":"Malloc Lab要求我们利用CSAPP中9.9节所介绍的技术设计一个简单的动态内存分配器，并且尽可能的使得分配效率最高且空间利用率最大。一个基本的思路便是先构建一个内存分配器的框架，并在此基础上不断优化使得效率和空间使用率均相对达到最优。","text":"Malloc Lab要求我们利用CSAPP中9.9节所介绍的技术设计一个简单的动态内存分配器，并且尽可能的使得分配效率最高且空间利用率最大。一个基本的思路便是先构建一个内存分配器的框架，并在此基础上不断优化使得效率和空间使用率均相对达到最优。 概览首先我们来看一下Lab的基本情况。在Lab的mm.c文件中提供了一个最简单的动态内存分配器，我们需要实现以下四个函数以实现更加高效紧凑的内存分配： mm_init：初始化堆 mm_malloc：在堆中申请一段空间 mm_free：在堆中释放一段之前申请的空间 mm_realloc：重新调整之前申请的空间大小 为了方便起见，Lab在memlib.c中为我们提供了一些封装好的基础函数可供我们调用： mem_sbrk：改变堆大小（仅能扩张堆） mem_heap_lo：返回指向堆首的指针 mem_heap_hi：返回指向堆尾的指针 mem_heapsize：返回当前的堆大小 mem_pagesize：返回系统页大小 我们可以使用Lab为我们提供的mdriver工具装载预先设计好的Trace文件测试我们的内存分配器效率和空间使用率： 1&gt; ./mdriver -V -f shortX-bal.rep # X代表Trace文件编号 基本功能宏定义首先我们仿照CSAPP中9.9.12的例子定义一组宏以方便后续的使用： 1234567891011121314151617181920212223242526#define WSIZE 4 //字大小（Bytes）#define DSIZE 8 //双字大小（Bytes）#define CHUNKSIZE (1&lt;&lt;12) //扩展堆的最小大小（Bytes）#define MAX(x,y) ((x) &gt; (y)? (x):(y)) //求二者最大值//将块大小和使用标识符组合进一个字中#define PACK(size,alloc) ((size) | (alloc))//将任意指针转为一个字指针#define GET(p) (*(unsigned int *)(p))//在指针位置放入长度为一个字的值#define PUT(p,val) (*(unsigned int *)(p)=(val))//将任意指针转为通用指针#define GET_ADDRESS(p) (*(void **)(p))//从头部获取块大小#define GET_SIZE(p) (GET(p) &amp; ~0x7)//从头部获取使用标识符#define GET_ALLOC(p) (GET(p) &amp; 0x1)//计算块头部位置#define HDRP(bp) ((char *)(bp)-WSIZE)//计算块尾部位置#define FTRP(bp) ((char *)(bp)+ GET_SIZE(HDRP(bp))-DSIZE)//计算有效载荷大小#define GET_PAYLOAD(bp) (GET_SIZE(HDRP(bp))-DSIZE) //计算后一个块的位置#define NEXT_BLKP(bp) ((char *)(bp)+GET_SIZE(((char *)(bp)-WSIZE)))//计算前一个块的位置#define PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(((char *)(bp)-DSIZE))) 堆初始化堆初始化的一个基本作用就是向内存系统申请一块初始空间并标识为空闲状态。不过我们会发现，这一行为和后续当需要额外向系统申请新的空间时的行为完全相同，因此我们可以将这一逻辑封装为一个单独的函数： 12345678910111213141516static void *extend_heap(size_t words)&#123; char *bp; //新空间的起始指针 size_t size; //向上对齐为双字的倍数 size=(words %2)? (words+1)*WSIZE: words*WSIZE; //向系统申请空间 if((long)(bp = mem_sbrk(size)) == -1) return NULL; //设置块头部 PUT(HDRP(bp),PACK(size,0)); //设置块尾部 PUT(FTRP(bp),PACK(size,0)); return (void *)bp;&#125; 于是初始化函数可以被写成这样： 12345678int mm_init(void)&#123; if(extend_heap(CHUNKSIZE/WSIZE)==NULL) &#123; return -1; &#125; return 0;&#125; 申请空间现在我们来考虑如何响应用户的空间申请。由于堆需要保持双字对其，我们必须将用户的申请要求向上对齐为双字大小。而由于一个块还需要额外的双字空间用于存放块头部和块尾部，因此一次申请的空间必须为四字以上。随后我们需要找到合适的位置分配给用户的这一申请，由于后续我们需要不断优化分配的算法，因此我们将这一过程单独封装。此外，如果当前堆中找不到合适的位置分配给用户，我们还需要申请额外的空间以满足用户的需求。于是空间申请函数的基本构架就可以写成这样： 12345678910111213141516171819202122232425262728293031void *mm_malloc(size_t size)&#123; size_t asize; //实际分配的大小 size_t extendsize; //扩展堆大小 char *bp; //申请空间大小为0的情况 if(size==0) &#123; return NULL; &#125; //向上对齐 if(size&lt;=DSIZE) asize=2*DSIZE; else asize=DSIZE*((size+(DSIZE)+(DSIZE-1))/DSIZE); //寻找合适的位置并分配空间 if((bp=find_fit(asize))!=NULL) &#123; place(bp,asize); return bp; &#125; //当空间不够使扩展堆大小 extendsize = MAX(asize, CHUNKSIZE); if((bp=extend_heap(extendsize/WSIZE))==NULL) &#123; return NULL; &#125; //分配空间 place(bp,asize); return bp;&#125; 释放空间释放空间本质上就是把块头部的使用标识符从已使用改为空闲状态，因此我们可以快速实现出这一函数： 12345678void mm_free(void *ptr)&#123; size_t size=GET_SIZE(HDRP(ptr)); //块大小 //将头部设置为空闲状态 PUT(HDRP(ptr),PACK(size,0)); //将尾部设置为空闲状态 PUT(FTRP(ptr),PACK(size,0));&#125; 不过进一步思考我们会发现，当有多个连续的空闲块时，我们需要在释放时将其合并。由于空闲块可能在新释放的块之前或之后，因此我们需要讨论所有情况： 1234567891011121314151617181920212223242526272829303132333435static void *coalesce(void *bp)&#123; size_t prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp))); //前一个块是否空闲 size_t next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp))); //后一个块是否空闲 size_t size=GET_SIZE(HDRP(bp)); //块大小 //前后都不空闲 if(prev_alloc &amp;&amp; next_alloc) &#123; return bp; &#125; //前一个块空闲 else if(prev_alloc &amp;&amp; !next_alloc) &#123; size+=GET_SIZE(HDRP(NEXT_BLKP(bp))); PUT(HDRP(bp),PACK(size,0)); PUT(FTRP(bp),PACK(size,0)); return bp; &#125; //后一个块空闲 else if(!prev_alloc &amp;&amp; next_alloc) &#123; size+=GET_SIZE(FTRP(PREV_BLKP(bp))); PUT(FTRP(bp),PACK(size,0)); PUT(HDRP(PREV_BLKP(bp)),PACK(size,0)); return PREV_BLKP(bp); &#125; //前后都空闲 else &#123; size+=(GET_SIZE(HDRP(NEXT_BLKP(bp)))+GET_SIZE(FTRP(PREV_BLKP(bp)))); PUT(FTRP(NEXT_BLKP(bp)),PACK(size,0)); PUT(HDRP(PREV_BLKP(bp)),PACK(size,0)); return PREV_BLKP(bp); &#125;&#125; 在合并的过程中，我们还需要考虑遇到堆的前后边界时的情况。我们可以利用CSAPP中介绍的通过在堆首和堆尾引入首位块的方法规避这一问题： 1234567891011121314151617int mm_init(void)&#123; //申请空间存放首位块 if((head_listp = mem_sbrk(4*WSIZE)) == (void *)-1) return -1; //填充 PUT(head_listp,0); //序言块首 PUT(head_listp+(1*WSIZE),PACK(DSIZE,1)); //序言块尾 PUT(head_listp+(2*WSIZE),PACK(DSIZE,1)); //结尾块首 PUT(head_listp+(3*WSIZE),PACK(0,1)); //堆首指针指向序言块 head_listp += (2*WSIZE); ...&#125; 此外，在扩展堆大小的时候，我们也需要考虑到合并的情况： 12345static void *extend_heap(size_t words)&#123; ... return coalesce(bp);&#125; 调整空间大小当用户需要调整空间的大小时，我们需要考虑所有可能的情况。如果这一行为相当于申请更大的空间，我们可以先使用合并空闲块的思想将前后的空闲块合并进来，当合并后的空间大小还不够时，我们就需要重新在堆中申请一块更大的空间，并将原本空间中的数据复制过去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107void *mm_realloc(void *ptr, size_t size)&#123; //如果没有原始位置，相当于申请一块新的空间 if(ptr==NULL) return mm_malloc(size); //如果新空间大小为0，相当于释放原本的空间 if(size==0) &#123; mm_free(ptr); return ptr; &#125; size_t asize=0; //实际分配大小 //对齐处理 if(size&lt;=DSIZE) asize=2*DSIZE; else asize=DSIZE*((size+(DSIZE)+(DSIZE-1))/DSIZE); if(ptr!=NULL) &#123; size_t oldsize=GET_PAYLOAD(ptr); //获取原本的有效载荷大小 //原本大小小于新申请空间的大小 if(oldsize&lt;size) &#123; void* newptr=recoalesce(ptr,asize); //尝试合并前后块 //合并空间无法满足需求，申请额外的空间 if(newptr==NULL) &#123; newptr=mm_malloc(asize); //申请新空间 memcpy(newptr,ptr,oldsize); //复制数据 mm_free(ptr); //释放原空间 return newptr; &#125; //合并后空间能够满足需求 else &#123; return newptr; &#125; &#125; //原本大小和新空间大小一致 else if(oldsize==size) &#123; return ptr; &#125; //原本大小大于新空间大小 else &#123; return ptr; &#125; &#125; return NULL;&#125;//合并前后空闲块static void *recoalesce(void *bp,size_t needsize)&#123; size_t prev_alloc=GET_ALLOC(FTRP(PREV_BLKP(bp))); //前一个块是否空闲 size_t next_alloc=GET_ALLOC(HDRP(NEXT_BLKP(bp))); //后一个块是否空闲 size_t size=GET_SIZE(HDRP(bp)); //当前块大小 //前后都不空闲 if(prev_alloc &amp;&amp; next_alloc) &#123; return NULL; &#125; //后一个块空闲 else if(prev_alloc &amp;&amp; !next_alloc) &#123; size += GET_SIZE(HDRP(NEXT_BLKP(bp))); //合并后一个块后的大小 if(size&lt;needsize) return NULL; else &#123; PUT(HDRP(bp),PACK(size,1)); PUT(FTRP(bp),PACK(size,1)); return bp; &#125; &#125; //前一个块空闲 else if(!prev_alloc &amp;&amp; next_alloc) &#123; size += GET_SIZE(HDRP(PREV_BLKP(bp))); if(size&lt;needsize) return NULL; else &#123; size_t thissize=GET_PAYLOAD(bp); //当前有效载荷大小 void* prev_point=PREV_BLKP(bp); //前一个块的位置 PUT(FTRP(bp),PACK(size,1)); PUT(HDRP(prev_point),PACK(size,1)); memcpy(prev_point,bp,thissize); //向前复制数据 return prev_point; &#125; &#125; //前后都空闲 else &#123; size += (GET_SIZE(HDRP(NEXT_BLKP(bp)))+GET_SIZE(FTRP(PREV_BLKP(bp)))); if(size&lt;needsize) return NULL; else &#123; size_t thissize=GET_PAYLOAD(bp); void* prev_point=PREV_BLKP(bp); PUT(FTRP(NEXT_BLKP(bp)),PACK(size,1)); PUT(HDRP(PREV_BLKP(bp)),PACK(size,1)); memcpy(prev_point,bp,thissize); return prev_point; &#125; &#125;&#125; 性能优化前面我们使用隐式链表的方式实现了内存分配器的基本逻辑。但以这种方式实现的内存分配器效率极低且会产生大量的外部碎片，因此我们需要对其逐步优化。 显式分离存储在使用隐式链表存储块信息的情况下，搜索一个空闲块的平均时间复杂度为 \\mathcal{O}(n)，当块的数量很大或空闲块分布较为稀疏时，搜索效率就会变得极低。如果我们显式地将空闲块连在一起，搜索效率会得到一定的提高，然而，每当我们需要释放一段空间时，就需要在空闲链表中搜索合适的位置放置新的空闲块，这一操作有可能使得总时间复杂度再次退化到 \\mathcal{O}(n)，因此我们还需要使用CSAPP中介绍的分离链表的方式存储不同规模的空闲块。我们可以按照2的幂来划分每个空闲链表的大小范围，这里一共划分成了10类：(0,8],(9,16],(17,32],(33,64],(65,128],(129,256],(257,512],(513,2048],(2049,4096],(4097, +\\infty) 我们可以通过一个指针数据来保存每张链表的头位置： 12static int MAX_SIZE=10;static void* linkhead[10]=&#123;NULL&#125;; 随后我们实现一个根据块大小计算属于哪一张链表的辅助函数： 1234567891011121314151617181920212223static int findlink(size_t size)&#123; if(size&lt;=8) return 0; else if(size&lt;=16) return 1; else if(size&lt;=32) return 2; else if(size&lt;=64) return 3; else if(size&lt;=128) return 4; else if(size&lt;=256) return 5; else if(size&lt;=512) return 6; else if(size&lt;=2048) return 7; else if(size&lt;=4096) return 8; else return 9;&#125; 现在我们就可以实现空闲块的插入和删除逻辑了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//向对应的空闲链表中插入空闲块static void placefree(void* bp)&#123; int index=findlink(GET_SIZE(HDRP(bp))); //空闲链表头下标 void* head=linkhead[index]; //空闲链表入口 //相应链表未初始化时 if(head==NULL) &#123; //把当前块作为标首 linkhead[index]=bp; GET_ADDRESS(PRED(bp))=NULL; GET_ADDRESS(SUCC(bp))=NULL; &#125; else &#123; size_t bpsize=GET_SIZE(HDRP(bp)); //当前块大小 void* temp=NULL; //移动到链表中和当前块大小最接近的元素前 while(head!=NULL) &#123; temp=head; if(GET_SIZE(HDRP(head))&gt;=bpsize) break; head=GET_ADDRESS(SUCC(head)); &#125; //插入当前块 if(head==NULL) &#123; GET_ADDRESS(SUCC(temp))=bp; GET_ADDRESS(PRED(bp))=temp; GET_ADDRESS(SUCC(bp))=NULL; &#125; else &#123; if(head==linkhead[index]) &#123; GET_ADDRESS(PRED(head))=bp; GET_ADDRESS(SUCC(bp))=head; GET_ADDRESS(PRED(bp))=NULL; linkhead[index]=bp; &#125; else &#123; GET_ADDRESS(SUCC(GET_ADDRESS(PRED(head))))=bp; GET_ADDRESS(PRED(bp))=GET_ADDRESS(PRED(head)); GET_ADDRESS(SUCC(bp))=head; GET_ADDRESS(PRED(head))=bp; &#125; &#125; &#125;&#125;//从对应的空闲链表中删除块static void deletefree(void* bp)&#123; int index=findlink(GET_SIZE(HDRP(bp))); //特判 if(linkhead[index]==NULL) printf(&quot;Freelist is empty!&quot;); //链表中仅有一个元素时 if(GET_ADDRESS(PRED(bp))==NULL &amp;&amp; GET_ADDRESS(SUCC(bp))==NULL) &#123; linkhead[index]=NULL; &#125; //当前元素为表首元素时 else if(GET_ADDRESS(PRED(bp))==NULL &amp;&amp; GET_ADDRESS(SUCC(bp))!=NULL) &#123; GET_ADDRESS(PRED(GET_ADDRESS(SUCC(bp))))=NULL; linkhead[index]=GET_ADDRESS(SUCC(bp)); GET_ADDRESS(SUCC(bp))=NULL; &#125; //当前元素为表尾元素时 else if(GET_ADDRESS(PRED(bp))!=NULL &amp;&amp; GET_ADDRESS(SUCC(bp))==NULL) &#123; GET_ADDRESS(SUCC(GET_ADDRESS(PRED(bp))))=NULL; GET_ADDRESS(PRED(bp))=NULL; &#125; //当前元素在表的中间位置时 else &#123; GET_ADDRESS(SUCC(GET_ADDRESS(PRED(bp))))=GET_ADDRESS(SUCC(bp)); GET_ADDRESS(PRED(GET_ADDRESS(SUCC(bp))))=GET_ADDRESS(PRED(bp)); GET_ADDRESS(PRED(bp))=GET_ADDRESS(SUCC(bp))=NULL; &#125;&#125; 随后我们需要在合并空闲块时引入这一管理机制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static void *coalesce(void *bp)&#123; ... if(prev_alloc &amp;&amp; next_alloc) &#123; placefree(bp); //向空闲链表插入当前块 ... &#125; else if(prev_alloc &amp;&amp; !next_alloc) &#123; deletefree(NEXT_BLKP(bp)); //从空闲链表中删除后一个块 ... placefree(bp); &#125; else if(!prev_alloc &amp;&amp; next_alloc) &#123; deletefree(PREV_BLKP(bp)); //从空闲链表中删除前一个块 ... placefree(PREV_BLKP(bp)); //向空闲链表插入更新过的前一个块 &#125; else &#123; deletefree(PREV_BLKP(bp)); //从空闲链表中删除前一个块 deletefree(NEXT_BLKP(bp)); //从空闲链表中删除后一个块 ... placefree(PREV_BLKP(bp)); //向空闲链表插入更新过的前一个块 ... &#125;&#125;static void *recoalesce(void *bp,size_t needsize)&#123; ... else if(prev_alloc &amp;&amp; !next_alloc) &#123; ... else &#123; deletefree(NEXT_BLKP(bp)); ... &#125; &#125; else if(!prev_alloc &amp;&amp; next_alloc) &#123; ... else &#123; ... deletefree(prev_point); ... &#125; &#125; else &#123; ... else &#123; ... deletefree(prev_point); deletefree(NEXT_BLKP(bp)); ... &#125; &#125;&#125; 分离适配有了分离存储的结构后，我们就可以使用分离适配的方法来寻找合适的块分配给用户的每一次空间请求了。其具体思路就是当用户申请某个大小的空间时，我们在其对应空间大小范围的链表中搜索，一旦搜索到一块不小于用户申请大小的块，就将其分配给用户。不过需要注意的是，如果分配给用户的块剩下的大小还可以单独形成一个新的空闲块，则需要将其分割成两个块。用代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//寻找合适的块static void *find_fit(size_t size)&#123; //遍历对应的链表 for(int index=findlink(size);index&lt;MAX_SIZE;++index) &#123; void* bp=linkhead[index]; while(bp!=NULL) &#123; //在找到第一个不小于用户申请大小的块时返回 if(GET_SIZE(HDRP(bp))&gt;=size) return bp; bp=GET_ADDRESS(SUCC(bp)); &#125; &#125; //如果找不到合适的空间则返回空 return NULL;&#125;//在块中分配空间static void place(void* bp,size_t asize)&#123; //剩余块大小 size_t left=GET_SIZE(HDRP(bp))-asize; int alloc=GET_ALLOC(HDRP(bp)); //如果块为空闲状态，则把它从空闲链表中移除 if(alloc==0) deletefree(bp); //剩余空间可以构成一个新块 if(left&gt;=(DSIZE*2)) &#123; PUT(HDRP(bp),PACK(asize,1)); PUT(FTRP(bp),PACK(asize,1)); PUT(HDRP(NEXT_BLKP(bp)),PACK(left,0)); PUT(FTRP(NEXT_BLKP(bp)),PACK(left,0)); coalesce(NEXT_BLKP(bp)); &#125; //剩余空间不能构成一个新块 else &#123; size_t allsize=GET_SIZE(HDRP(bp)); PUT(HDRP(bp),PACK(allsize,1)); PUT(FTRP(bp),PACK(allsize,1)); &#125;&#125; 可以证明，这种方法的空间利用率近似于对整个堆做最佳适配搜索，且其搜索效率明显优于对整个堆做最佳适配搜索。","categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://gonggongjohn.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"Computer-System","slug":"Computer-System","permalink":"http://gonggongjohn.me/tags/Computer-System/"}]},{"title":"Shell Lab实验记录","slug":"csapp-shlab","date":"2021-01-29T15:48:59.000Z","updated":"2021-01-29T17:30:27.575Z","comments":true,"path":"2021/01/29/csapp-shlab/","link":"","permalink":"http://gonggongjohn.me/2021/01/29/csapp-shlab/","excerpt":"简单来说就是用C语言以及各种系统调用实现一个简单的Unix Shell，说的更直白点就是把CSAPP书上第八章提到的关于Shell的内容全部实现一遍，因此最快的办法应该就是先搭一个基本的框架出来，然后跟着trace的要求把功能一个个补齐。","text":"简单来说就是用C语言以及各种系统调用实现一个简单的Unix Shell，说的更直白点就是把CSAPP书上第八章提到的关于Shell的内容全部实现一遍，因此最快的办法应该就是先搭一个基本的框架出来，然后跟着trace的要求把功能一个个补齐。 概览首先我们来看一下Lab的具体要求和操作流程。 在Lab下的tsh.c文件里给出了一个Shell的基本框架，我们的任务就是要完成如下几个函数的具体实现： eval：解析并执行用户输入的命令 builtin_cmd：识别并解析Shell的内置函数 do_bgfg：内置函数bg和fg的功能实现 waitfg：等待前台任务完成 sigchld_handler：SIGCHLD信号处理 sigint_handler：SIGINT信号处理 sigstp_handler：SIGSTP信号处理 其中，内置函数包括如下几个： quit：结束当前的Shell进程 jobs：列出所有当前的后台任务 bg &lt;jobs&gt;：向被挂起的前台任务发送SIGCONT信号，并将其转到后台运行 fg &lt;jobs&gt;：向被挂起的后台任务发送SIGCONT信号，并将其转到前台运行 任务要求我们必须回收所有的僵尸孩子进程，并对相应的信号给出正确的反馈。 为了方便起见，tsh.c文件中提供了一些已封装完成的函数可供我们使用：（仅列出了需要使用到的函数） parseline：解析命令行字符串 addjob：向任务列表添加任务 deletejob：从任务列表移除任务 listjobs：输出任务列表中所有任务的信息 fgpid：获取当前前台任务的PID getjobpid/getjobjid：使用PID/Job ID获取任务实例 pid2jid：PID号转Job ID号 unix_error：发送错误信息并退出 Lab设计了16个Trace任务用于测试给出的Shell，我们可以使用Lab中提供的sdriver.pl工具测试我们的Shell代码： 1&gt; ./sdriver.pl -t traceXX.txt -s ./tsh -a &quot;-p&quot; # XX代表要使用的trace编号 作为参考，我们可以将每个Trace的输出结果与tshref.out中的相应内容进行比对以验证功能是否正确。 基本功能eval及builtin_cmd我们先从eval和builtin_cmd函数入手。对于eval函数，其基本的逻辑如下： 使用parseline函数解析命令行 边界判断（判断输入命令是否为空或仅有一个&amp;符号） 判断是否为内置函数，若是，则直接执行并返回 创建子进程并执行命令 将任务加入任务列表 若为前台任务，则等待其执行完成；否则输出信息并返回 于是我们可以快速写出其对应的代码实现： 12345678910111213141516171819202122232425262728293031323334353637void eval(char *cmdline) &#123; char *argv[MAXARGS]; //参数列表 int bg; //前后台标识符 pid_t pid; //最近创建子任务的PID号 //解析命令行 bg = parseline(cmdline, argv); //特判 if(argv[0] == NULL) return; if(!strcmp(argv[0], &quot;&amp;&quot;)) return; //内置函数判断 if(!builtin_cmd(argv))&#123; //创建子进程 if((pid = fork()) == 0)&#123; //执行任务 if(execve(argv[0], argv, environ) &lt; 0)&#123; printf(&quot;%s: Command not found.\\n&quot;, argv[0]); exit(0); &#125; &#125; //将任务加入任务列表 if(bg) addjob(jobs, pid, BG, cmdline); else addjob(jobs, pid, FG, cmdline); //前后台任务处理 if(bg)&#123; printf(&quot;[%d] (%d) %s&quot;, pid2jid(pid), pid, cmdline); &#125; else&#123; waitfg(pid); &#125; &#125; return;&#125; builtin_cmd函数的功能仅为判断命令是否为内置函数并调用对应的函数，因此其实现更为简单： 123456789101112131415161718192021222324int builtin_cmd(char **argv) &#123; //处理quit指令 if(!strcmp(argv[0], &quot;quit&quot;))&#123; exit(0); &#125; //处理jobs指令 else if(!strcmp(argv[0], &quot;jobs&quot;))&#123; listjobs(jobs); return 1; &#125; //处理bg指令 else if(!strcmp(argv[0], &quot;bg&quot;))&#123; do_bgfg(argv); return 1; &#125; //处理fg指令 else if(!strcmp(argv[0], &quot;fg&quot;))&#123; do_bgfg(argv); return 1; &#125; else return 0;&#125; do_bgfg随后我们来处理内置函数bg和fg的实现。当用户输入bg或fg时，需要切换指定任务的运行状态。首先我们来看一下job实例的结构： 123456struct job_t &#123; pid_t pid; // 任务PID int jid; // 任务Job ID int state; // 任务状态：UNDEF（未定义）, BG（后台）, FG（前台）, or ST（停止） char cmdline[MAXLINE]; // 命令行字符串&#125;; 由此可知我们只需要切换job实例中的state变量即可。这一逻辑可以通过下面这段代码实现： 12345if(!strcmp(argv[0], &quot;fg&quot;))&#123; job-&gt;state = FG; //转为前台任务&#125;else&#123; job-&gt;state = BG; //转为后台任务&#125; 因此我们需要根据用户的输入获取到对应的job实例。用户可以通过PID或Job ID来指定要操作的任务，不过根据题目要求，我们需要讨论所有的输入情况： 1234567891011121314151617181920212223242526272829int jid;struct job_t *job;pid_t pid;//无参数的情况if(argv[1] == NULL)&#123; printf(&quot;%s command requires PID or %%jobid argument\\n&quot;, argv[0]); return;&#125;//输入Job ID的情况if(sscanf(argv[1], &quot;%%%d&quot;, &amp;jid) &gt; 0)&#123; job = getjobjid(jobs, jid); if(job == NULL || job-&gt;state == UNDEF)&#123; printf(&quot;%s: No such job\\n&quot;, argv[1]); return; &#125;&#125;//输入PID的情况else if(sscanf(argv[1], &quot;%d&quot;, &amp;pid) &gt; 0)&#123; job = getjobpid(jobs, pid); if(job == NULL || job-&gt;state == UNDEF)&#123; printf(&quot;(%s): No such process\\n&quot;, argv[1]); return; &#125;&#125;//输入其他字符的情况else&#123; printf(&quot;%s: argument must be a PID or %%jobid\\n&quot;, argv[0]); return;&#125; 随后我们需要向任务发送SIGCONT信号。需要注意的是，我们需要向任务及其子任务同时发送信号，因此我们需要在创建任务时将其自身和后续的子任务打包到一个独立的进程组中，这可以通过setpgid函数来实现： 1234567891011void eval(char *cmdline) &#123; ... if(!builtin_cmd(argv))&#123; if((pid = fork()) == 0)&#123; setpgid(0, 0); //将自身及子进程放入一个以自身PID为组号的进程组中 ... &#125; ... &#125;&#125; 现在我们就可以使用kill函数向整个进程组发送信号了： 1kill(-pid, SIGCONT); //向pid进程组发送SIGCONT信号 随后的行为和eval中类似，只需分情况处理前台或后台任务即可： 12345if(!strcmp(argv[0], &quot;fg&quot;))&#123; waitfg(pid);&#125;else&#123; printf(&quot;[%d] (%d) %s&quot;, job-&gt;jid, pid, job-&gt;cmdline);&#125; waitfgwaitfg的作用基本就是在前台任务终止前锁住Shell进程的指令执行。我们可以使用while+pause语句来快速实现这一功能： 123456void waitfg(pid_t pid)&#123; while(pid == fgpid(jobs))&#123; pause(); &#125;&#125; 信号处理SIGINT及SIGTSTP首先我们来处理SIGINT和SIGTSTP信号。这两种信号的处理方式完全一致，均为向前台任务的整个进程组发送相应的信号： 1234pid_t pid = fgpid(jobs);if(pid != 0)&#123; kill(-pid, sig);&#125; 由于这一过程中可能会由于出现另外的异常而改变errno的值，因此我们需要在刚进入函数时保存errno的值，再在函数返回前将其恢复： 123int old_errno = errno;...errno = old_errno; SIGCHLD按照实验要求，共有三种可能的情况会触发SIGCHLD信号： 子任务正常结束 前台任务被信号终止 前台任务被信号暂停 因此我们需要分情况处理： 1234567891011121314151617181920212223242526void sigchld_handler(int sig) &#123; int old_errno = errno; pid_t pid; int state; //子进程结束状态码 struct job_t *job; //对所有已终止或暂停的子进程进行操作 while((pid = waitpid(-1, &amp;state, WNOHANG | WUNTRACED)) &gt; 0)&#123; //正常退出的情况 if(WIFEXITED(state))&#123; deletejob(jobs, pid); &#125; //被信号终止的情况 else if(WIFSIGNALED(state))&#123; printf(&quot;Job [%d] (%d) terminated by signal %d\\n&quot;, pid2jid(pid), pid, WTERMSIG(state)); deletejob(jobs, pid); &#125; //被信号暂停的情况 else if(WIFSTOPPED(state))&#123; job = getjobpid(jobs, pid); job-&gt;state = ST; //将子进程设置为暂停状态 printf(&quot;Job [%d] (%d) stopped by signal %d\\n&quot;, job-&gt;jid, pid, WSTOPSIG(state)); &#125; &#125; errno = old_errno;&#125; 同样的，我们需要备份errno以防止破坏其他的操作。 调度排查现在我们的程序已经能够通过绝大部分的Trace任务，但由于进程调度机制的存在，某些操作的执行顺序可能并不会如我们所愿，这样在某些情况下可能会导致竞争或死锁的问题，因此我们需要排查这些情况并解决。 首先在任务的添加和删除时，由于要修改全局变量jobs，我们不希望有其他信号处理函数打断这一过程导致jobs被修改，因此在执行这些函数时我们要屏蔽所有的信号接收： 12345678910111213141516171819202122232425262728void eval(char *cmdline) &#123; sigset_t mask_all, mask_prev; ... if(!builtin_cmd(argv))&#123; sigfillset(&amp;mask_all); sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;mask_prev); ... if(bg) addjob(jobs, pid, BG, cmdline); else addjob(jobs, pid, FG, cmdline); sigprocmask(SIG_SETMASK, &amp;mask_prev, NULL); ... &#125;&#125;void sigchld_handler(int sig) &#123; sigset_t mask_all, mask_prev; ... sigfillset(&amp;mask_all); while((pid = waitpid(-1, &amp;state, WNOHANG | WUNTRACED)) &gt; 0)&#123; sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;mask_prev); ... sigprocmask(SIG_SETMASK, &amp;mask_prev, NULL); &#125; ...&#125; 同理，在修改任务状态时我们也需要屏蔽所有信号： 1234567891011void do_bgfg(char **argv) &#123; ... sigset_t mask_all, mask_prev; ... sigfillset(&amp;mask_all); sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;mask_prev); ... sigprocmask(SIG_SETMASK, &amp;mask_prev, NULL); ...&#125; 接着，我们继续检查eval函数，发现如果子进程在addjob函数被执行前便已终止，则sigchld_handler中的deletejob便无法正确删除相应的任务，因此我们需要在addjob被执行前屏蔽SIGCHLD信号： 123456789101112void eval(char *cmdline) &#123; ... sigset_t mask_one, mask_prev; ... if(!builtin_cmd(argv))&#123; sigemptyset(&amp;mask_one); sigaddset(&amp;mask_one, SIGCHLD); sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;mask_prev); ... &#125;&#125; 然而，这一操作可能会使得子进程也无法接收到SIGCHLD信号，因此我们需要在创建子进程后恢复信号的接收： 1234567891011void eval(char *cmdline) &#123; ... if(!builtin_cmd(argv))&#123; if((pid = fork()) == 0)&#123; sigprocmask(SIG_SETMASK, &amp;mask_prev, NULL); ... &#125; ... &#125;&#125; 最后，我们考察waitfg函数，发现经过上面的修改后Shell进程已无法正确接受SIGCHLD指令。此时尽管我们可以暂时放开SIGCHLD信号的接收，但如果程序刚放开信号进程调度程序便调度至子进程并运行至子进程退出，则pause指令永远无法正确接收到SIGCHLD信号，此时便会出现死锁的情况。因此我们需要使用sigsuspend函数来代替以保证其不会被打断： 123456789void waitfg(pid_t pid)&#123; sigset_t empty_mask; sigemptyset(&amp;empty_mask); while(pid == fgpid(jobs))&#123; sigsuspend(&amp;empty_mask); &#125;&#125;","categories":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://gonggongjohn.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"Computer-System","slug":"Computer-System","permalink":"http://gonggongjohn.me/tags/Computer-System/"}]},{"title":"K-Means聚类与层次聚类","slug":"clustering","date":"2020-12-30T13:22:44.000Z","updated":"2021-02-01T07:42:39.481Z","comments":true,"path":"2020/12/30/clustering/","link":"","permalink":"http://gonggongjohn.me/2020/12/30/clustering/","excerpt":"Cluster AnalysisCluster analysis or clustering is a task of grouping a set of objects in such a way that objects in the same group are more similar to each other than to those in other groups. It is a main task of exploratory data mining, and a common technique for statistical data analysis which is used in many fields including pattern recognition, image analysis, information retrieval, bioinformatics, data compression, computer graphics and machine learning.","text":"Cluster AnalysisCluster analysis or clustering is a task of grouping a set of objects in such a way that objects in the same group are more similar to each other than to those in other groups. It is a main task of exploratory data mining, and a common technique for statistical data analysis which is used in many fields including pattern recognition, image analysis, information retrieval, bioinformatics, data compression, computer graphics and machine learning. There are various clustering algorithms that differ significantly in their understanding of what constitutes a cluster and how to effectively find them, which proved to be useful in different scenarios. K-means ClusteringConceptK-means clustering is a partition-based method that can be used to partition a dataset into a fixed number of clusters. We can use the famous priest-villager model to illustrate the main idea of K-means algorithm. There are four priests preaching in the countryside. At first, they chose four preaching points arbitrarily, and told villagers to take the preaching course that is nearest to their own house. After the first class, some villagers complained that the preaching points were still too far from their home, so each of the priests collected the home addresses of all the villagers that came to his class and move the preaching point to the center of all the addresses. Since the update of preaching points, some villagers found that another preaching points became closer to their house than the previous one, so they chose to take the course at the new preaching point. In this way, the priests updated their preaching points every week, and villagers decided which course to take according to the distance of each preaching points. After several weeks, the preaching points became stable and both the villagers and the priests got satisfied. In formal words, K-means algorithm can be described as follows: Choose a set of K initial points \\{c_1, c_2, ..., c_K\\} that denotes the centroid of each cluster Iteratively execute the following steps until all the centroid points stop to change (or hit some global restriction): For each sample points in the dataset, compute the distances from it to every centroids and assign it to the centroid with the smallest distance Recompute the position of each centroid according to the positions of all the samples assigned to it Mathematical DetailsIntuitively, we want to find a set of centroids and an assignment of every instances in the dataset to these centroids so that every centroid covers the most reasonable amount of instances and anchors at exactly the average point of all the instances that assigned to it. We can use a mathematical trick to convert this intuition into an optimization problem. If we define an indicator variable r_{nk} to describe which cluster an instance is in, which is r_{nk} = \\left\\{ \\begin{aligned} &1, &if \\ n \\ is \\ assigned \\ to \\ k \\\\ &0, &otherwise \\end{aligned} \\right., then the sum of the distance of all the instances in the dataset to their centroids can be written as J = \\sum_{n=1}^N \\sum_{k=1}^K r_{nk} \\cdot dist(x_n, c_k)where N is the size of the dataset, K is the number of clusters, x_n is the n^{th} instance in the dataset, c_k is the k^{th} centroid, dist(a, b) is the distance between a and b. Specifically, if the dataset is in the Euclidean space, then we can use the square of Euclidean distance as the distance function (square is for the convenience of derivation operations), which is dist(x_n, c_k) = ||x_n - c_k||^2 = (x_{n1}-c_{k1})^2 + (x_{n2}-c_{k2})^2 + ... + (x_{nm}-c_{km})^2where x_{ni} and c_{ki} is the i^{th} component of x and c respectively. If the dataset denotes some broader set (usually text data), we can also use the Jaccard distance as the distance function, which is defined as dist(A, B) = \\frac{A \\Delta B}{|A \\cup B|} = \\frac{|A \\cup B - A \\cap B|}{|A \\cup B|}where A, B are two sets and |S| is the size of set S. Therefore, our goal becomes to minimize the function J. A famous solution to this kind of problems is the EM(Expectation-Maximization) Algorithm where optimizing r_{nk} is the expectation step and minimizing dist(x_n, c_k) is the maximization step. First we optimize r_{nk}. Since J is the linear function of r_{nk}, we can simply assigned every instance to the centroid k if the distance between them is the smallest among all centroids to get the minimum J when the centroids are fixed. Then we try to minimize the distance function. Here we only consider the situation when we use the Euclidean distance as the distance metrics. More specifically, our goal is to minimize J = \\sum_{n=1}^N \\sum_{k=1}^K r_{nk} ||x_n - c_k||^2when r_{nk} is fixed (This function are also called the sum of squared error function). Since each cluster is independent, we can optimize each cluster respectively to get the global minimum, which is to minimize the following expression J_k = \\sum_{n=1}^N r_{nk} \\cdot ||x_n-c_k||^2for every k from 1 to K. We can notice that this is a quadratic function of c_k, so we can simply set its derivative function to 0 and solve for c_k to get the minimum point. From this we can get the final formula to find the position of c_k c_k = \\frac{\\sum_\\limits{n=1}^N r_{nk}x_n}{\\sum_\\limits{n=1}^N r_{nk}}Since both of the two steps aims at reducing J while J is always greater than 0, we can prove that the function will finally converges. Complexity AnalysisWe can implement K-means algorithm in pseudo-code: 1234567891011121314K-MEANS(K, t, s): &#x2F;&#x2F;The paramaters denote the number of clusters, the iteration times and the dataset respectivelyInitialize c[K] &#x2F;&#x2F;Denote the centroid setWhile t For i in s min_dist &#x3D; INF For j &#x3D; 1 to K d &#x3D; Distance between i and c[j] If d &lt; min_dist min_dist &#x3D; d min_index &#x3D; j Append i into the cluster set of c[min_index] For i &#x3D; 1 to K c[i].pos &#x3D; Mean position of all the points in the cluster set of c[i]return c If we use the standard Euclidean distance (L_2 norm) as the distance metrics, then the time complexity of K-means algorithm is \\mathcal{O}(tknm) where t is the iteration times, k is the number of clusters, n is the size of the dataset and m is the dimension of each sample in the dataset. Similarly, if the samples of the dataset and the centroids are all in m-dimensional Euclidean space, than the space complexity of K-means algorithm is \\mathcal{O}((n+k) \\cdot m) where n is the size of the dataset, k is the number of clusters. ApplicationsDue to its simplicity, K-means clustering algorithm has been successfully used in many domains such as market segmentation, computer vision and astronomy. It is also used as a preprocessing step before many other alogirithms to find a starting configuration. For example, in computer graphics, there is a task called color quantization which is to reduce the color palette of a picture into a fixed number. K-means algorithm can easily been used for this task and often produces a competitive result. As an unsupervised learning algorithm, K-means algorithm is also widely used to explore the implicit features of a dataset before applying subsequent learning algorithms in data mining area, which can be very useful in some NLP(Natural Language Processing) and computer vision tasks. Pros And ConsThe advantage of K-means algorithm is that it has a relatively low time and space complexity, and has a good flexibility even when applying to a large dataset. However, there are also some drawbacks of it: The algorithm may converges to a local minimum, which is counterintuitive in some situation. Unable to get a correct partition when the clusters is not spherical or non-convex. The algorithm is sensitive to the cluster number K and the initial point of the centroids. Hierarchical ClusteringConceptAs its name suggests, hierarchical clustering is a hierarchical-based method to group similar objects into clusters. Its main idea is to build a hierarchical tree (or dendrogram) to represent the nested group relations. In general, there are two different strategies to achieve this goal: Agglomerative Hierarchical Clustering and Divisive Hierarchical Clustering. Agglomative method is a bottom-up method, which is to regard each of the instances as a single cluster at first and then keep merging the most similar clusters until there is only one cluster left. In comparison, divisive method is a top-down method, which consider the whole dataset as a big cluster and keep splitting down until each of the clusters have only one instance in it. Complexity AnalysisAgglomerative hierarchical clustering algorithm can be implemented as follow: 123456789101112131415AHC(s): &#x2F;&#x2F;s denotes the datasetInitialize c &#x2F;&#x2F;Denote the clusters at the current levelAppend every instance from s to cWhile c.length !&#x3D; 1 min_dist &#x3D; INF For i in c For j in c If i !&#x3D; j d &#x3D; Distance between i and j If d &lt; min_dist min_dist &#x3D; d min_cp &#x3D; i, j cm &#x3D; merge(min_cp) Remove min_cp from c Append cm to c The basic structure of Divisive hierarchical clustering algorithm is the same as the agglomerative one, except the divisive one needs to split the farthest sub-clusters from the larger cluster in every loop. If we use the Euclidean distance as the distance metrics, then the time complexity of hierarchical clustering is \\mathcal{O}(mn^3) where m is the dimension of each sample in the dataset and n is the size of the dataset. Since every cluster needs to record its member and its sub-clusters, the space complexity of hierarchical clustering is \\mathcal{O}(n^2) ApplicationsHierarchical clustering is an ideal methods to find the hierarchical relations between instances. These instances often differ from each other in some aspects, but not to the extent that we should put them into two mutual exclusive groups. For instance, we can use hierarchical clustering to find the members of each party in America senate. To achieve this, we can define how much one senator agrees with another’s words as a metrics, and implement hierarchical clustering algorithm on all senator’s twitter accounts. Pros And ConsA conspicuous benefit for hierarchical clustering is that it can get the whole cluster information once-and-for-all. Once we get the hierarchical relation tree of a dataset, we can probe the cluster information in different granularity and get the fittest cluster results we want to get. However, the defects of it is equally distinct. The huge cost of computing distance between every two clusters and storing hierarchical information makes it unsuitable to handle large dataset. Once a cluster partition or congregation is determined, it is not easy to change since every subsequent judgement is based on clusters existed, which gives the algorithm a poor flexibility. Moreover, the strategy for merging or splitting the clusters is a greedy strategy, which may leads to an local-optimum result. K-means V.S. Hierarchical ClusteringIn view of their different features, K-means and hierarchical clustering are often used in different scenarios. K-means can be easily adapted to a large or dense dataset thanks to its simplity and low computational cost. When it is uneasy to determine how many clusters in the dataset or the instance relations are unambiguous, hierarchical clustering proves to be a better choice. In practice, we often perform K-means clustering first to get a rough understanding of a dataset and reduce the data size. Then we perform hierarchical clustering to explore the deeper interrelationships among the dataset.","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://gonggongjohn.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"Machine-Learning","slug":"Machine-Learning","permalink":"http://gonggongjohn.me/tags/Machine-Learning/"}]},{"title":"从主方法到Akra-Bazzi定理","slug":"akra-bazzi","date":"2020-11-25T03:34:14.000Z","updated":"2021-01-21T07:09:55.412Z","comments":true,"path":"2020/11/25/akra-bazzi/","link":"","permalink":"http://gonggongjohn.me/2020/11/25/akra-bazzi/","excerpt":"主方法在算法分析中，当我们使用分治法求解问题时，通常会遇到以递归式定义的算法运行时间函数。要得到此类算法的时间复杂度，就必须求出该递归式的渐近表达式。通常情况下，我们可以通过如下公式直接得到大部分不太复杂的递归式的渐近解。《算法导论》一书中将该方法称为“主方法”。","text":"主方法在算法分析中，当我们使用分治法求解问题时，通常会遇到以递归式定义的算法运行时间函数。要得到此类算法的时间复杂度，就必须求出该递归式的渐近表达式。通常情况下，我们可以通过如下公式直接得到大部分不太复杂的递归式的渐近解。《算法导论》一书中将该方法称为“主方法”。 Theorem: 设a\\geq 1, b >1，f(n)为一定义在非负整数上的函数， T(n)=aT\\left(\\frac{n}{b}\\right) + f(n)（当 \\frac{n}{b} 不为整数时代表 \\lfloor{\\frac{n}{b}\\rfloor} 或 \\lceil{\\frac{n}{b}\\rceil}），则 若存在 \\varepsilon > 0，使得 f(n) = \\mathcal{O}\\left(n^{\\log_b a - \\varepsilon}\\right)，则 T(n) = \\Theta\\left(n^{\\log_b a}\\right) 若存在 k \\geq 0，使得 f(n) = \\Theta\\left(n^{\\log_b a} \\lg^k n\\right)，则 T(n) = \\Theta\\left(n^{\\log_b a} \\lg^{k+1} n\\right) 若存在 \\varepsilon > 0，使得 f(n) = \\Omega\\left(n^{\\log_b a + \\varepsilon}\\right)，且存在 0 \\log_2 4 = 2 可知，存在 \\varepsilon > 0，使得 f(n) = \\Theta(n^2) = \\mathcal{O}(n^{\\log_2 7 - \\varepsilon}) 故由主定理可知，T(n) = \\Theta(n^{\\log_2 7}) Example2: 归并排序算法的运行时间函数 T(n) = 2T\\left(\\frac{n}{2}\\right) + \\Theta(n)，求归并排序算法的时间复杂度 解：由 \\log_2 2 = 1 可知，存在 k=0，使得 f(n) = \\Theta(n) = \\Theta(n^{\\log_2 2} \\lg^k n) 故由主定理可知，T(n) = \\Theta(n \\lg n) Example3: 若一个算法的运行时间函数 T(n)=2T\\left(\\frac{n}{2}\\right) + \\Theta(n^2)，求该算法的时间复杂度 解：由 \\log_2 2 = 1 可知，存在 \\varepsilon > 0，使得 f(n) = \\Theta(n^2) = \\Omega(n^{\\log_2 2 + \\varepsilon}) 又由于 af\\left(\\frac{n}{b}\\right) = 2 \\left(\\frac{n}{2}\\right)^2 = \\frac{n^2}{2} 因此仅需取 \\frac{1}{2} \\leq c < 1，则有 af\\left(\\frac{n}{b}\\right) \\leq cf(n) 故由主定理可知，T(n) = \\Theta(n^2) 主定理的证明下面我们来尝试证明主定理。 主定理的证明思路如下：首先我们考虑当 n 为 b 的某个幂次时的情况，此时可以保证 \\frac{n}{b} 是一个整数，因此可以直接做递推并求出其阶数。随后，通过放缩，我们可以将其推广到一切正整数的情况上去。 首先我们考虑当 n 为 b 的 k 次幂时的情况。此时原递归式可写为 T(n)=\\left\\{ \\begin{aligned} &\\Theta(1) &, &n = 1 \\\\ &aT\\left(\\frac{n}{b}\\right)+f(n) &, &n=b^i(i=1,2,...,k) \\end{aligned} \\right.作递推，可得 \\begin{aligned} T(n)&=aT\\left(\\frac{n}{b}\\right) + f(n) \\\\ &=a^2T\\left(\\frac{n}{b^2}\\right) + af\\left(\\frac{n}{b}\\right) + f(n) \\\\ &=a^3T\\left(\\frac{n}{b^3}\\right) + a^2f\\left(\\frac{n}{b^2}\\right) + af\\left(\\frac{n}{b}\\right) + f(n) \\\\ &=... \\\\ &=a^{\\log_b n} T(1) + \\sum_\\limits{i = 0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right) \\\\ &=n^{\\log_b a} \\Theta(1) + \\sum_\\limits{i = 0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right) \\\\ &=\\Theta \\left(n^{\\log_b a} \\right) + \\sum_\\limits{i = 0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right) \\end{aligned}因此我们只需要考察 \\sum_\\limits{i = 0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right) 的渐近表达式即可得到 T(n) 的渐近解。 现在我们来证明如下的的引理成立 Lemma: 设 g(n) = \\sum_\\limits{i = 0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right) （其中 a \\geq 1, b > 1，n=b^k），则 若存在 \\varepsilon > 0，使得 f(n) = \\mathcal{O} \\left(n^{\\log_b a - \\varepsilon} \\right)，则 g(n) = \\mathcal{O}\\left(n^{\\log_b a}\\right) 若存在 k \\geq 0，使得 f(n) = \\Theta\\left(n^{\\log_b a} \\lg^k n\\right)，则 g(n) = \\Theta\\left(n^{\\log_b a} \\lg^{k+1} n\\right) 若存在 0N 时，有 a^i f\\left(\\frac{n}{b^i}\\right) \\leq c^if(n) 故 \\begin{aligned} g(n) &= \\sum_\\limits{i = 0}^{\\log_b n - \\log_b N} a^i f \\left( \\frac{n}{b^i} \\right) + \\sum_\\limits{i = \\log_b n - \\log_b N + 1}^{\\log_b n - 1} a^i f \\left( \\frac{n}{b^i} \\right) \\\\ &\\leq \\sum_\\limits{i = 0}^{\\log_b n - \\log_b N}c^if(n) + \\Theta(1) \\\\ &=f(n) \\sum_\\limits{i = 0}^{\\log_b n - \\log_b N}c^i + \\Theta(1) \\\\ &\\leq f(n) \\sum_\\limits{i = 0}^{\\infty}c^i + \\Theta(1) \\\\ &=\\frac{1}{1-c} \\cdot f(n) + \\Theta(1) \\\\ &=\\mathcal{O}(f(n)) \\end{aligned}由此可得 g(n) = \\Theta(f(n)) 由于 T(n)=\\Theta \\left(n^{\\log_b a} \\right) + \\sum_\\limits{i = 0}^{\\log_b n - 1} a^i f\\left(\\frac{n}{b^i}\\right)，故根据引理我们就能快速得到 n 为 b 的 k 次幂时的主定理。 下面我们需要将 n 为 b 的 k 次幂时的主定理推广到 n 为一切整数时的情况以证明完整的主定理成立。 首先由于 \\begin{aligned} T(n)&=aT\\left(\\lceil{\\frac{n}{b}\\rceil}\\right) + f(n) \\\\ &\\geq aT\\left(\\frac{n}{b}\\right) + f(n) \\end{aligned}故根据 n 为 b 的幂次时的主定理可知当 T(n)=aT\\left(\\lceil{\\frac{n}{b}\\rceil}\\right) + f(n) 时，T(n)=\\Omega(A) （根据不同情况 A 取 n^{\\log_b a}、n^{\\log_b a} \\lg^{k+1} n 或 f(n)） 同理可得当 T(n)=aT\\left(\\lfloor{\\frac{n}{b}\\rfloor}\\right) + f(n) 时，T(n)=\\mathcal{O}(A) 下面我们来证明当 T(n)=aT\\left(\\lceil{\\frac{n}{b}\\rceil}\\right) + f(n) 时，T(n)=\\mathcal{O}(A) 令 t_0 = n, t_1 = \\lceil{\\frac{t_0}{b} \\rceil}, t_2 = \\lceil{\\frac{t_1}{b} \\rceil}, ..., t_k = \\lceil{\\frac{t_{k - 1}}{b} \\rceil}=\\Theta(1) 由于 \\begin{aligned} t_1 &\\leq \\frac{n}{b} + 1 \\\\ t_2 &\\leq \\frac{t_1}{b} + 1 \\leq \\frac{n}{b^2} + \\frac{1}{b} + 1 \\\\ ... \\\\ t_k &\\leq \\frac{t_{k-1}}{b} + 1 \\leq \\frac{n}{b^k} + \\sum_\\limits{i = 0}^{k-1} \\frac{1}{b^i} \\end{aligned}故 \\begin{aligned} t_k &\\leq \\frac{n}{b^k} + \\sum_\\limits{i = 0}^{\\infty} \\frac{1}{b^i} \\\\ &=\\frac{n}{b^k} + \\frac{b}{b-1} \\end{aligned}由于当 k = \\lfloor{\\log_b n\\rfloor} 时有 \\frac{n}{b^k} + \\frac{b}{b-1} \\leq \\frac{n}{b^{\\log_b n - 1}} + \\frac{b}{b-1} = \\frac{b^2}{b-1} = \\Theta(1)故 k \\leq \\lfloor{\\log_b n\\rfloor} 故对原式作递推，可得 \\begin{aligned} T(n) &= aT\\left(t_1\\right) + f(t_0) \\\\ &= a^2T(t_2) + af(t_1) + f(t_0) \\\\ &... \\\\ &\\leq \\Theta \\left(n^{\\log_b a} \\right) + \\sum_\\limits{i = 0}^{\\lfloor{\\log_b n \\rfloor} - 1} a^i f\\left(t_i\\right) \\end{aligned}因此由上面 n 为 b 的幂次时主定理得推导过程同理可得，T(n) \\leq \\Theta(A)，即 T(n) = \\mathcal{O}(A) 类似的我们同样可以得到当 T(n)=aT\\left(\\lfloor{\\frac{n}{b}\\rfloor}\\right) + f(n) 时，T(n)=\\Omega(A) 于是综上所述，T(n) = \\Theta(A) 可推广到一切正整数，即主定理成立 主方法的局限性通俗来说，若要使用主方法，f(n) 必须多项式意义上的小于或大于 n^{\\log_b a}（即 f(n) 与 n^{\\log_b a} 的阶数差能够被某个 n^\\varepsilon 控制住），或者 f(n) 仅比 n^{\\log_b a} 大 \\log 阶。而这三种情况并不能覆盖 f(n) 所有可能的函数特征，若 f(n) 的阶数在这三种情况之间，主方法就失效了。 例如当 T(n) = 3T \\left(\\frac{n}{3}\\right) + \\frac{n}{\\lg n} 时，对于 f(n) = \\frac{n}{\\lg n}，无法找到某个 \\varepsilon > 0 使得 f(n) = \\mathcal{O}(n)，即 f(n) 不是多项式意义上的小于 \\log_b a，此时便无法使用主定理得到该递归式的渐近解。 此外，主方法要求递归式必须由平均划分的子式定义，而对于如 T(n) = T\\left(\\frac{n}{2} \\right) + T\\left(\\frac{n}{4} \\right) + T\\left(\\frac{n}{8} \\right) + n 这样非平均划分子式定义的递归式，同样无法使用主方法求解。 遇到此类问题，《算法导论》中推荐使用画递归树+数学归纳证明的方法解决。然而对于一些子问题情况较为复杂的递归式，这种方法的效率十分低下且容易出错，有时并不能很好的作为一种普适的办法使用。 Akra-Bazzi定理Akra-Bazzi定理是由两位黎巴嫩数学家Mohamad Akra和Louay Bazzi于1998年提出的一种用于求解线性递归式的渐近解的定理。Akra-Bazzi定理相比主定理对递归式的要求更弱，其适用范围也远广于主定理。 为了引出Akra-Bazzi定理，我们需要定义一个多项式增长条件 Definition: 设 g(x) 为一定义在非负实数上的函数，\\{b_k\\} 为一个含有 k 项的数列且满足 0 < b_i< 1，若存在正常数 c_1, c_2 使得对任意 x \\geq 1, 1 \\leq i \\leq k, u \\in [b_i x , x]，均有 c_1 g(x) \\leq g(u) \\leq c_2 g(x) ，则称 g(x) 满足多项式增长条件 由定义可知，若存在 c > 0 ，使得 |g'(x)| \\in \\mathcal{O}(x^c)，则 g(x) 满足多项式增长条件。例如，对任意 \\alpha, \\beta \\in \\mathbb{R}，g(x) = x^{\\alpha} \\lg^{\\beta} x 均满足多项式增长条件。 下面我们来叙述Akra-Bazzi定理： Theorem: 设 g(x) 为一非负函数， T(x) = \\left\\{ \\begin{aligned} &\\Theta(1)&, &1 \\leq x \\leq X_0 \\\\ &\\sum_\\limits{i = 1}^k a_i T(b_i x) +g(x)&, &x > X_0 \\end{aligned}\\right.（其中 k \\geq 1, a_i > 0, 0 < b_i < 1，X_0 满足对任意 1 \\leq i \\leq k 有 X_0 > \\frac{1}{b_i} 且 X_0> \\frac{1}{1-b_i}），若 g(x) 满足多项式增长条件，p 为方程 \\sum_\\limits{i = 1}^k a_i b_i^p = 1 的实数解，则 \\begin{aligned} T(x) &= \\Theta \\left(x^p \\left( 1 + \\int_1^x \\frac{g(u)}{u^{p+1}} du\\right)\\right) \\end{aligned} 通过该定理，我们可以快速求解许多主方法无法处理的递归式。 Example1: 设 T(n) = 2T \\left( \\frac{n}{4}\\right) + 3T \\left(\\frac{n}{6} \\right) + n \\lg n，求 T(n) 的渐近解 解：由 \\frac{2}{4^p} + \\frac{3}{6^p} = 1 可知 p = 1 故由Akra-Bazzi定理可知 \\begin{aligned} T(n) &= \\Theta \\left(n \\left(1 + \\int_1^n \\frac{x \\lg x}{x^2} dx\\right)\\right) \\\\ &=\\Theta \\left(n \\left(1 + \\frac{1}{2}\\lg^2 n \\right)\\right) \\\\ &=\\Theta \\left(n \\lg^2 n \\right) \\end{aligned}Example2: 设 T(n) = 3T \\left( \\frac{n}{3}\\right) + \\frac{n}{\\lg n}（n \\geq 2），求 T(n) 的渐近解 解：由 \\left(\\frac{3}{3}\\right)^p = 1 可知 p = 1 故由Akra-Bazzi定理可知 \\begin{aligned} T(n) &= \\Theta \\left(n \\left( 1 + \\int_2^n \\frac{\\frac{x}{\\lg x}}{x^2} dx\\right)\\right) \\\\ &=\\Theta \\left(n \\left( 1 + \\int_2^n \\frac{1}{x \\lg x} dx\\right)\\right) \\\\ &=\\Theta \\left(n \\left( 1 + \\lg \\lg n \\right) \\right) \\\\ &=\\Theta(n \\lg \\lg n) \\end{aligned}Example3: 设 T(n) = \\frac{1}{2} T \\left( \\frac{n}{2} \\right) + \\frac{1}{n}，求 T(n) 的渐近解 解：由 \\frac{1}{2} \\cdot \\left(\\frac{1}{2}\\right)^p = 1 可知 p = -1 故由Akra-Bazzi定理可知 \\begin{aligned} T(n) &= \\Theta \\left(n^{-1} \\left( 1 + \\int_1^n \\frac{\\frac{1}{x}}{x^0} dx \\right)\\right) \\\\ &= \\Theta(\\left(n^{-1} \\left(1 + \\ln n \\right) \\right) \\\\ &= \\Theta \\left(\\frac{\\ln n}{n}\\right) \\end{aligned} Akra-Bazzi定理的证明Akra-Bazzi的原始论文中使用了一种称为阶变换（Order Transform）的技巧来导出Akra-Bazzi定理，但完整过程篇幅较长且较为复杂。在已经知道结论的情况下，我们还可以使用数学归纳法来证明Akra-Bazzi定理，这种方法更加简洁且相对容易理解。 首先我们证明一个引理 Lemma: 若 g(x) 为一非负函数且满足多项式增长条件，则存在 c_3, c_4 > 0，使得对任意 x \\geq 1, 1 \\leq i \\leq k，有 c_3 g(x) \\leq x^p \\int_{b_i x}^x \\frac{g(u)}{u^{p + 1}} du \\leq c_4 g(x)证明： g(x) 满足多项式增长条件，即存在正常数 c_1, c_2 使得对任意 x \\geq 1, 1 \\leq i \\leq k, u \\in [b_i x , x]，均有 c_1 g(x) \\leq g(u) \\leq c_2 g(x) 故 \\begin{aligned} x^p \\int_{b_i x}^x \\frac{g(u)}{u^{p + 1}} du &\\leq c_2 x^p g(x) \\cdot \\int_{b_i x}^x \\frac{1}{u^{p + 1}} du \\\\ &\\leq c_2 x^p g(x) \\cdot (x - b_i x) \\cdot \\max \\{ \\frac{1}{(b_i x)^{p+1}}, \\frac{1}{x^{p+1}}\\} \\\\ &=c_2 \\cdot (1-b_i) \\cdot \\max \\{\\frac{1}{b_i^{p+1}}, 1 \\} \\cdot g(x) \\end{aligned}因此仅需令 c_4 \\geq c_2 \\cdot (1-b_i) \\cdot \\max \\{\\frac{1}{b_i^{p+1}}, 1 \\}，就有 x^p \\int_{b_i x}^x \\frac{g(u)}{u^{p + 1}} du \\leq c_4 g(x) 同理，令 c_3 \\leq c_2 \\cdot (1-b_i) \\cdot \\min \\{\\frac{1}{b_i^{p+1}}, 1 \\}，就有 x^p \\int_{b_i x}^x \\frac{g(u)}{u^{p + 1}} du \\geq c_3 g(x) 故原命题成立 下面我们使用数学归纳法证明存在 c_5>0, x_1 > 1，使得对任意 x > x_1，有 T(x) \\geq c_5 \\cdot x^p \\left( 1 + \\int_1^x \\frac{g(u)}{u^{p+1}} du\\right) 由于 T(x) 的取值范围包含大于1的一切实数，我们不能直接对 x 进行归纳。 为了使用数学归纳法，我们令 I_0 = [1, X_0], I_1 = (X_0+1, X_0+2], ..., I_j = (X_0 + j -1, X_0 + j]。易见 x 必然落在某一个区间 j_0 内，且 b_i x 必然落在 j_0 前面的某一区间内，因此我们可以对 I_j 进行归纳。 当 j=0 时，由定义可知 T(x) = \\Theta(1)，结论显然成立 若结论对任意 j < j_0 均成立，则当 j=j_0 时，有 \\begin{aligned} T(x) &= \\sum_\\limits{i = 1}^k a_i T(b_i x) +g(x) \\\\ &\\geq \\sum_\\limits{i = 1}^k a_i \\cdot c_5 \\cdot (b_i x)^p \\left( 1 + \\int_1^{b_i x} \\frac{g(u)}{u^{p+1}} du\\right) +g(x) \\\\ &=c_5 x ^p \\sum_\\limits{i = 1}^k a_i \\cdot b_i^p \\left( 1 + \\int_1^{x} \\frac{g(u)}{u^{p+1}} du - \\int_{b_i x}^{x} \\frac{g(u)}{u^{p+1}} du\\right) +g(x) \\\\ &\\geq c_5 x ^p \\cdot \\left( 1 + \\int_1^{x} \\frac{g(u)}{u^{p+1}} du - \\frac{c_4}{x_p}g(x)\\right) \\cdot \\sum_\\limits{i = 1}^k a_i b_i^p +g(x) \\\\ &=c_5 x ^p \\cdot \\left( 1 + \\int_1^{x} \\frac{g(u)}{u^{p+1}} du - \\frac{c_4}{x_p}g(x)\\right) +g(x) \\\\ &=c_5 x ^p \\cdot \\left( 1 + \\int_1^{x} \\frac{g(u)}{u^{p+1}} du \\right) - (c_4c_5 - 1) g(x) \\end{aligned}因此，只需令 c_5 \\leq \\frac{1}{c_4}，就有 T(x) \\geq c_5 \\cdot x^p \\left( 1 + \\int_1^x \\frac{g(u)}{u^{p+1}} du\\right) 成立 即 T(x) = \\Omega \\left( x^p \\left( 1 + \\int_1^x \\frac{g(u)}{u^{p+1}} du\\right) \\right) 同理可证得 T(x) = \\mathcal{O} \\left( x^p \\left( 1 + \\int_1^x \\frac{g(u)}{u^{p+1}} du\\right) \\right) 由此我们便证得了最终的结论 T(x) = \\Theta \\left(x^p \\left( 1 + \\int_1^x \\frac{g(u)}{u^{p+1}} du\\right)\\right) 推广的Akra-Bazzi定理事实上，Tom Leighton还给出过一个更一般形式的Akra-Bazzi推广定理 Definition（推广的多项式增长条件）: 设 g(x),h(x) 均为定义在非负实数上的函数，\\{b_k\\} 为一个含有 k 项的数列且满足 0 < b_i< 1，若存在正常数 c_1, c_2 使得对任意 x \\geq 1, 1 \\leq i \\leq k, u \\in [b_i x + h_i(x), x]，均有 c_1 g(x) \\leq g(u) \\leq c_2 g(x) ，则称 g(x) 满足多项式增长条件 Theorem: 设 g(x) 为一非负函数， T(x) = \\left\\{ \\begin{aligned} &\\Theta(1)&, &1 \\leq x \\leq X_0 \\\\ &\\sum_\\limits{i = 1}^k a_i T(b_i x + h_i(x)) +g(x)&, &x > X_0 \\end{aligned}\\right.，若满足以下四个条件： (1) k \\geq 1，对任意 1 \\leq i \\leq k，有 a_i > 0, 0 < b_i < 1 (2) X_0 为一足够大的常数，使得存在 \\varepsilon > 0，对任意 1 \\leq i \\leq k, x \\geq X_0，满足以下四个条件： \\begin{aligned} &(a) \\left( 1 - \\frac{1}{b_i \\lg^{1+\\varepsilon} x} \\right)^p \\left( 1 + \\frac{1}{\\lg^{\\frac{\\varepsilon}{2}} \\left( b_i x + \\frac{x}{\\lg^{1+\\varepsilon} x}\\right)} \\right) \\geq 1+ \\frac{1}{\\lg^{\\frac{\\varepsilon}{2}} x} \\\\ &(b) \\left( 1 + \\frac{1}{b_i \\lg^{1+\\varepsilon} x} \\right)^p \\left( 1 - \\frac{1}{\\lg^{\\frac{\\varepsilon}{2}} \\left( b_i x + \\frac{x}{\\lg^{1+\\varepsilon} x}\\right)} \\right) \\leq 1- \\frac{1}{\\lg^{\\frac{\\varepsilon}{2}} x} \\\\ &(c) \\frac{1}{2} \\left( 1 + \\frac{1}{\\lg^{\\frac{\\varepsilon}{2}} x}\\right) \\leq 1 \\\\ &(d) 2 \\left( 1 - \\frac{1}{\\lg^{\\frac{\\varepsilon}{2}} x} \\right) \\geq 1 \\end{aligned}(3) 存在 \\varepsilon > 0 使得对任意 1 \\leq i \\leq k, x > X_0，均有 |h_i(x)| \\leq \\frac{x}{\\lg^{1+\\varepsilon} x} (4) g(x) 满足多项式增长条件 若设 p 为方程 \\sum_\\limits{i = 1}^k a_i b_i^p = 1 的实数解，则 \\begin{aligned} T(x) &= \\Theta \\left(x^p \\left( 1 + \\int_1^x \\frac{g(u)}{u^{p+1}} du\\right)\\right) \\end{aligned} 该定理在Akra-Bazzi的基础上，进一步考虑了递归式参数中带余项的情况，因此适用面更广。与Akra-Bazzi类似，其正确性同样可以使用数学归纳法验证，不过篇幅较长，这里就不详细阐述了。","categories":[{"name":"算法","slug":"算法","permalink":"http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://gonggongjohn.me/tags/Algorithm/"}]},{"title":"斐波那契数的相关算法","slug":"fibonacci","date":"2020-10-30T15:29:04.000Z","updated":"2021-01-21T07:10:05.314Z","comments":true,"path":"2020/10/30/fibonacci/","link":"","permalink":"http://gonggongjohn.me/2020/10/30/fibonacci/","excerpt":"斐波那契数列斐波那契数列由以下递推式定义： \\left\\{ \\begin{aligned} &F(0)=0 \\\\ &F(1)=1 \\\\ &F(n)=F(n-1)+F(n-2),n \\geq 2 \\end{aligned} \\right.","text":"斐波那契数列斐波那契数列由以下递推式定义： \\left\\{ \\begin{aligned} &F(0)=0 \\\\ &F(1)=1 \\\\ &F(n)=F(n-1)+F(n-2),n \\geq 2 \\end{aligned} \\right. 下面我们来推导斐波那契数列的通项公式 设矩阵 M=\\begin{pmatrix} m_{11} & m_{12} \\\\ m_{21} & m_{22} \\end{pmatrix}，使得 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} =M \\begin{pmatrix} F_{n} \\\\ F_{n-1} \\end{pmatrix} 故 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} =\\begin{pmatrix} m_{11} & m_{12} \\\\ m_{21} & m_{22} \\end{pmatrix} \\begin{pmatrix} F_{n} \\\\ F_{n-1} \\end{pmatrix} =\\begin{pmatrix} m_{11}F_{n}+m_{12}F_{n-1} \\\\ m_{21}F_{n}+m_{22}F_{n-1} \\end{pmatrix}对比等式左右可得 m_{11}=m_{12}=m_{21}=1,m_{22}=0，即 M=\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} 由此可知 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} =\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} F_{n} \\\\ F_{n-1} \\end{pmatrix}对该矩阵等式做递推，可得 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} =\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^n \\begin{pmatrix} F_{1} \\\\ F_{0} \\end{pmatrix} =\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^n \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}易知 \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} 的特征多项式 f(\\lambda) = \\begin{vmatrix} \\lambda - 1 & -1 \\\\ -1 & \\lambda \\end{vmatrix} = \\lambda^2 - \\lambda - 1 令 f(\\lambda) = 0，可得该矩阵的特征值 \\lambda_1 = \\frac{1 - \\sqrt{5}}{2}, \\lambda_2 = \\frac{1 + \\sqrt{5}}{2} 由此可知该矩阵可相似对角化 对于 \\lambda_1 = \\frac{1-\\sqrt{5}}{2}，其对应的特征向量 \\alpha_1 = \\left(\\frac{1-\\sqrt{5}}{2},1\\right) 对于 \\lambda_2 = \\frac{1+\\sqrt{5}}{2}，其对应的特征向量 \\alpha_2 = \\left(\\frac{1+\\sqrt{5}}{2},1\\right) 故若令 P=\\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & \\frac{1+\\sqrt{5}}{2} \\\\ 1 & 1 \\end{pmatrix}，则 \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} =P \\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & 0\\\\ 0 & \\frac{1+\\sqrt{5}}{2} \\end{pmatrix} P^{-1}于是 \\begin{aligned} \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} &=P \\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & 0\\\\ 0 & \\frac{1+\\sqrt{5}}{2} \\end{pmatrix}^n P^{-1} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\\\ &=\\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & \\frac{1+\\sqrt{5}}{2} \\\\ 1 & 1 \\end{pmatrix} \\begin{pmatrix} \\left(\\frac{1-\\sqrt{5}}{2}\\right)^n & 0\\\\ 0 & \\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\end{pmatrix} \\begin{pmatrix} -\\frac{1}{\\sqrt{5}} & \\frac{5 + \\sqrt{5}}{10} \\\\ \\frac{1}{\\sqrt{5}} & \\frac{5 - \\sqrt{5}}{10} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\\\ &=\\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & \\frac{1+\\sqrt{5}}{2} \\\\ 1 & 1 \\end{pmatrix} \\begin{pmatrix} -\\frac{1}{\\sqrt{5}}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n \\\\ \\frac{1}{\\sqrt{5}}\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\end{pmatrix} \\\\ &=\\begin{pmatrix} \\frac{\\sqrt{5}-1}{2\\sqrt{5}}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n + \\frac{\\sqrt{5}+1}{2\\sqrt{5}}\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\\\ -\\frac{1}{\\sqrt{5}}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n + \\frac{1}{\\sqrt{5}}\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\end{pmatrix} \\end{aligned}由此我们得到了斐波那契数列的通项公式 F_n = \\frac{1}{\\sqrt{5}} \\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^n \\right]朴素递归算法朴素递归算法即为递推式定义的程序表达，采用递归的方法实现。代码如下： 12345int Fibonacci(int n)&#123; if(n == 0) return 0; else if(n == 1) return 1; else return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 易得该算法时间复杂度的递推表达式为 T(n)=T(n-1)+T(n-2)+\\Theta(1) 观察递归树可以发现，所有叶子结点的和就是 \\Theta(F_n) ，而所有内部节点的和为 \\Theta(F_n-1) 故朴素递归算法的时间复杂度 \\begin{aligned} T(n)&=\\Theta(F_n) + \\Theta(F_n-1) \\\\ &=\\Theta(F_n) \\\\ &=\\Theta\\left(\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n\\right) \\\\ &=\\mathcal{O}(1.62^n) \\end{aligned}自下而上算法朴素递归算法的时间复杂度为指数级，这显然是难以接受的。观察发现朴素递归算法的主要问题是重复求解了许多子问题，其本质原因在于朴素递归算法是自上而下的求解子问题，而不同子问题中重叠的部分无法相互影响。故我们换一种思路，自下而上的求解，就可以很好的解决这一问题。代码如下： 123456789int Fibonacci(int n)&#123; int a[N]; //N is the biggest possible value a[0] = 0; a[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; a[i] = a[i - 1] + a[i - 2]; &#125; return a[n];&#125; 易知该算法的时间复杂度 T(n)=n-1=\\Theta(n) 矩阵快速幂算法自下而上算法已经将原本的指数级时间复杂度降低到了多项式级，我们希望能够进一步的将其降低到对数级别。自然的，我们首先想到的是利用其通项公式并通过快速幂的方法来求解。但斐波那契数列的通项公式中包含无理数，由于计算机的精度限制，计算结果可能并不正确，故这种方法显然是不可靠的。 注：事实上，若不存在精度限制的问题，斐波那契数列还可以表示为 F_n = \\left[ \\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\right] （其中 [x] 表示取整到离 x 最近的整数） 于是问题转化为是否存在一个仅需在整数域内进行运算的斐波那契通项公式。回顾上面求解斐波那契数列通项公式的过程，注意到 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^n \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}，故我们可以通过求解该矩阵来得到 F_n 的值。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839struct matrix&#123; int a[2][2]; matrix(int a11, int a12, int a21, int a22)&#123; a[0][0] = a11; a[0][1] = a12; a[1][0] = a21; a[1][1] = a22; &#125;&#125;;//This function can only handle 2*2 matrix multiplicationmatrix matrixMult(matrix matA, matrix matB)&#123; matrix matR(0, 0, 0, 0); for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k =0; k &lt; 2; k++) matR.a[i][j] += matA.a[i][k] * matB.a[k][j]; return matR;&#125;matrix matrixPow(matrix mat, int n)&#123; if(n == 1) return mat; if(n % 2 == 0)&#123; matrix matT = matrixPow(mat, n / 2); return matrixMult(matT, matT); &#125; else&#123; matrix matT1 = matrixPow(mat, (n - 1) / 2); matrix matT2 = matrixMult(matT1, matT1); return matrixMult(matT2, mat); &#125;&#125;int Fibonacci(int n)&#123; if(n == 0) return 0; else if(n == 1) return 1; else&#123; matrix matT(1, 1, 1, 0); matrix matR = matrixPow(matT, n); return matR.a[1][0]; &#125;&#125; 分析该算法，发现其时间复杂度的递推表达式为 T(n) = T\\left(\\frac{n}{2}\\right) + \\Theta(1)。故由主定理可知该矩阵快速幂算法的时间复杂度为 T(n) = \\Theta(\\lg n)","categories":[{"name":"算法","slug":"算法","permalink":"http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://gonggongjohn.me/tags/Algorithm/"}]},{"title":"和式的求解方法","slug":"sum-solve","date":"2020-10-11T12:40:02.000Z","updated":"2020-10-11T12:44:47.214Z","comments":true,"path":"2020/10/11/sum-solve/","link":"","permalink":"http://gonggongjohn.me/2020/10/11/sum-solve/","excerpt":"扰动法扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。","text":"扰动法扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。 令 S_n = \\sum_\\limits{0 \\leq k \\leq n} a_k \\begin{aligned} S_n + a_{n+1} &= \\sum_\\limits{0 \\leq k \\leq n+1} a_k \\\\ &= a_0 + \\sum_\\limits{1 \\leq k \\leq n+1} a_k \\\\ &= a_0 + \\sum_\\limits{1 \\leq k+1 \\leq n+1} a_{k+1} \\\\ &= a_0 + \\sum_\\limits{0 \\leq k \\leq n} a_{k+1} \\end{aligned}若能将 \\sum_\\limits{0 \\leq k \\leq n} a_{k+1} 写为 S_n 的表达式，即可求出该求和式的通项公式 Example1: 求等比数列和 S_n = \\sum_\\limits{0 \\leq k \\leq n} a q^k \\ \\ (q \\neq 1) 的通项公式 解： 由上述公式可知 \\begin{aligned} S_n + a_{n+1} &= a + \\sum_\\limits{0 \\leq k \\leq n} aq^{k+1} \\\\ &=a + q \\sum_\\limits{0 \\leq k \\leq n} aq^k \\\\ &=a + q S_n \\end{aligned}从而 $(1-q)S_n = a - aq^{n+1}$ 故 $S_n = \\frac{a\\left(1-q^{n+1} \\right)}{1-q} \\ \\ (q \\neq 1)$ Example2: 求等比差数列和 S_n = \\sum_\\limits{0 \\leq k \\leq n} k \\cdot q^k \\ \\ (q \\neq 1) 的通项公式 解： 由上述公式可知 \\begin{aligned} S_n + a_{n+1} &= 0 + \\sum_\\limits{0 \\leq k \\leq n} (k+1) \\cdot q^{k+1} \\\\ &=\\sum_\\limits{0 \\leq k \\leq n} k \\cdot q^{k+1} + \\sum_\\limits{0 \\leq k \\leq n} q^{k+1} \\\\ &=q \\sum_\\limits{0 \\leq k \\leq n} k \\cdot q^k + q \\sum_\\limits{0 \\leq k \\leq n} q^k \\\\ &=q S_n + q \\cdot \\frac{1-q^{n+1}}{1-q} \\end{aligned}从而 $(1-q)S_n = \\frac{q-q^{n+2}}{1-q} - (n+1) \\cdot q^{n+1}$ 故 \\begin{aligned} S_n &= \\frac{q-q^{n+2}}{(1-q)^2} - \\frac{(n+1) \\cdot q^{n+1}}{1-q} \\\\ &= \\frac{q-(n+1)q^{n+1} + nq^{n+2}}{(1-q)^2} \\ \\ (q \\neq 1) \\end{aligned}","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.me/tags/Mathematics/"},{"name":"Sequence","slug":"Sequence","permalink":"http://gonggongjohn.me/tags/Sequence/"}]},{"title":"递归式的解法","slug":"recursion-solve","date":"2020-10-11T12:39:48.000Z","updated":"2020-10-11T12:52:00.138Z","comments":true,"path":"2020/10/11/recursion-solve/","link":"","permalink":"http://gonggongjohn.me/2020/10/11/recursion-solve/","excerpt":"求和因子法对于形如 a_n T_n = b_n T_{n-1} + c_n，我们可以求出其通项公式，下面我们来推导这一公式。 我们考虑通过变量替换的方式将 T_n 前的 a_n 和 b_n 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 b_n T_{n-1} 能够通过 a_n T_n 表示出来（该表达式通常被称为求和因子）。设该表达式为 s_n，两边同乘以 s_n，即为 s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n","text":"求和因子法对于形如 a_n T_n = b_n T_{n-1} + c_n，我们可以求出其通项公式，下面我们来推导这一公式。 我们考虑通过变量替换的方式将 T_n 前的 a_n 和 b_n 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 b_n T_{n-1} 能够通过 a_n T_n 表示出来（该表达式通常被称为求和因子）。设该表达式为 s_n，两边同乘以 s_n，即为 s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n 注意到等式左边均为第 $n$ 项，而右边为 T_{n-1}，故考虑将右边第一项变为 s_{n-1}a_{n-1}T_{n-1}。要做到这一点，就是要让 s_n b_n = s_{n-1} a_{n-1}，也即 s_n = s_{n-1} \\cdot \\frac{a_{n-1}}{b_n}。做递推，得到 s_n = \\frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2} \\cdot s_1。故仅需取 s_n = \\frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2} 或该式的常数倍即可。 现在，我们仅需令 P_n = s_n a_n T_n，即可将原式化简为 P_n = P_{n-1} + s_n c_n 故 P_n = P_0 + \\sum_\\limits{k=1}^n s_k c_k 故 s_n a_n T_n = s_0 a_0 T_0 + \\sum_\\limits{k=1}^n s_kc_k = s_1b_1T_0 + \\sum_\\limits{k=1}^n s_kc_k 故 T_n = \\frac{1}{s_n a_n} \\left( s_1b_1T_0 + \\sum_\\limits{k=1}^n s_kc_k \\right) Example: 已知Hanoi问题满足以下递归表达式，试求出其通项公式 \\left\\{ \\begin{aligned} &T_0 = 0 \\\\ &T_n = 2T_{n-1} + 1 \\end{aligned} \\right.解： 由 $a_n = 1, b_n = 2$ 可知求和因子 $s_n = \\frac{1}{2^{n-1}}$。由于 $s_n$ 乘以常数倍不影响其效果 ，故为了方便起见令 $s_n = \\frac{1}{2^n}$ 两边同乘以 s_n = \\frac{1}{2^n}，得到 \\frac{T_n}{2^n} = \\frac{T_{n-1}}{2^{n-1}} + \\frac{1}{2^n} 令$P_n = \\frac{T_n}{2^n}$，则 \\left\\{ \\begin{aligned} &P_n = P_{n-1} + \\frac{1}{2^n} \\\\ &P_0 = 0 \\end{aligned} \\right.故 P_n = \\sum_\\limits{k=1}^n \\frac{1}{2^k} = 1-\\left(\\frac{1}{2}\\right)^n，即 \\frac{T_n}{2^n} = 1-\\left(\\frac{1}{2}\\right)^n 故 T_n = 2^n - 1","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.me/tags/Mathematics/"},{"name":"Sequence","slug":"Sequence","permalink":"http://gonggongjohn.me/tags/Sequence/"}]},{"title":"快速排序时间复杂度分析","slug":"qsort-analyze","date":"2020-10-10T07:46:07.000Z","updated":"2021-01-21T07:09:44.427Z","comments":true,"path":"2020/10/10/qsort-analyze/","link":"","permalink":"http://gonggongjohn.me/2020/10/10/qsort-analyze/","excerpt":"随机化快速排序随机化快速排序在快速排序的基础上，通过随机数选择一个数作为pivot，使得没有特定的输入数据可以使得该算法达到最坏情况。 下面我们来分析其平均时间复杂度。","text":"随机化快速排序随机化快速排序在快速排序的基础上，通过随机数选择一个数作为pivot，使得没有特定的输入数据可以使得该算法达到最坏情况。 下面我们来分析其平均时间复杂度。 设 X_k 为一个随机变量，使得对任意 k=0,1,...,n-1，有 X_k = \\left\\{ \\begin{aligned} 1 &, &if \\ Partition \\ generates \\ (k:n-k-1) \\ split \\\\ 0 &, &otherwise \\end{aligned} \\right.若随机数生成每个数的概率相同，则 \\begin{aligned} E[X_k] &= 0 \\cdot \\Pr \\{X_k = 0\\} + 1 \\cdot \\Pr \\{X_k = 1\\} \\\\ &=\\Pr\\{X_k = 1\\} \\\\ &=\\frac{1}{n} \\end{aligned}设 T(n) 为一个代表总运行时间的随机变量（假设所有的情况均为独立的） 即 T(n) = \\left\\{ \\begin{aligned} T(0) + T(n-1) + \\Theta(n) &, &if \\ Partition \\ generates \\ (0:n-1) \\ split \\\\ T(1) + T(n-2) + \\Theta(n) &, &if \\ Partition \\ generates \\ (1:n-2) \\ split \\\\ ...... \\\\ T(n-1) + T(0) + \\Theta(n) &, &if \\ Partition \\ generates \\ (n-1:0) \\ split \\end{aligned} \\right.通过引入 X_k，我们可以把 T(n) 改写为一个和式 T(n) = \\sum_\\limits{k=0}^{n-1} X_k \\left( T(k) + T(n-k-1) + \\Theta(n) \\right)故 \\begin{aligned} E[T(n)] &= E \\left[\\sum_\\limits{k=0}^{n-1} X_k \\left( T(k) + T(n-k-1) + \\Theta(n) \\right) \\right] \\\\ &=\\sum_\\limits{k=0}^{n-1} E \\left[ X_k \\left( T(k) + T(n-k-1) + \\Theta(n) \\right) \\right] \\\\ &=\\sum_\\limits{k=0}^{n-1} E \\left[ X_k \\right] \\cdot E\\left[ \\left( T(k) + T(n-k-1) + \\Theta(n)\\right) \\right] \\\\ &=\\frac{1}{n} \\sum_\\limits{k=0}^{n-1} E[T(k)] + \\frac{1}{n} \\sum_\\limits{k=0}^{n-1} E[T(n-k-1)] + \\frac{1}{n} \\sum_\\limits{k=0}^{n-1} E[\\Theta(n)] \\\\ &=\\frac{2}{n} \\sum_\\limits{k=0}^{n-1} E[T(k)] + \\Theta(n) \\end{aligned}由此我们得到了一个关于 E[T(n)] 的递推式。下面我们使用第二数学归纳法证明：当 n \\geq 3 时，存在 a>0，使得 E[T(n)] \\leq an \\lg n 为了方便起见，我们首先对原式进行适当变形 \\begin{aligned} E[T(n)] &=\\frac{2}{n} \\sum_\\limits{k=0}^{n-1} E[T(k)] + \\Theta(n) \\\\ &=\\frac{2}{n}E[T(0)] + \\frac{2}{n}E[T(1)] + \\frac{2}{n} \\sum_\\limits{k=2}^{n-1} E[T(k)] + \\Theta(n) \\\\ &=\\frac{2}{n} \\sum_\\limits{k=2}^{n-1} E[T(k)] + \\Theta(n) \\end{aligned}随后，我们需要一个引理 Lemma: \\sum_\\limits{k=2}^{n-1} k \\lg k \\leq \\frac{1}{2}n^2 \\lg n - \\frac{1}{8} n^2证明：令 f(x) = x \\lg x 则 f'(x) = \\lg k + \\frac{1}{\\ln 2} 故当 x \\geq 2 时 f(x)>0 且 f(x) 单调递增 因此 \\begin{aligned} \\sum_\\limits{k=2}^{n-1} k \\lg k &\\leq \\int_2^n x \\lg x dx \\\\ &=\\frac{1}{2} \\int_2^n \\lg x d(x^2) \\\\ &=\\frac{1}{2} \\left(\\left[x^2 \\lg x\\right]\\Big|_2^n - \\int_2^n x^2 \\cdot \\frac{1}{x \\ln 2} dx\\right) \\\\ &=\\frac{1}{2} \\left( n^2 \\lg n - 4 - \\frac{1}{2 \\ln 2} \\cdot \\left[x^2\\right]\\Big|_2^n\\right) \\\\ &=\\frac{1}{2}n^2 \\lg n - \\frac{1}{4 \\ln 2}n^2 -2 + \\frac{1}{\\ln 2} \\\\ &\\leq \\frac{1}{2}n^2 \\lg n -\\frac{1}{4\\ln2}n^2 \\\\ &\\leq \\frac{1}{2}n^2 \\lg n - \\frac{1}{8}n^2 \\end{aligned} 现在就可以对 n 进行归纳了 当 n=3 时，E[T(3)]=\\Theta(1)，仅需取一足够大的 a，则结论显然成立 若对 \\forall k < n，存在 a>0 使得 E[T(n)] \\leq ak \\lg k 成立 则 \\begin{aligned} E[T(n)] &\\leq \\frac{2}{n} \\sum_\\limits{k=2}^{n-1} ak \\lg k + \\Theta(n) \\\\ &\\leq \\frac{2a}{n} \\cdot \\left( \\frac{1}{2}n^2 \\lg n - \\frac{1}{8}n^2\\right) + \\Theta(n) \\\\ &=an \\lg n - \\frac{an}{4} + \\Theta(n) \\end{aligned}故仅需取一足够大的 a 使得 \\frac{an}{4}> \\Theta(n)，即可使得 E[T(n)] \\leq an \\lg n 因此 E[T(n)] \\leq an \\lg n 对 \\forall n \\geq 3 均成立 由此可知 E[T(n)] = \\mathcal{O}(n \\lg n) 同理可得 E[T(n)] = \\Omega(n\\lg n) 故 E[T(n)] = \\Theta(n \\lg n) 事实上，原始的快速排序中Partition的操作次数为 n+1 次，故总运行时间的期望还可以进一步写成以下递推式 \\left\\{ \\begin{aligned} &E[T(0)] = 0 \\\\ &E[T(n)] = \\frac{2}{n}\\sum_\\limits{k = 0}^{n-1} E[T(k)] + n+1 \\ \\ (n \\geq 1) \\end{aligned} \\right.下面我们来尝试推导该递推式的封闭解 首先将原式化简为整式，得到 n \\cdot E[T(n)] = 2 \\sum_\\limits{k=0}^{n-1} E[T(k)] + n^2+n 注意到等式右边有一个连续的求和式（即从 E[T(0)] 到 E[T(n-1)] 中没有缺项），故考虑做差项消去该求和式。 \\left\\{ \\begin{aligned} &n \\cdot E[T(n)] = 2 \\sum_\\limits{k=0}^{n-1} E[T(k)] + n^2+n \\\\ &(n-1) \\cdot E[T(n-1)] = 2 \\sum_\\limits{k=0}^{n-2} E[T(k)] + (n-1)^2+(n-1) \\end{aligned} \\right.两式相减，得到 $n \\cdot E[T(n)] - (n-1) \\cdot E[T(n-1)] = 2n + 2 \\cdot E[T(n-1)]$ 化简得到 n \\cdot E[T(n)] = (n+1) \\cdot E[T(n-1)] + 2n 接下来我们考虑将 E[T(n)] 和 E[T(n-1)] 前的系数消去以找出通项公式。 两边同时乘以 \\frac{2}{n(n+1)} ，得到 \\frac{2}{n+1} \\cdot E[T(n)] = \\frac{2}{n} \\cdot E[T(n-1)] + \\frac{4}{n+1} 令 S_n = \\frac{2}{n+1} \\cdot E[T(n)]，于是原递归式化简为 \\left\\{ \\begin{aligned} & S_0 = 0 \\\\ & S_n = S_{n-1} + \\frac{4}{n+1} \\end{aligned} \\right.我们可以快速写出该递归式的通项公式 S_n = 4\\sum_\\limits{k=2}^{n+1} \\frac{1}{k} 即 $\\frac{2}{n+1} \\cdot E[T(n)] = 4\\sum_\\limits{k=2}^{n+1} \\frac{1}{k}$ 化简即得 $E[T(n)] = 2(n+1)\\sum_\\limits{k=2}^{n+1} \\frac{1}{k}$ 引入调和级数符号 $H_n = 1 + \\frac{1}{2} + \\frac{1}{3} + … + \\frac{1}{n}$ 注意到 $\\sum_\\limits{k=2}^{n+1} \\frac{1}{k} = H_n - 1 + \\frac{1}{n+1}$ 故我们得到了原递推式的封闭解 E[T(n)] = 2(n+1)H_n - 2n 又由 $H_n = \\ln n + \\gamma + \\mathcal{O}\\left(\\frac{1}{n} \\right)$ 故可得 \\begin{aligned} E[T(n)] &= 2(n+1)\\left(\\ln n + \\gamma + \\mathcal{O} \\left(\\frac{1}{n} \\right)\\right) - 2n \\\\ &= 2n \\ln n + 2(\\gamma - 1)n + 2\\ln n + 2\\gamma + \\mathcal{O}(1) + \\mathcal{O}\\left(\\frac{1}{n}\\right) \\\\ &= \\Theta \\left( n \\ln n \\right) \\\\ &= \\Theta \\left( n \\lg n\\right) \\end{aligned}由此我们得到了快速排序的平均时间复杂度为 $\\Theta (n \\lg n)$","categories":[{"name":"算法","slug":"算法","permalink":"http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://gonggongjohn.me/tags/Algorithm/"}]},{"title":"《深入理解计算机系统》笔记整理（一）","slug":"csapp-01","date":"2020-10-07T14:31:17.000Z","updated":"2020-10-11T12:39:08.176Z","comments":true,"path":"2020/10/07/csapp-01/","link":"","permalink":"http://gonggongjohn.me/2020/10/07/csapp-01/","excerpt":"Chapter 2：信息的表示和处理基本概念进制转换进位计数制定义：设一个 $m$ 进制下$w$ 位的位向量表示为 [a_{w-1}, a_{w-2}, ..., a_0]，则其表示的数为 $\\sum_\\limits{i=0}^{w-1} a_im^i$ $m$ 进制 $\\rightarrow$ 十进制 设一个 $w$ 位 $m$ 进制整数的位相量表示为 \\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ] ，定义函数 $M2D(\\vec{x}) = \\sum_\\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\\vec{x})$","text":"Chapter 2：信息的表示和处理基本概念进制转换进位计数制定义：设一个 $m$ 进制下$w$ 位的位向量表示为 [a_{w-1}, a_{w-2}, ..., a_0]，则其表示的数为 $\\sum_\\limits{i=0}^{w-1} a_im^i$ $m$ 进制 $\\rightarrow$ 十进制 设一个 $w$ 位 $m$ 进制整数的位相量表示为 \\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ] ，定义函数 $M2D(\\vec{x}) = \\sum_\\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\\vec{x})$ 证明：由进位计数制的定义可直接得到结论 Example: 将 $3$ 进制数 $12011$ 转为十进制数 解： 令 $\\vec{x} = [1,2,0,1,1], m = 3$ \\begin{align} \\therefore n = M2D(\\vec{x}) &= 1 \\cdot 3^4 + 2 \\cdot 3^3 + 1 \\cdot 3^1 +1 \\cdot 3^0 \\\\ &= 81+54+3+1 \\\\ &= 139 \\end{align}故 12011_3 = 139_{10} 十进制 $\\rightarrow$ $m$ 进制 设一个十进制整数为 $n$，定义序列 \\begin{align} &p_0 = \\lfloor \\frac{n}{m} \\rfloor, \\ r_0 = n \\ \\ mod \\ \\ m \\\\ &p_1 = \\lfloor \\frac{p_0}{m}\\rfloor, \\ r_1 = p_0 \\ \\ mod \\ \\ m \\\\ &... \\\\ &p_{s-1} = \\lfloor \\frac{p_{s-2}}{m}\\rfloor = 0, \\ r_{s-1} = p_{s-2} \\ \\ mod \\ \\ m \\\\ \\end{align}则其对应的 $m$ 进制数的位向量表示为 \\vec{x} = [r_{s-1}, r_{s-2}, ..., r_0] 证明：设 $n$ 在 $m$ 进制下的位相量表示为 [r_{s-1}, r_{s-2}, ..., r_0] 则由定义可知，n = r_{s-1} \\cdot m^{s-1} + r_{s-2} \\cdot m^{s-2} + ...+ r_0 故 n = m \\cdot \\left( r_{s-1} \\cdot m^{s-2} + r_{s-2} \\cdot m^{s-3} + ... + r_1 \\right) + r_0 故 $r_0 = n \\ \\ mod \\ \\ m$ 又由 \\begin{align} p_0 = \\lfloor \\frac{n}{m} \\rfloor &= r_{s-1} \\cdot m^{s-2} + r_{s-2} \\cdot m^{s-3} + ... + r_1 \\\\ &= m \\cdot \\left( r_{s-1} \\cdot m^{s-3} + r_{s-2} \\cdot m^{s-4} + ... + r_2 \\right) + r_1 \\end{align}故 $r_1 = p_0 \\ \\ mod \\ \\ m$ 以此类推，r_{i} = p_{i-1} \\ \\ mod \\ \\ m \\ (i=s-2, ..., 1) 故结论成立 Example: 将十进制数 $508$ 转为八进制数 解： \\begin{align} 508 &= 63 * 8 + 4 \\\\ 63 &= 7 * 8 + 7 \\\\ 7 &= 0 * 8 + 7 \\end{align}故 $508_{10} = 774_8$ 信息的存储字长（Word Size）在计算机中，字（Word）是用来表示一次性处理数据的固定长度。字的位数称为字长（Word Size）。字长是计算机系统中的一个重要指标，字长的大小决定了虚拟地址空间的最大大小。 对于一个字长为 $w$ 的机器来说，其虚拟地址的范围为 $0$ ～ $2^w-1$，即可以存储 $2^w$ 个字节 Example: 字长为32的机器的虚拟地址范围为 $0$ ～ $2^{32}-1$，可以存储 $2^{32}$ 个字节 小端序（Little Endian）和大端序（Big Endian）超过一个字节的数据在计算机中有两种排列顺序：小端序（Little Endian）和大端序（Big Endian）。 小端序：将较低的有效字节放在较小的内存地址中。 大端序：将较低的有效字节放在较大的内存地址中。 Example: 原始数据：12 34 56 78 小端序存储：12 34 56 78 大端序存储：78 56 34 12 注：使用ASCII码存储的字符数据在任何系统上都能得到相同的结果，不受端序的影响。 基本运算位级运算计算机中有以下四种基本位级运算：按位与（&amp;），按位或（|），按位非（~），按位异或（^），其规则与布尔代数中的规则一致。 Example: 101100 &amp; 100110 = 100100 101100 | 100110 = 101110 ~101100 = 010011 101100 ^ 100110 = 001010 逻辑运算计算机中提供了以下三种逻辑运算：且（&amp;&amp;），或（||），非（!），其规则与命题逻辑中的规则一致。 注：C语言中的逻辑运算有提早终止（Early Termination）的机制，即当两个表达式做逻辑运算时，若前一个表达式已经能确定最终结果，则不再计算后一个表达式。 Example: (1+1=2) &amp; (3=3) = 1 (1-1=0) || (1=2) = 1 !(2*5=10) = 0 !0x3F = 0 位移运算计算机中提供了三种位移操作：左移（&lt;&lt;），逻辑右移（&gt;&gt;），算术右移（&gt;&gt;） $x$ 左移 $k$ 位：将 $x$ 的最高 $k$ 位丢弃并在最低位后补充 $k$ 个零，相当于 $x \\cdot 2^k$ $x$ 逻辑右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个零，相当于 $\\lfloor \\frac{x}{2^k} \\rfloor$ 算术右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个最高位值 整数的存储与运算无符号整数二进制数码不表示符号信息的整数称为无符号整数，其代码的数字与常规的进位计数制规则一致。即若定义 B2U_w(\\vec{x}) = \\sum_\\limits{i=0}^{w-1}x_i 2^i，则一个 $w$ 位的二进制位相量 $\\vec{x}$ 所对应的十进制数 $n = B2U_w(\\vec{x})$ 由定义可知，一个 $w$ 位的二进制位相量 $\\vec{x}$ 可表示的整数范围为 $0$ ～ $2^w-1$ 有符号整数有符号整数是采用补码进行存储的整数。补码是对二进制的一种新的解读方式，其严格的定义如下：若定义 B2T_w(\\vec{x}) = -x_{w-1} 2^{w-1} + \\sum_\\limits{i=0}^{w-2}x_i 2^i，则一个 $w$ 位的二进制位相量 $\\vec{x}$ 所对应的十进制数 $n = B2T_w(\\vec{x})$。通俗来说，补码将原本 $0$ ～ $2^w-1$ 中 $2^{w-1}$ ～ $2^{w} - 1$ 的部分重新解读为负数，从而使得其可以表示负数。从取模的角度来看， 对于一个 $0$ ～ $2^{w-1} - 1$ 中的数 $n$ 和一个 $2^{w-1}$ ～ $2^{w} - 1$ 中的数 $m$，$(n + m) \\ \\ mod \\ \\ 2^w = n - (2^w - m)$，故这样定义是合适的。且容易看出其与无符号整数间的转换关系为 U2T(x) = \\left\\{ \\begin{aligned} &x &, &0 \\leq x \\leq 2^{w-1} - 1 \\\\ &x - 2^w &, &2^{w-1} \\leq x \\leq 2^w - 1 \\end{aligned} \\right. T2U(x) = \\left\\{ \\begin{aligned} &x &, & 0 \\leq x \\leq 2^{w-1}-1 \\\\ &x + 2^w &, & -2^{w-1} \\leq x \\leq -1 \\end{aligned} \\right.证明：设二进制位向量 $\\vec{x}$ 当 0 \\leq B2U_w(\\vec{x}) \\leq 2^{w-1} - 1 时 x_{w-1} = 0此时 B2T_w(\\vec{x}) = \\sum_\\limits{i=0}^{w-2}x_i 2^i = B2U_w(\\vec{x}) 故 U2T_w(x) = x 当 2^{w-1} \\leq x \\leq 2^w - 1 时 x_{w-1} = 1此时 \\left\\{ \\begin{aligned} B2T_w(\\vec{x}) &= -2^{w-1} + \\sum_\\limits{i=0}^{w-2}x_i 2^i \\\\ B2U_w(\\vec{x}) &= 2^{w-1} + \\sum_\\limits{i=0}^{w-2}x_i 2^i \\end{aligned} \\right.故 B2T_w(\\vec{x}) = B2U_w(\\vec{x}) - 2^w 故 U2T_w(\\vec{x}) = x - 2^w T2U(x)的情况同理可证 注：无符号或有符号整数仅为二进制解读为十进制时的不同解读方式，由于计算机在二进制层面进行运算，故计算机在进行底层运算时并不区分这两种解读方式。","categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"CSAPP","slug":"CSAPP","permalink":"http://gonggongjohn.me/tags/CSAPP/"}]},{"title":"GDB使用指南","slug":"gdb-guide","date":"2020-09-19T04:24:40.000Z","updated":"2020-09-28T08:06:30.878Z","comments":true,"path":"2020/09/19/gdb-guide/","link":"","permalink":"http://gonggongjohn.me/2020/09/19/gdb-guide/","excerpt":"GDB使用指南GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。 GDB官网：GDB: The GNU Project Debugger","text":"GDB使用指南GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。 GDB官网：GDB: The GNU Project Debugger GDB和LLDBLLDB是一款开源的具有REPL（Read-Evaluation-Print-Loop）特征的调试工具，相比GDB在部分场景下更加先进和高效。Xcode自4.3版本后默认内置了LLDB，因此macOS用户可以直接使用LLDB对程序进行调试。（当然macOS同样也可以安装GDB调试工具） GDB与LLDB命令对照表：GDB to LLDB command map WINDOWS下安装GCC和GDBMinGW（Minimalist GNU For Windows）是Windows下的一个小型GNU工具集。新版MinGW中集成了GCC和GDB的相关工具，因此只需安装MinGW即可使用GCC和GDB。 下载MinGW及GCC包首先前往MinGW官方网站：MinGW 并在Download界面下载MinGW管理工具。 安装MinGW管理工具并打开。 选择所需的工具集，点击左上角的Installation-&gt;Apply Changes即可安装。（由于受国内网络环境影响，可能会出现下载失败的情况，可以多尝试几次或使用其他网络连接方式下载）。若使用C/C++进行开发，通常仅需安装mingw32-base-bin及mingw32-gcc-g++-bin即可。 配置系统环境变量安装完成后，我们需要配置系统环境变量使得其可以在CMD中执行。 右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量，在系统变量框中找到Path变量，选择编辑，在最后新增一行填入你的MinGW安装路径\\bin，确定退出。 打开CMD，输入gcc -v及gdb -v，若显示相关版本信息，表明环境变量配置成功。 在其他IDE中调用GDBCLionCLion本身已经集成了十分完善的可视化调试工具，但如果想在CLion中使用GDB或LLDB调试程序同样十分方便。 使用通常的方法在需要的地方打上断点启动调试，在下方的Debug窗口中就可以看到GDB/LLDB窗口，在其中输入命令即可。 Visual Studio CodeVSCode本身并不自带GCC和GDB的相关功能，因此使用VSCode进行调试同样需要额外安装GDB/LLDB调试工具。不过，VSCode提供了一个可视化的C/C++调试插件，相比命令行调试会直观很多。该插件可直接在插件商店里搜索并安装。 和其他大型IDE类似，VSCode将一个目录视为一个项目，因此在创建项目时，你需要指定一个空的文件夹来存放项目文件（这也是一些人装了辅助插件却被提示要手动配置调试文件的一大重要原因）。在第一次运行程序时，选择Run-&gt;Start Debugging，在弹出的选项框中选择一个要使用的调试环境及编译环境，VSCode就会自动在当前的项目目录下创建相应的配置文件。（当然也可以手动指定配置文件，具体配置方法可参考VSCode官方文档） 随后即可在调试界面中看到相关的调试信息。你也可以在下方的Debug Console中输入相关的GDB/LLDB命令来进行进一步的调试。 GDB的基本使用启动调试若要使用GDB来调试程序，需要在使用GCC编译源文件的时候打开-g选项。 1gcc -g [源文件名] -o [目标文件名] Example: 1gcc -g test.c -o test 若不打开调试选项，则在调试时无法添加断点。 使用gdb打开生成的可执行文件即可开始调试。 1gdb [目标文件名] GDB还可以关联正在运行的程序进行调试。我们可以通过ps命令查询目标进程的PID，随后进入GDB使用attach命令关联进程。 123ps -ef|grep [进程名]gdb(gdb) attach [PID] Linux用户在这一过程过可能会遇到权限不足的情况。解决方法：切换至root用户，进入/etc/stsctl.d/10-ptrace.conf中将kernel.yama.ptrace_scpoe = 1改为kernel.yama.ptrace_scpoe = 0即可。 添加断点通常在调试过程中，我们需要在程序的某个位置添加断点，并让程序运行到这一位置时自动暂停以分析程序当前的运行状态。在GDB环境下，我们可以通过break命令来快速添加断点。 12(gdb) break [源文件名称]:[行号] #执行到某一行时中断(gdb) break [函数名] #执行到某个函数时中断 Example: 12(gdb) break test.c:5(gdb) break main 有时我们希望程序在特定条件下中断，这个时候我们可以使用break+if或condition语句来设置条件断点。 1(gdb) break [中断位置] if 触发条件 Example: 1(gdb) break test.c:10 if a==5 12(gdb) break [中断位置](gdb) condition [断点号] [触发条件] Example: 12(gdb) break test.c:10(gdb) condition 1 a==5 我们可以使用info指令查看已设置断点的断点号及相关信息 1(gdb) info breakpoints 通过clear和delete命令可以删除已创建的断点。 1234(gdb) clear [目标文件名]:[行号] #删除某一行处的断点(gdb) clear [函数名] #删除某个函数处的断点(gdb) delete #删除所有断点(gdb) delete [断点号] #删除某一特定断点 Example: 12(gdb) clear test:5(gdb) delete 1 运行程序对于不需要向main函数传递参数的程序，可以直接使用run指令开始运行程序。 1(gdb) run 对于需要向main函数传递参数的程序，可以使用set args指令或直接在run后跟参数的方式运行程序。 12(gdb) set args [参数](gdb) run Example: 12(gdb) set args para1 para2 para3(gdb) run 1(gdb) run [参数] Example: 1(gdb) run para1 para2 para3 程序运行后，会一直运行至第一个断点处并暂停。若没有设置断点，则效果等同于直接运行程序。 当程序中断后，GDB提供了以下几种继续运行的指令。 12345(gdb) next #单步执行（不进入函数内部，等同于Clion中的Step Over）(gdb) step #单步进入（进入函数内部，等同于Clion的Step Into）(gdb) continue #继续执行至下一个断点处(gdb) until [行号] #继续执行直至某一行(gdb) finish #运行至程序结尾 查看变量及内存在程序中断时，GDB提供了一系列指令来查看当前变量及内存中的各种信息。 通过print指令可以打印变量或表达式的值 1(gdb) print &#x27;[源文件名/函数名]&#x27;::[变量名/表达式] Example: 123(gdb) print &#x27;main&#x27;::a(gdb) print &#x27;test.c&#x27;::b(gdb) print &#x27;main&#x27;::*p 通过display命令可以使得每次程序中断时自动打印某个变量或表达式的值 1(gdb) display [变量名/表达式] 此外，我们还可以通过watch指令追踪某一变量，使其值发生改变时中断程序 1(gdb) watch [变量名] 通过backtrace指令可以查看函数调用栈的存储情况及相关信息。 1(gdb) backtrace 更多其他命令的详细用法，可以通过help指令查询 1(gdb) help [命令]","categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"Language","slug":"Language","permalink":"http://gonggongjohn.me/tags/Language/"}]},{"title":"实数的严格定义","slug":"analysis-real-number","date":"2020-08-26T11:03:01.000Z","updated":"2021-01-21T07:09:14.876Z","comments":true,"path":"2020/08/26/analysis-real-number/","link":"","permalink":"http://gonggongjohn.me/2020/08/26/analysis-real-number/","excerpt":"","text":"对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。","categories":[{"name":"分析学","slug":"分析学","permalink":"http://gonggongjohn.me/categories/%E5%88%86%E6%9E%90%E5%AD%A6/"}],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.me/tags/Mathematics/"},{"name":"Analysis","slug":"Analysis","permalink":"http://gonggongjohn.me/tags/Analysis/"}]},{"title":"代数概念整理：映射","slug":"algebra-projection","date":"2020-07-31T07:00:00.000Z","updated":"2021-01-21T07:09:04.830Z","comments":true,"path":"2020/07/31/algebra-projection/","link":"","permalink":"http://gonggongjohn.me/2020/07/31/algebra-projection/","excerpt":"定义 设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个映射，记为 $f:X \\to Y$ ， $X$ 称为 $f$ 的定义域， $Y$ 称为 $f$ 的陪域 设 $f:X \\to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的象，记为 $f(a)$ ； $a$ 称为 $b$ 的原象，记为 $f^{-1}(b)$ ；集合 ${f(x) \\big| x \\in X}$ 称为 $f$ 的值域或 $f$ 的象，记为$f(X)$ 或 $Imf$ 设 $f:X \\to Y$ 为一映射，若 $\\forall x_1 \\neq x_2 \\in X, f(x_1) \\neq f(x_2)$ ，则称 $f$ 为一个单射 设 $f:X \\to Y$ 为一映射，若 $\\forall y \\in Y, \\exists x \\in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个满射","text":"定义 设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个映射，记为 $f:X \\to Y$ ， $X$ 称为 $f$ 的定义域， $Y$ 称为 $f$ 的陪域 设 $f:X \\to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的象，记为 $f(a)$ ； $a$ 称为 $b$ 的原象，记为 $f^{-1}(b)$ ；集合 ${f(x) \\big| x \\in X}$ 称为 $f$ 的值域或 $f$ 的象，记为$f(X)$ 或 $Imf$ 设 $f:X \\to Y$ 为一映射，若 $\\forall x_1 \\neq x_2 \\in X, f(x_1) \\neq f(x_2)$ ，则称 $f$ 为一个单射 设 $f:X \\to Y$ 为一映射，若 $\\forall y \\in Y, \\exists x \\in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个满射 设 $f:X \\to Y$ 为一映射，若 $f$ 即是单射又是满射，则称 $f$ 为一个双射 设 $f: X \\to Y$ 为一映射，若 $Y=X$ ，且 $\\forall x \\in X, f(x) = x$ ，则称 $f$ 为一个恒等映射，记为 $Id_X$ 或 $e_X$ 设 $f: A \\to C, g: B \\to D$ 为两个映射，若 $A = B,C=D$ ，且 $\\forall x \\in A, f(x)=g(x)$ ，则称映射 $f$ 与 $g$ 相等 设 $f: X \\to Y, g: Y \\to Z$ 为两个映射，则由法则 $(g \\circ f)(x) = g(f(x))$ 定义的映射称为 $f$ 与 $g$ 的合成，记为 $g \\circ f: X \\to Z$ 或 $gf: X \\to Z$ 设 $f:X \\to Y,g: Y \\to X$ 为两个映射，若 $g \\circ f = e_X$ ，则称 $g$ 为 $f$ 的左逆， $f$ 为 $g$ 的右逆；若 $g \\circ f = e_X,f \\circ g = e_Y$ ,则称 $g$ 为 $f$ 的双边逆或逆 基本性质1、（映射的合成律） 设 $f: X \\to Y, g: Y \\to Z, h: Z \\to W$ 为三个映射，则 $h(gf)=(hg)f$ 证明： 对于 $ h(gf) $ ，$(X \\to Y \\to Z) \\to W=X \\to W$ ；对于 $(hg)f$ ，$X \\to (Y \\to Z \\to W)=X \\to W$ $\\therefore$ $h(gf)$ 与 $(hg)f$ 的定义域及陪域相同 $\\forall x \\in X$ ，由定义8可知 $(h(gf))(x)=h((gf)(x))=h(g(f(x)))=(hg)(f(x))=((hg)f)(x)$ $\\therefore$ 由定义7可知，$h(gf)=(hg)f$","categories":[{"name":"代数学","slug":"代数学","permalink":"http://gonggongjohn.me/categories/%E4%BB%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.me/tags/Mathematics/"},{"name":"Algebra","slug":"Algebra","permalink":"http://gonggongjohn.me/tags/Algebra/"}]},{"title":"代数概念整理：集合","slug":"algebra-set","date":"2020-07-30T07:31:34.000Z","updated":"2021-01-21T07:08:51.567Z","comments":true,"path":"2020/07/30/algebra-set/","link":"","permalink":"http://gonggongjohn.me/2020/07/30/algebra-set/","excerpt":"定义 若 $a$ 为 $S$ 中的一个元素，则称 $a$ 包含于 $S$ ，记为 $a \\in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ 不包含于 $S$ ，记为 $a \\notin S$ 设 $S,T$ 为两个集合，若 $\\forall a \\in S$ ，成立 $a \\in T$ ，则称 $S$ 是 $T$ 的一个子集，记为 $S \\subset T$ 设 $S,T$ 为两个集合，若 $S \\subset T, T \\subset S$ ，则称 $S$ 与 $T$ 相等，记为 $S=T$ 设 $S,T$ 为两个集合，将集合 ${ x \\big| x \\in S \\land x \\in T }$ 称为 $S$ 与 $T$ 的交集，记为 $S \\cap T$ ；将集合 ${ x \\big| x \\in S \\lor x \\in T }$ 称为 $S$ 与 $T$ 的并集，记为 $S \\cup T$","text":"定义 若 $a$ 为 $S$ 中的一个元素，则称 $a$ 包含于 $S$ ，记为 $a \\in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ 不包含于 $S$ ，记为 $a \\notin S$ 设 $S,T$ 为两个集合，若 $\\forall a \\in S$ ，成立 $a \\in T$ ，则称 $S$ 是 $T$ 的一个子集，记为 $S \\subset T$ 设 $S,T$ 为两个集合，若 $S \\subset T, T \\subset S$ ，则称 $S$ 与 $T$ 相等，记为 $S=T$ 设 $S,T$ 为两个集合，将集合 ${ x \\big| x \\in S \\land x \\in T }$ 称为 $S$ 与 $T$ 的交集，记为 $S \\cap T$ ；将集合 ${ x \\big| x \\in S \\lor x \\in T }$ 称为 $S$ 与 $T$ 的并集，记为 $S \\cup T$ 设 $S,T$ 为两个集合，将集合 ${ x \\big| x \\in S \\land x \\notin T }$ 称为 $S$ 与 $T$ 的差集，记为 $S \\setminus T$ 设 $S,T$ 为两个集合，若 $T \\subset S$ ，则将集合 $S \\setminus T$ 称为 $T$ 在 $S$ 中的的补集，记为 $\\complement_S{T}$ 设 $S,T$ 为两个集合，则将集合 ${(x,y) \\big| x \\in S, y \\in T}$ 称为 $S$ 与 $T$ 的笛卡尔积 ，记为 $S \\times T$ ；将 $\\underbrace{X \\times X \\times … \\times X}_{k个}$ 简记为 $X^k$ 设 $S$ 为一个集合，则将 $S$ 中元素的个数记为 $S$ 的基数，记为 $|S|$ 基本性质1、（集合分配律）设 $R,S,T$ 为三个集合，则 ① $R \\cap (S \\cup T)=(R \\cap S) \\cup (R \\cap T)$ ② $R \\cup (S \\cap T) = (R \\cup S) \\cap (R \\cup T)$ 证明：① $\\forall x \\in R \\cap (S \\cup T)$ $\\therefore x \\in R$ 且 $x \\in S \\cup T$ $\\therefore$ （ $x \\in R$ 且 $x \\in S$ ） 或 （ $x \\in R 且 x \\in T$ ） $ \\therefore x \\in (R \\cap S) \\cup (R \\cap T)$ $\\therefore$ 由定义2可知， $R \\cap (S \\cup T)\\subset (R \\cap S) \\cup (R \\cap T)$ 反之， $\\forall x \\in (R \\cap S) \\cup (R \\cap T)$ $\\therefore$ $x \\in R \\cap S$ 或 $x \\in R \\cap T$ $\\therefore x \\in R$ 且（ $x \\in S$ 或 $x \\in T$ ） $\\therefore$ 由定义2可知，$(R \\cap S) \\cup (R \\cap T) \\subset R \\cap (S \\cup T)$ $\\therefore$ 由定义3可知， $R \\cap (S \\cup T)=(R \\cap S) \\cup (R \\cap T)$ ② 同理即可证得结论 2、 设 $X,Y$ 为两个集合，且 $|X|=n,|Y|=m$ ，则 ① $|X \\times Y|=n \\cdot m$ ② $|X \\cup Y|=n +m-|X \\cap Y|$","categories":[{"name":"代数学","slug":"代数学","permalink":"http://gonggongjohn.me/categories/%E4%BB%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.me/tags/Mathematics/"},{"name":"Algebra","slug":"Algebra","permalink":"http://gonggongjohn.me/tags/Algebra/"}]}],"categories":[{"name":"分析学","slug":"分析学","permalink":"http://gonggongjohn.me/categories/%E5%88%86%E6%9E%90%E5%AD%A6/"},{"name":"计算机系统","slug":"计算机系统","permalink":"http://gonggongjohn.me/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"机器学习","slug":"机器学习","permalink":"http://gonggongjohn.me/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://gonggongjohn.me/categories/%E7%AE%97%E6%B3%95/"},{"name":"代数学","slug":"代数学","permalink":"http://gonggongjohn.me/categories/%E4%BB%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.me/tags/Mathematics/"},{"name":"Analysis","slug":"Analysis","permalink":"http://gonggongjohn.me/tags/Analysis/"},{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.me/tags/Computer-Science/"},{"name":"Computer-System","slug":"Computer-System","permalink":"http://gonggongjohn.me/tags/Computer-System/"},{"name":"Machine-Learning","slug":"Machine-Learning","permalink":"http://gonggongjohn.me/tags/Machine-Learning/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://gonggongjohn.me/tags/Algorithm/"},{"name":"Sequence","slug":"Sequence","permalink":"http://gonggongjohn.me/tags/Sequence/"},{"name":"CSAPP","slug":"CSAPP","permalink":"http://gonggongjohn.me/tags/CSAPP/"},{"name":"Language","slug":"Language","permalink":"http://gonggongjohn.me/tags/Language/"},{"name":"Algebra","slug":"Algebra","permalink":"http://gonggongjohn.me/tags/Algebra/"}]}