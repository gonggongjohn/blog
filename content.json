{"meta":{"title":"GONGGONGJOHN's Blog","subtitle":"","description":"This is the private blog site of gonggongjohn","author":"GONGGONGJOHN","url":"http://gonggongjohn.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"斐波那契数的相关算法","slug":"fibonacci","date":"2020-10-30T15:29:04.000Z","updated":"2020-10-31T06:12:06.720Z","comments":true,"path":"2020/10/30/fibonacci/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/10/30/fibonacci/","excerpt":"斐波那契数列斐波那契数列由以下递推式定义： \\left\\{ \\begin{aligned} &F(0)=0 \\\\ &F(1)=1 \\\\ &F(n)=F(n-1)+F(n-2),n \\geq 2 \\end{aligned} \\right.","text":"斐波那契数列斐波那契数列由以下递推式定义： \\left\\{ \\begin{aligned} &F(0)=0 \\\\ &F(1)=1 \\\\ &F(n)=F(n-1)+F(n-2),n \\geq 2 \\end{aligned} \\right. 下面我们来推导斐波那契数列的通项公式 设矩阵 M=\\begin{pmatrix} m_{11} & m_{12} \\\\ m_{21} & m_{22} \\end{pmatrix}，使得 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} =M \\begin{pmatrix} F_{n} \\\\ F_{n-1} \\end{pmatrix} 故 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} =\\begin{pmatrix} m_{11} & m_{12} \\\\ m_{21} & m_{22} \\end{pmatrix} \\begin{pmatrix} F_{n} \\\\ F_{n-1} \\end{pmatrix} =\\begin{pmatrix} m_{11}F_{n}+m_{12}F_{n-1} \\\\ m_{21}F_{n}+m_{22}F_{n-1} \\end{pmatrix}对比等式左右可得 m_{11}=m_{12}=m_{21}=1,m_{22}=0，即 M=\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} 由此可知 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} =\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} F_{n} \\\\ F_{n-1} \\end{pmatrix}对该矩阵等式做递推，可得 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} =\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^n \\begin{pmatrix} F_{1} \\\\ F_{0} \\end{pmatrix} =\\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^n \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}易知 \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} 的特征多项式 f(\\lambda) = \\begin{vmatrix} \\lambda - 1 & -1 \\\\ -1 & \\lambda \\end{vmatrix} = \\lambda^2 - \\lambda - 1 令 f(\\lambda) = 0，可得该矩阵的特征值 \\lambda_1 = \\frac{1 - \\sqrt{5}}{2}, \\lambda_2 = \\frac{1 + \\sqrt{5}}{2} 由此可知该矩阵可相似对角化 对于 \\lambda_1 = \\frac{1-\\sqrt{5}}{2}，其对应的特征向量 \\alpha_1 = \\left(\\frac{1-\\sqrt{5}}{2},1\\right) 对于 \\lambda_2 = \\frac{1+\\sqrt{5}}{2}，其对应的特征向量 \\alpha_2 = \\left(\\frac{1+\\sqrt{5}}{2},1\\right) 故若令 P=\\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & \\frac{1+\\sqrt{5}}{2} \\\\ 1 & 1 \\end{pmatrix}，则 \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix} =P \\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & 0\\\\ 0 & \\frac{1+\\sqrt{5}}{2} \\end{pmatrix} P^{-1}于是 \\begin{aligned} \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} &=P \\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & 0\\\\ 0 & \\frac{1+\\sqrt{5}}{2} \\end{pmatrix}^n P^{-1} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\\\ &=\\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & \\frac{1+\\sqrt{5}}{2} \\\\ 1 & 1 \\end{pmatrix} \\begin{pmatrix} \\left(\\frac{1-\\sqrt{5}}{2}\\right)^n & 0\\\\ 0 & \\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\end{pmatrix} \\begin{pmatrix} -\\frac{1}{\\sqrt{5}} & \\frac{5 + \\sqrt{5}}{10} \\\\ \\frac{1}{\\sqrt{5}} & \\frac{5 - \\sqrt{5}}{10} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\\\ &=\\begin{pmatrix} \\frac{1-\\sqrt{5}}{2} & \\frac{1+\\sqrt{5}}{2} \\\\ 1 & 1 \\end{pmatrix} \\begin{pmatrix} -\\frac{1}{\\sqrt{5}}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n \\\\ \\frac{1}{\\sqrt{5}}\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\end{pmatrix} \\\\ &=\\begin{pmatrix} \\frac{\\sqrt{5}-1}{2\\sqrt{5}}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n + \\frac{\\sqrt{5}+1}{2\\sqrt{5}}\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\\\ -\\frac{1}{\\sqrt{5}}\\left(\\frac{1-\\sqrt{5}}{2}\\right)^n + \\frac{1}{\\sqrt{5}}\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\end{pmatrix} \\end{aligned}由此我们得到了斐波那契数列的通项公式 F_n = \\frac{1}{\\sqrt{5}} \\left[\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^n \\right]朴素递归算法朴素递归算法即为递推式定义的程序表达，采用递归的方法实现。代码如下： 12345int Fibonacci(int n)&#123; if(n == 0) return 0; else if(n == 1) return 1; else return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 易得该算法时间复杂度的递推表达式为 T(n)=T(n-1)+T(n-2)+\\Theta(1) 观察递归树可以发现，所有叶子结点的和就是 \\Theta(F_n) ，而所有内部节点的和为 \\Theta(F_n-1) 故朴素递归算法的时间复杂度 \\begin{aligned} T(n)&=\\Theta(F_n) + \\Theta(F_n-1) \\\\ &=\\Theta(F_n) \\\\ &=\\Theta\\left(\\left(\\frac{1+\\sqrt{5}}{2}\\right)^n\\right) \\\\ &=\\mathcal{O}(1.62^n) \\end{aligned}自下而上算法朴素递归算法的时间复杂度为指数级，这显然是难以接受的。观察发现朴素递归算法的主要问题是重复求解了许多子问题，其本质原因在于朴素递归算法是自上而下的求解子问题，而不同子问题中重叠的部分无法相互影响。故我们换一种思路，自下而上的求解，就可以很好的解决这一问题。代码如下： 123456789int Fibonacci(int n)&#123; int a[N]; //N is the biggest possible value a[0] = 0; a[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; a[i] = a[i - 1] + a[i - 2]; &#125; return a[n];&#125; 易知该算法的时间复杂度 T(n)=n-1=\\Theta(n) 矩阵快速幂算法自下而上算法已经将原本的指数级时间复杂度降低到了多项式级，我们希望能够进一步的将其降低到对数级别。自然的，我们首先想到的是利用其通项公式并通过快速幂的方法来求解。但斐波那契数列的通项公式中包含无理数，由于计算机的精度限制，计算结果可能并不正确，故这种方法显然是不可靠的。 注：事实上，若不存在精度限制的问题，斐波那契数列还可以表示为 F_n = \\left[ \\left(\\frac{1+\\sqrt{5}}{2}\\right)^n \\right] （其中 [x] 表示取整到离 x 最近的整数） 于是问题转化为是否存在一个仅需在整数域内进行运算的斐波那契通项公式。回顾上面求解斐波那契数列通项公式的过程，注意到 \\begin{pmatrix} F_{n+1} \\\\ F_n \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\\\ 1 & 0 \\end{pmatrix}^n \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}，故我们可以通过求解该矩阵来得到 F_n 的值。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839struct matrix&#123; int a[2][2]; matrix(int a11, int a12, int a21, int a22)&#123; a[0][0] = a11; a[0][1] = a12; a[1][0] = a21; a[1][1] = a22; &#125;&#125;;//This function can only handle 2*2 matrix multiplicationmatrix matrixMult(matrix matA, matrix matB)&#123; matrix matR(0, 0, 0, 0); for(int i = 0; i &lt; 2; i++) for(int j = 0; j &lt; 2; j++) for(int k =0; k &lt; 2; k++) matR.a[i][j] += matA.a[i][k] * matB.a[k][j]; return matR;&#125;matrix matrixPow(matrix mat, int n)&#123; if(n == 1) return mat; if(n % 2 == 0)&#123; matrix matT = matrixPow(mat, n / 2); return matrixMult(matT, matT); &#125; else&#123; matrix matT1 = matrixPow(mat, (n - 1) / 2); matrix matT2 = matrixMult(matT1, matT1); return matrixMult(matT2, mat); &#125;&#125;int Fibonacci(int n)&#123; if(n == 0) return 0; else if(n == 1) return 1; else&#123; matrix matT(1, 1, 1, 0); matrix matR = matrixPow(matT, n); return matR.a[1][0]; &#125;&#125; 分析该算法，发现其时间复杂度的递推表达式为 T(n) = T\\left(\\frac{n}{2}\\right) + \\Theta(1)。故由主定理可知该矩阵快速幂算法的时间复杂度为 T(n) = \\Theta(\\lg n)","categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.github.io/blog/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://gonggongjohn.github.io/blog/tags/Algorithm/"}]},{"title":"和式的求解方法","slug":"sum-solve","date":"2020-10-11T12:40:02.000Z","updated":"2020-10-11T12:44:47.214Z","comments":true,"path":"2020/10/11/sum-solve/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/10/11/sum-solve/","excerpt":"扰动法扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。","text":"扰动法扰动法的主要思想是将原和式加上后一项并分离第一项，从而化简得到一个求和下标对齐的包含后一项的和式。若能将该和式写成原来和式的表达式，即可通过解方程求出原和式的通项公式。 令 S_n = \\sum_\\limits{0 \\leq k \\leq n} a_k \\begin{aligned} S_n + a_{n+1} &= \\sum_\\limits{0 \\leq k \\leq n+1} a_k \\\\ &= a_0 + \\sum_\\limits{1 \\leq k \\leq n+1} a_k \\\\ &= a_0 + \\sum_\\limits{1 \\leq k+1 \\leq n+1} a_{k+1} \\\\ &= a_0 + \\sum_\\limits{0 \\leq k \\leq n} a_{k+1} \\end{aligned}若能将 \\sum_\\limits{0 \\leq k \\leq n} a_{k+1} 写为 S_n 的表达式，即可求出该求和式的通项公式 Example1: 求等比数列和 S_n = \\sum_\\limits{0 \\leq k \\leq n} a q^k \\ \\ (q \\neq 1) 的通项公式 解： 由上述公式可知 \\begin{aligned} S_n + a_{n+1} &= a + \\sum_\\limits{0 \\leq k \\leq n} aq^{k+1} \\\\ &=a + q \\sum_\\limits{0 \\leq k \\leq n} aq^k \\\\ &=a + q S_n \\end{aligned}从而 $(1-q)S_n = a - aq^{n+1}$ 故 $S_n = \\frac{a\\left(1-q^{n+1} \\right)}{1-q} \\ \\ (q \\neq 1)$ Example2: 求等比差数列和 S_n = \\sum_\\limits{0 \\leq k \\leq n} k \\cdot q^k \\ \\ (q \\neq 1) 的通项公式 解： 由上述公式可知 \\begin{aligned} S_n + a_{n+1} &= 0 + \\sum_\\limits{0 \\leq k \\leq n} (k+1) \\cdot q^{k+1} \\\\ &=\\sum_\\limits{0 \\leq k \\leq n} k \\cdot q^{k+1} + \\sum_\\limits{0 \\leq k \\leq n} q^{k+1} \\\\ &=q \\sum_\\limits{0 \\leq k \\leq n} k \\cdot q^k + q \\sum_\\limits{0 \\leq k \\leq n} q^k \\\\ &=q S_n + q \\cdot \\frac{1-q^{n+1}}{1-q} \\end{aligned}从而 $(1-q)S_n = \\frac{q-q^{n+2}}{1-q} - (n+1) \\cdot q^{n+1}$ 故 \\begin{aligned} S_n &= \\frac{q-q^{n+2}}{(1-q)^2} - \\frac{(n+1) \\cdot q^{n+1}}{1-q} \\\\ &= \\frac{q-(n+1)q^{n+1} + nq^{n+2}}{(1-q)^2} \\ \\ (q \\neq 1) \\end{aligned}","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Sequence","slug":"Sequence","permalink":"http://gonggongjohn.github.io/blog/tags/Sequence/"}]},{"title":"递归式的解法","slug":"recursion-solve","date":"2020-10-11T12:39:48.000Z","updated":"2020-10-11T12:52:00.138Z","comments":true,"path":"2020/10/11/recursion-solve/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/10/11/recursion-solve/","excerpt":"求和因子法对于形如 a_n T_n = b_n T_{n-1} + c_n，我们可以求出其通项公式，下面我们来推导这一公式。 我们考虑通过变量替换的方式将 T_n 前的 a_n 和 b_n 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 b_n T_{n-1} 能够通过 a_n T_n 表示出来（该表达式通常被称为求和因子）。设该表达式为 s_n，两边同乘以 s_n，即为 s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n","text":"求和因子法对于形如 a_n T_n = b_n T_{n-1} + c_n，我们可以求出其通项公式，下面我们来推导这一公式。 我们考虑通过变量替换的方式将 T_n 前的 a_n 和 b_n 隐去以方便求解。为了做到这一点，我们需要通过将等式左右同时乘以某个表达式使得 b_n T_{n-1} 能够通过 a_n T_n 表示出来（该表达式通常被称为求和因子）。设该表达式为 s_n，两边同乘以 s_n，即为 s_n a_n T_n = s_n b_n T_{n-1} + s_n c_n 注意到等式左边均为第 $n$ 项，而右边为 T_{n-1}，故考虑将右边第一项变为 s_{n-1}a_{n-1}T_{n-1}。要做到这一点，就是要让 s_n b_n = s_{n-1} a_{n-1}，也即 s_n = s_{n-1} \\cdot \\frac{a_{n-1}}{b_n}。做递推，得到 s_n = \\frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2} \\cdot s_1。故仅需取 s_n = \\frac{a_{n-1} a_{n-2}...a_1}{b_n b_{n-1}...b_2} 或该式的常数倍即可。 现在，我们仅需令 P_n = s_n a_n T_n，即可将原式化简为 P_n = P_{n-1} + s_n c_n 故 P_n = P_0 + \\sum_\\limits{k=1}^n s_k c_k 故 s_n a_n T_n = s_0 a_0 T_0 + \\sum_\\limits{k=1}^n s_kc_k = s_1b_1T_0 + \\sum_\\limits{k=1}^n s_kc_k 故 T_n = \\frac{1}{s_n a_n} \\left( s_1b_1T_0 + \\sum_\\limits{k=1}^n s_kc_k \\right) Example: 已知Hanoi问题满足以下递归表达式，试求出其通项公式 \\left\\{ \\begin{aligned} &T_0 = 0 \\\\ &T_n = 2T_{n-1} + 1 \\end{aligned} \\right.解： 由 $a_n = 1, b_n = 2$ 可知求和因子 $s_n = \\frac{1}{2^{n-1}}$。由于 $s_n$ 乘以常数倍不影响其效果 ，故为了方便起见令 $s_n = \\frac{1}{2^n}$ 两边同乘以 s_n = \\frac{1}{2^n}，得到 \\frac{T_n}{2^n} = \\frac{T_{n-1}}{2^{n-1}} + \\frac{1}{2^n} 令$P_n = \\frac{T_n}{2^n}$，则 \\left\\{ \\begin{aligned} &P_n = P_{n-1} + \\frac{1}{2^n} \\\\ &P_0 = 0 \\end{aligned} \\right.故 P_n = \\sum_\\limits{k=1}^n \\frac{1}{2^k} = 1-\\left(\\frac{1}{2}\\right)^n，即 \\frac{T_n}{2^n} = 1-\\left(\\frac{1}{2}\\right)^n 故 T_n = 2^n - 1","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Sequence","slug":"Sequence","permalink":"http://gonggongjohn.github.io/blog/tags/Sequence/"}]},{"title":"快速排序时间复杂度分析","slug":"qsort-analyze","date":"2020-10-10T07:46:07.000Z","updated":"2020-10-10T07:52:36.300Z","comments":true,"path":"2020/10/10/qsort-analyze/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/10/10/qsort-analyze/","excerpt":"快速排序的平均比较次数满足以下递归表达式： \\left\\{ \\begin{aligned} &C_0 = 0 \\\\ &C_n = n + 1 + \\frac{2}{n}\\sum_\\limits{k = 0}^{n-1} C_k \\ \\ (n > 0) \\end{aligned} \\right.下面我们来尝试推导该递归式的封闭解","text":"快速排序的平均比较次数满足以下递归表达式： \\left\\{ \\begin{aligned} &C_0 = 0 \\\\ &C_n = n + 1 + \\frac{2}{n}\\sum_\\limits{k = 0}^{n-1} C_k \\ \\ (n > 0) \\end{aligned} \\right.下面我们来尝试推导该递归式的封闭解 首先将原式化简为整式，得到 nC_n = n^2 + n + 2 \\sum_\\limits{k=0}^{n-1} C_k 注意到等式右边有一个连续的求和式（即从 C_0 到 C_{n-1} 中没有缺项），故考虑做差项消去该求和式。 \\left\\{ \\begin{aligned} &nC_n = n^2 + n + 2 \\sum_\\limits{k=0}^{n-1} C_k \\\\ &(n-1)C_{n-1} = (n-1)^2 + (n-1) + 2 \\sum_\\limits{k=0}^{n-2} C_k \\end{aligned} \\right.两式相减，得到 nC_n - (n-1)C_{n-1} = 2n + 2C_{n-1} 化简得到 nC_n = (n+1)C_{n-1} + 2n 接下来我们考虑将 C_n 和 C_{n-1} 前的系数消去以找出通项公式。 两边同时乘以 $\\frac{2}{n(n+1)}$ ，得到 \\frac{2}{n+1}C_n = \\frac{2}{n}C_{n-1} + \\frac{4}{n+1} 令 $T_n = \\frac{2}{n+1} C_n$，于是原递归式化简为 \\left\\{ \\begin{aligned} & T_0 = 0 \\\\ & T_n = T_{n-1} + \\frac{4}{n+1} \\end{aligned} \\right.我们可以快速写出该递归式的通项公式 T_n = 4\\sum_\\limits{k=2}^{n+1} \\frac{1}{k} 即 \\frac{2}{n+1}C_n = 4\\sum_\\limits{k=2}^{n+1} \\frac{1}{k} 化简即得 C_n = 2(n+1)\\sum_\\limits{k=2}^{n+1} \\frac{1}{k} 引入调和级数符号 $H_n = 1 + \\frac{1}{2} + \\frac{1}{3} + … + \\frac{1}{n}$ 注意到 $\\sum_\\limits{k=2}^{n+1} \\frac{1}{k} = H_n - 1 + \\frac{1}{n+1}$ 故我们得到了原递归表达式的封闭解 $C_n = 2(n+1)H_n - 2n$ 又由 $H_n = \\ln n + \\gamma + \\mathcal{O}\\left(\\frac{1}{n} \\right)$ 故可得 \\begin{aligned} C_n &= 2(n+1)\\left(\\ln n + \\gamma + \\mathcal{O} \\left(\\frac{1}{n} \\right)\\right) - 2n \\\\ &= 2n \\ln n + 2(\\gamma - 1)n + 2\\ln n + 2\\gamma + \\mathcal{O}(1) + \\mathcal{O}\\left(\\frac{1}{n}\\right) \\\\ &= \\Theta \\left( n \\ln n \\right) \\\\ &= \\Theta \\left( n \\lg n\\right) \\end{aligned}由此我们得到了快速排序的平均时间复杂度为 $\\Theta (n \\lg n)$","categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.github.io/blog/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://gonggongjohn.github.io/blog/tags/Algorithm/"}]},{"title":"《深入理解计算机系统》笔记整理（一）","slug":"csapp-01","date":"2020-10-07T14:31:17.000Z","updated":"2020-10-11T12:39:08.176Z","comments":true,"path":"2020/10/07/csapp-01/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/10/07/csapp-01/","excerpt":"Chapter 2：信息的表示和处理基本概念进制转换进位计数制定义：设一个 $m$ 进制下$w$ 位的位向量表示为 [a_{w-1}, a_{w-2}, ..., a_0]，则其表示的数为 $\\sum_\\limits{i=0}^{w-1} a_im^i$ $m$ 进制 $\\rightarrow$ 十进制 设一个 $w$ 位 $m$ 进制整数的位相量表示为 \\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ] ，定义函数 $M2D(\\vec{x}) = \\sum_\\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\\vec{x})$","text":"Chapter 2：信息的表示和处理基本概念进制转换进位计数制定义：设一个 $m$ 进制下$w$ 位的位向量表示为 [a_{w-1}, a_{w-2}, ..., a_0]，则其表示的数为 $\\sum_\\limits{i=0}^{w-1} a_im^i$ $m$ 进制 $\\rightarrow$ 十进制 设一个 $w$ 位 $m$ 进制整数的位相量表示为 \\vec{x} = [ x_{w-1}, x_{w-2}, ..., x_0 ] ，定义函数 $M2D(\\vec{x}) = \\sum_\\limits{i=0}^{w-1} x_i m^i$，则其对应的十进制数 $n = M2D(\\vec{x})$ 证明：由进位计数制的定义可直接得到结论 Example: 将 $3$ 进制数 $12011$ 转为十进制数 解： 令 $\\vec{x} = [1,2,0,1,1], m = 3$ \\begin{align} \\therefore n = M2D(\\vec{x}) &= 1 \\cdot 3^4 + 2 \\cdot 3^3 + 1 \\cdot 3^1 +1 \\cdot 3^0 \\\\ &= 81+54+3+1 \\\\ &= 139 \\end{align}故 12011_3 = 139_{10} 十进制 $\\rightarrow$ $m$ 进制 设一个十进制整数为 $n$，定义序列 \\begin{align} &p_0 = \\lfloor \\frac{n}{m} \\rfloor, \\ r_0 = n \\ \\ mod \\ \\ m \\\\ &p_1 = \\lfloor \\frac{p_0}{m}\\rfloor, \\ r_1 = p_0 \\ \\ mod \\ \\ m \\\\ &... \\\\ &p_{s-1} = \\lfloor \\frac{p_{s-2}}{m}\\rfloor = 0, \\ r_{s-1} = p_{s-2} \\ \\ mod \\ \\ m \\\\ \\end{align}则其对应的 $m$ 进制数的位向量表示为 \\vec{x} = [r_{s-1}, r_{s-2}, ..., r_0] 证明：设 $n$ 在 $m$ 进制下的位相量表示为 [r_{s-1}, r_{s-2}, ..., r_0] 则由定义可知，n = r_{s-1} \\cdot m^{s-1} + r_{s-2} \\cdot m^{s-2} + ...+ r_0 故 n = m \\cdot \\left( r_{s-1} \\cdot m^{s-2} + r_{s-2} \\cdot m^{s-3} + ... + r_1 \\right) + r_0 故 $r_0 = n \\ \\ mod \\ \\ m$ 又由 \\begin{align} p_0 = \\lfloor \\frac{n}{m} \\rfloor &= r_{s-1} \\cdot m^{s-2} + r_{s-2} \\cdot m^{s-3} + ... + r_1 \\\\ &= m \\cdot \\left( r_{s-1} \\cdot m^{s-3} + r_{s-2} \\cdot m^{s-4} + ... + r_2 \\right) + r_1 \\end{align}故 $r_1 = p_0 \\ \\ mod \\ \\ m$ 以此类推，r_{i} = p_{i-1} \\ \\ mod \\ \\ m \\ (i=s-2, ..., 1) 故结论成立 Example: 将十进制数 $508$ 转为八进制数 解： \\begin{align} 508 &= 63 * 8 + 4 \\\\ 63 &= 7 * 8 + 7 \\\\ 7 &= 0 * 8 + 7 \\end{align}故 $508_{10} = 774_8$ 信息的存储字长（Word Size）在计算机中，字（Word）是用来表示一次性处理数据的固定长度。字的位数称为字长（Word Size）。字长是计算机系统中的一个重要指标，字长的大小决定了虚拟地址空间的最大大小。 对于一个字长为 $w$ 的机器来说，其虚拟地址的范围为 $0$ ～ $2^w-1$，即可以存储 $2^w$ 个字节 Example: 字长为32的机器的虚拟地址范围为 $0$ ～ $2^{32}-1$，可以存储 $2^{32}$ 个字节 小端序（Little Endian）和大端序（Big Endian）超过一个字节的数据在计算机中有两种排列顺序：小端序（Little Endian）和大端序（Big Endian）。 小端序：将较低的有效字节放在较小的内存地址中。 大端序：将较低的有效字节放在较大的内存地址中。 Example: 原始数据：12 34 56 78 小端序存储：12 34 56 78 大端序存储：78 56 34 12 注：使用ASCII码存储的字符数据在任何系统上都能得到相同的结果，不受端序的影响。 基本运算位级运算计算机中有以下四种基本位级运算：按位与（&amp;），按位或（|），按位非（~），按位异或（^），其规则与布尔代数中的规则一致。 Example: 101100 &amp; 100110 = 100100 101100 | 100110 = 101110 ~101100 = 010011 101100 ^ 100110 = 001010 逻辑运算计算机中提供了以下三种逻辑运算：且（&amp;&amp;），或（||），非（!），其规则与命题逻辑中的规则一致。 注：C语言中的逻辑运算有提早终止（Early Termination）的机制，即当两个表达式做逻辑运算时，若前一个表达式已经能确定最终结果，则不再计算后一个表达式。 Example: (1+1=2) &amp; (3=3) = 1 (1-1=0) || (1=2) = 1 !(2*5=10) = 0 !0x3F = 0 位移运算计算机中提供了三种位移操作：左移（&lt;&lt;），逻辑右移（&gt;&gt;），算术右移（&gt;&gt;） $x$ 左移 $k$ 位：将 $x$ 的最高 $k$ 位丢弃并在最低位后补充 $k$ 个零，相当于 $x \\cdot 2^k$ $x$ 逻辑右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个零，相当于 $\\lfloor \\frac{x}{2^k} \\rfloor$ 算术右移 $k$ 位：将 $x$ 的最低 $k$ 位丢弃并在最高位前补充 $k$ 个最高位值 整数的存储与运算无符号整数二进制数码不表示符号信息的整数称为无符号整数，其代码的数字与常规的进位计数制规则一致。即若定义 B2U_w(\\vec{x}) = \\sum_\\limits{i=0}^{w-1}x_i 2^i，则一个 $w$ 位的二进制位相量 $\\vec{x}$ 所对应的十进制数 $n = B2U_w(\\vec{x})$ 由定义可知，一个 $w$ 位的二进制位相量 $\\vec{x}$ 可表示的整数范围为 $0$ ～ $2^w-1$ 有符号整数有符号整数是采用补码进行存储的整数。补码是对二进制的一种新的解读方式，其严格的定义如下：若定义 B2T_w(\\vec{x}) = -x_{w-1} 2^{w-1} + \\sum_\\limits{i=0}^{w-2}x_i 2^i，则一个 $w$ 位的二进制位相量 $\\vec{x}$ 所对应的十进制数 $n = B2T_w(\\vec{x})$。通俗来说，补码将原本 $0$ ～ $2^w-1$ 中 $2^{w-1}$ ～ $2^{w} - 1$ 的部分重新解读为负数，从而使得其可以表示负数。从取模的角度来看， 对于一个 $0$ ～ $2^{w-1} - 1$ 中的数 $n$ 和一个 $2^{w-1}$ ～ $2^{w} - 1$ 中的数 $m$，$(n + m) \\ \\ mod \\ \\ 2^w = n - (2^w - m)$，故这样定义是合适的。且容易看出其与无符号整数间的转换关系为 U2T(x) = \\left\\{ \\begin{aligned} &x &, &0 \\leq x \\leq 2^{w-1} - 1 \\\\ &x - 2^w &, &2^{w-1} \\leq x \\leq 2^w - 1 \\end{aligned} \\right. T2U(x) = \\left\\{ \\begin{aligned} &x &, & 0 \\leq x \\leq 2^{w-1}-1 \\\\ &x + 2^w &, & -2^{w-1} \\leq x \\leq -1 \\end{aligned} \\right.证明：设二进制位向量 $\\vec{x}$ 当 0 \\leq B2U_w(\\vec{x}) \\leq 2^{w-1} - 1 时 x_{w-1} = 0此时 B2T_w(\\vec{x}) = \\sum_\\limits{i=0}^{w-2}x_i 2^i = B2U_w(\\vec{x}) 故 U2T_w(x) = x 当 2^{w-1} \\leq x \\leq 2^w - 1 时 x_{w-1} = 1此时 \\left\\{ \\begin{aligned} B2T_w(\\vec{x}) &= -2^{w-1} + \\sum_\\limits{i=0}^{w-2}x_i 2^i \\\\ B2U_w(\\vec{x}) &= 2^{w-1} + \\sum_\\limits{i=0}^{w-2}x_i 2^i \\end{aligned} \\right.故 B2T_w(\\vec{x}) = B2U_w(\\vec{x}) - 2^w 故 U2T_w(\\vec{x}) = x - 2^w T2U(x)的情况同理可证 注：无符号或有符号整数仅为二进制解读为十进制时的不同解读方式，由于计算机在二进制层面进行运算，故计算机在进行底层运算时并不区分这两种解读方式。","categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.github.io/blog/tags/Computer-Science/"},{"name":"CSAPP","slug":"CSAPP","permalink":"http://gonggongjohn.github.io/blog/tags/CSAPP/"}]},{"title":"GDB使用指南","slug":"gdb-guide","date":"2020-09-19T04:24:40.000Z","updated":"2020-09-28T08:06:30.878Z","comments":true,"path":"2020/09/19/gdb-guide/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/09/19/gdb-guide/","excerpt":"GDB使用指南GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。 GDB官网：GDB: The GNU Project Debugger","text":"GDB使用指南GDB（GNU Project Debugger）是一款UNIX及类UNIX环境下的C/C++调试工具。 GDB官网：GDB: The GNU Project Debugger GDB和LLDBLLDB是一款开源的具有REPL（Read-Evaluation-Print-Loop）特征的调试工具，相比GDB在部分场景下更加先进和高效。Xcode自4.3版本后默认内置了LLDB，因此macOS用户可以直接使用LLDB对程序进行调试。（当然macOS同样也可以安装GDB调试工具） GDB与LLDB命令对照表：GDB to LLDB command map WINDOWS下安装GCC和GDBMinGW（Minimalist GNU For Windows）是Windows下的一个小型GNU工具集。新版MinGW中集成了GCC和GDB的相关工具，因此只需安装MinGW即可使用GCC和GDB。 下载MinGW及GCC包首先前往MinGW官方网站：MinGW 并在Download界面下载MinGW管理工具。 安装MinGW管理工具并打开。 选择所需的工具集，点击左上角的Installation-&gt;Apply Changes即可安装。（由于受国内网络环境影响，可能会出现下载失败的情况，可以多尝试几次或使用其他网络连接方式下载）。若使用C/C++进行开发，通常仅需安装mingw32-base-bin及mingw32-gcc-g++-bin即可。 配置系统环境变量安装完成后，我们需要配置系统环境变量使得其可以在CMD中执行。 右键此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量，在系统变量框中找到Path变量，选择编辑，在最后新增一行填入你的MinGW安装路径\\bin，确定退出。 打开CMD，输入gcc -v及gdb -v，若显示相关版本信息，表明环境变量配置成功。 在其他IDE中调用GDBCLionCLion本身已经集成了十分完善的可视化调试工具，但如果想在CLion中使用GDB或LLDB调试程序同样十分方便。 使用通常的方法在需要的地方打上断点启动调试，在下方的Debug窗口中就可以看到GDB/LLDB窗口，在其中输入命令即可。 Visual Studio CodeVSCode本身并不自带GCC和GDB的相关功能，因此使用VSCode进行调试同样需要额外安装GDB/LLDB调试工具。不过，VSCode提供了一个可视化的C/C++调试插件，相比命令行调试会直观很多。该插件可直接在插件商店里搜索并安装。 和其他大型IDE类似，VSCode将一个目录视为一个项目，因此在创建项目时，你需要指定一个空的文件夹来存放项目文件（这也是一些人装了辅助插件却被提示要手动配置调试文件的一大重要原因）。在第一次运行程序时，选择Run-&gt;Start Debugging，在弹出的选项框中选择一个要使用的调试环境及编译环境，VSCode就会自动在当前的项目目录下创建相应的配置文件。（当然也可以手动指定配置文件，具体配置方法可参考VSCode官方文档） 随后即可在调试界面中看到相关的调试信息。你也可以在下方的Debug Console中输入相关的GDB/LLDB命令来进行进一步的调试。 GDB的基本使用启动调试若要使用GDB来调试程序，需要在使用GCC编译源文件的时候打开-g选项。 1gcc -g [源文件名] -o [目标文件名] Example: 1gcc -g test.c -o test 若不打开调试选项，则在调试时无法添加断点。 使用gdb打开生成的可执行文件即可开始调试。 1gdb [目标文件名] GDB还可以关联正在运行的程序进行调试。我们可以通过ps命令查询目标进程的PID，随后进入GDB使用attach命令关联进程。 123ps -ef|grep [进程名]gdb(gdb) attach [PID] Linux用户在这一过程过可能会遇到权限不足的情况。解决方法：切换至root用户，进入/etc/stsctl.d/10-ptrace.conf中将kernel.yama.ptrace_scpoe = 1改为kernel.yama.ptrace_scpoe = 0即可。 添加断点通常在调试过程中，我们需要在程序的某个位置添加断点，并让程序运行到这一位置时自动暂停以分析程序当前的运行状态。在GDB环境下，我们可以通过break命令来快速添加断点。 12(gdb) break [源文件名称]:[行号] #执行到某一行时中断(gdb) break [函数名] #执行到某个函数时中断 Example: 12(gdb) break test.c:5(gdb) break main 有时我们希望程序在特定条件下中断，这个时候我们可以使用break+if或condition语句来设置条件断点。 1(gdb) break [中断位置] if 触发条件 Example: 1(gdb) break test.c:10 if a==5 12(gdb) break [中断位置](gdb) condition [断点号] [触发条件] Example: 12(gdb) break test.c:10(gdb) condition 1 a==5 我们可以使用info指令查看已设置断点的断点号及相关信息 1(gdb) info breakpoints 通过clear和delete命令可以删除已创建的断点。 1234(gdb) clear [目标文件名]:[行号] #删除某一行处的断点(gdb) clear [函数名] #删除某个函数处的断点(gdb) delete #删除所有断点(gdb) delete [断点号] #删除某一特定断点 Example: 12(gdb) clear test:5(gdb) delete 1 运行程序对于不需要向main函数传递参数的程序，可以直接使用run指令开始运行程序。 1(gdb) run 对于需要向main函数传递参数的程序，可以使用set args指令或直接在run后跟参数的方式运行程序。 12(gdb) set args [参数](gdb) run Example: 12(gdb) set args para1 para2 para3(gdb) run 1(gdb) run [参数] Example: 1(gdb) run para1 para2 para3 程序运行后，会一直运行至第一个断点处并暂停。若没有设置断点，则效果等同于直接运行程序。 当程序中断后，GDB提供了以下几种继续运行的指令。 12345(gdb) next #单步执行（不进入函数内部，等同于Clion中的Step Over）(gdb) step #单步进入（进入函数内部，等同于Clion的Step Into）(gdb) continue #继续执行至下一个断点处(gdb) until [行号] #继续执行直至某一行(gdb) finish #运行至程序结尾 查看变量及内存在程序中断时，GDB提供了一系列指令来查看当前变量及内存中的各种信息。 通过print指令可以打印变量或表达式的值 1(gdb) print &#x27;[源文件名/函数名]&#x27;::[变量名/表达式] Example: 123(gdb) print &#x27;main&#x27;::a(gdb) print &#x27;test.c&#x27;::b(gdb) print &#x27;main&#x27;::*p 通过display命令可以使得每次程序中断时自动打印某个变量或表达式的值 1(gdb) display [变量名/表达式] 此外，我们还可以通过watch指令追踪某一变量，使其值发生改变时中断程序 1(gdb) watch [变量名] 通过backtrace指令可以查看函数调用栈的存储情况及相关信息。 1(gdb) backtrace 更多其他命令的详细用法，可以通过help指令查询 1(gdb) help [命令]","categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.github.io/blog/tags/Computer-Science/"},{"name":"Language","slug":"Language","permalink":"http://gonggongjohn.github.io/blog/tags/Language/"}]},{"title":"实数的严格定义","slug":"analysis-real-number","date":"2020-08-26T11:03:01.000Z","updated":"2020-08-27T02:39:10.000Z","comments":true,"path":"2020/08/26/analysis-real-number/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/08/26/analysis-real-number/","excerpt":"","text":"对于整数和有理数，我们可以很轻松的从直观上理解并将他们表示出来。对于整数 $1,2,3,4,…$，我们只需要通过写出各数位上的数字便可将他们精确的表出；对于有理数，我们也只需要写出构成分母和分子的两个整数便可以精确表示。","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Analysis","slug":"Analysis","permalink":"http://gonggongjohn.github.io/blog/tags/Analysis/"}]},{"title":"代数概念整理：映射","slug":"algebra-projection","date":"2020-07-31T07:00:00.000Z","updated":"2020-09-23T02:33:28.611Z","comments":true,"path":"2020/07/31/algebra-projection/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/07/31/algebra-projection/","excerpt":"定义 设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个映射，记为 $f:X \\to Y$ ， $X$ 称为 $f$ 的定义域， $Y$ 称为 $f$ 的陪域 设 $f:X \\to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的象，记为 $f(a)$ ； $a$ 称为 $b$ 的原象，记为 $f^{-1}(b)$ ；集合 ${f(x) \\big| x \\in X}$ 称为 $f$ 的值域或 $f$ 的象，记为$f(X)$ 或 $Imf$ 设 $f:X \\to Y$ 为一映射，若 $\\forall x_1 \\neq x_2 \\in X, f(x_1) \\neq f(x_2)$ ，则称 $f$ 为一个单射 设 $f:X \\to Y$ 为一映射，若 $\\forall y \\in Y, \\exists x \\in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个满射","text":"定义 设 $X,Y$ 为两个集合，$f$ 为某种使得 $X$ 中的每一个元素都对应于 $Y$ 中某个元素的规则，则称 $f$ 为 $X$ 到 $Y$ 的一个映射，记为 $f:X \\to Y$ ， $X$ 称为 $f$ 的定义域， $Y$ 称为 $f$ 的陪域 设 $f:X \\to Y$ 为一映射，则 $X$ 中的元素 $a$ 在 $f$ 下对应的 $Y$ 中的元素 $b$ 称为 $a$ 的象，记为 $f(a)$ ； $a$ 称为 $b$ 的原象，记为 $f^{-1}(b)$ ；集合 ${f(x) \\big| x \\in X}$ 称为 $f$ 的值域或 $f$ 的象，记为$f(X)$ 或 $Imf$ 设 $f:X \\to Y$ 为一映射，若 $\\forall x_1 \\neq x_2 \\in X, f(x_1) \\neq f(x_2)$ ，则称 $f$ 为一个单射 设 $f:X \\to Y$ 为一映射，若 $\\forall y \\in Y, \\exists x \\in X$ ，使得 $f(x)=y$ ，即 $Imf=Y$ ，则称 $f$ 为一个满射 设 $f:X \\to Y$ 为一映射，若 $f$ 即是单射又是满射，则称 $f$ 为一个双射 设 $f: X \\to Y$ 为一映射，若 $Y=X$ ，且 $\\forall x \\in X, f(x) = x$ ，则称 $f$ 为一个恒等映射，记为 $Id_X$ 或 $e_X$ 设 $f: A \\to C, g: B \\to D$ 为两个映射，若 $A = B,C=D$ ，且 $\\forall x \\in A, f(x)=g(x)$ ，则称映射 $f$ 与 $g$ 相等 设 $f: X \\to Y, g: Y \\to Z$ 为两个映射，则由法则 $(g \\circ f)(x) = g(f(x))$ 定义的映射称为 $f$ 与 $g$ 的合成，记为 $g \\circ f: X \\to Z$ 或 $gf: X \\to Z$ 设 $f:X \\to Y,g: Y \\to X$ 为两个映射，若 $g \\circ f = e_X$ ，则称 $g$ 为 $f$ 的左逆， $f$ 为 $g$ 的右逆；若 $g \\circ f = e_X,f \\circ g = e_Y$ ,则称 $g$ 为 $f$ 的双边逆或逆 基本性质1、（映射的合成律） 设 $f: X \\to Y, g: Y \\to Z, h: Z \\to W$ 为三个映射，则 $h(gf)=(hg)f$ 证明： 对于 $ h(gf) $ ，$(X \\to Y \\to Z) \\to W=X \\to W$ ；对于 $(hg)f$ ，$X \\to (Y \\to Z \\to W)=X \\to W$ $\\therefore$ $h(gf)$ 与 $(hg)f$ 的定义域及陪域相同 $\\forall x \\in X$ ，由定义8可知 $(h(gf))(x)=h((gf)(x))=h(g(f(x)))=(hg)(f(x))=((hg)f)(x)$ $\\therefore$ 由定义7可知，$h(gf)=(hg)f$","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Algebra","slug":"Algebra","permalink":"http://gonggongjohn.github.io/blog/tags/Algebra/"}]},{"title":"代数概念整理：集合","slug":"algebra-set","date":"2020-07-30T07:31:34.000Z","updated":"2020-09-23T02:33:11.219Z","comments":true,"path":"2020/07/30/algebra-set/","link":"","permalink":"http://gonggongjohn.github.io/blog/2020/07/30/algebra-set/","excerpt":"定义 若 $a$ 为 $S$ 中的一个元素，则称 $a$ 包含于 $S$ ，记为 $a \\in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ 不包含于 $S$ ，记为 $a \\notin S$ 设 $S,T$ 为两个集合，若 $\\forall a \\in S$ ，成立 $a \\in T$ ，则称 $S$ 是 $T$ 的一个子集，记为 $S \\subset T$ 设 $S,T$ 为两个集合，若 $S \\subset T, T \\subset S$ ，则称 $S$ 与 $T$ 相等，记为 $S=T$ 设 $S,T$ 为两个集合，将集合 ${ x \\big| x \\in S \\land x \\in T }$ 称为 $S$ 与 $T$ 的交集，记为 $S \\cap T$ ；将集合 ${ x \\big| x \\in S \\lor x \\in T }$ 称为 $S$ 与 $T$ 的并集，记为 $S \\cup T$","text":"定义 若 $a$ 为 $S$ 中的一个元素，则称 $a$ 包含于 $S$ ，记为 $a \\in S$ ；若 $a$ 不为 $S$ 中的任一元素，则称 $a$ 不包含于 $S$ ，记为 $a \\notin S$ 设 $S,T$ 为两个集合，若 $\\forall a \\in S$ ，成立 $a \\in T$ ，则称 $S$ 是 $T$ 的一个子集，记为 $S \\subset T$ 设 $S,T$ 为两个集合，若 $S \\subset T, T \\subset S$ ，则称 $S$ 与 $T$ 相等，记为 $S=T$ 设 $S,T$ 为两个集合，将集合 ${ x \\big| x \\in S \\land x \\in T }$ 称为 $S$ 与 $T$ 的交集，记为 $S \\cap T$ ；将集合 ${ x \\big| x \\in S \\lor x \\in T }$ 称为 $S$ 与 $T$ 的并集，记为 $S \\cup T$ 设 $S,T$ 为两个集合，将集合 ${ x \\big| x \\in S \\land x \\notin T }$ 称为 $S$ 与 $T$ 的差集，记为 $S \\setminus T$ 设 $S,T$ 为两个集合，若 $T \\subset S$ ，则将集合 $S \\setminus T$ 称为 $T$ 在 $S$ 中的的补集，记为 $\\complement_S{T}$ 设 $S,T$ 为两个集合，则将集合 ${(x,y) \\big| x \\in S, y \\in T}$ 称为 $S$ 与 $T$ 的笛卡尔积 ，记为 $S \\times T$ ；将 $\\underbrace{X \\times X \\times … \\times X}_{k个}$ 简记为 $X^k$ 设 $S$ 为一个集合，则将 $S$ 中元素的个数记为 $S$ 的基数，记为 $|S|$ 基本性质1、（集合分配律）设 $R,S,T$ 为三个集合，则 ① $R \\cap (S \\cup T)=(R \\cap S) \\cup (R \\cap T)$ ② $R \\cup (S \\cap T) = (R \\cup S) \\cap (R \\cup T)$ 证明：① $\\forall x \\in R \\cap (S \\cup T)$ $\\therefore x \\in R$ 且 $x \\in S \\cup T$ $\\therefore$ （ $x \\in R$ 且 $x \\in S$ ） 或 （ $x \\in R 且 x \\in T$ ） $ \\therefore x \\in (R \\cap S) \\cup (R \\cap T)$ $\\therefore$ 由定义2可知， $R \\cap (S \\cup T)\\subset (R \\cap S) \\cup (R \\cap T)$ 反之， $\\forall x \\in (R \\cap S) \\cup (R \\cap T)$ $\\therefore$ $x \\in R \\cap S$ 或 $x \\in R \\cap T$ $\\therefore x \\in R$ 且（ $x \\in S$ 或 $x \\in T$ ） $\\therefore$ 由定义2可知，$(R \\cap S) \\cup (R \\cap T) \\subset R \\cap (S \\cup T)$ $\\therefore$ 由定义3可知， $R \\cap (S \\cup T)=(R \\cap S) \\cup (R \\cap T)$ ② 同理即可证得结论 2、 设 $X,Y$ 为两个集合，且 $|X|=n,|Y|=m$ ，则 ① $|X \\times Y|=n \\cdot m$ ② $|X \\cup Y|=n +m-|X \\cap Y|$","categories":[],"tags":[{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Algebra","slug":"Algebra","permalink":"http://gonggongjohn.github.io/blog/tags/Algebra/"}]}],"categories":[],"tags":[{"name":"Computer-Science","slug":"Computer-Science","permalink":"http://gonggongjohn.github.io/blog/tags/Computer-Science/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://gonggongjohn.github.io/blog/tags/Algorithm/"},{"name":"Mathematics","slug":"Mathematics","permalink":"http://gonggongjohn.github.io/blog/tags/Mathematics/"},{"name":"Sequence","slug":"Sequence","permalink":"http://gonggongjohn.github.io/blog/tags/Sequence/"},{"name":"CSAPP","slug":"CSAPP","permalink":"http://gonggongjohn.github.io/blog/tags/CSAPP/"},{"name":"Language","slug":"Language","permalink":"http://gonggongjohn.github.io/blog/tags/Language/"},{"name":"Analysis","slug":"Analysis","permalink":"http://gonggongjohn.github.io/blog/tags/Analysis/"},{"name":"Algebra","slug":"Algebra","permalink":"http://gonggongjohn.github.io/blog/tags/Algebra/"}]}